/**
 * Export Manager Module
 * Handles all export functionality
 */
class ExportManager {
    constructor(labelingTool) {
        this.labelingTool = labelingTool;
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Export modal kontrolleri - g√ºvenli element kontrol√º
        const closeExport = document.getElementById('closeExport');
        const cancelExport = document.getElementById('cancelExport');
        const confirmExport = document.getElementById('confirmExport');
        const previewExport = document.getElementById('previewExport');

        if (closeExport) closeExport.addEventListener('click', () => this.closeExportModal());
        if (cancelExport) cancelExport.addEventListener('click', () => this.closeExportModal());
        if (confirmExport) confirmExport.addEventListener('click', () => this.performExport());
        if (previewExport) previewExport.addEventListener('click', () => this.previewExport());

        // Train split deƒüi≈ütiƒüinde val split'i g√ºncelle
        const trainSplit = document.getElementById('trainSplit');
        if (trainSplit) {
            trainSplit.addEventListener('input', (e) => {
                const trainValue = parseInt(e.target.value);
                const valSplit = document.getElementById('valSplit');
                if (valSplit) valSplit.value = 100 - trainValue;
                this.updateExportPreview();
            });
        }

        // Image quality slider
        const imageQuality = document.getElementById('imageQuality');
        if (imageQuality) {
            imageQuality.addEventListener('input', (e) => {
                const qualityValue = document.getElementById('qualityValue');
                if (qualityValue) qualityValue.textContent = e.target.value + '%';
                this.updateExportPreview();
            });
        }

        // Export options change
        ['includeImages', 'includeCrops', 'includeDescriptions', 'normalizeCoordinates', 'includeMetadata', 'compressOutput', 'exportLabelCaseMode'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', () => this.updateExportPreview());
            }
        });

        // Format change
        document.querySelectorAll('input[name="exportFormat"]').forEach(radio => {
            radio.addEventListener('change', () => this.updateExportPreview());
        });

        // Class mapping buttons
        const autoMapClasses = document.getElementById('autoMapClasses');
        const resetClassMapping = document.getElementById('resetClassMapping');
        if (autoMapClasses) autoMapClasses.addEventListener('click', () => this.autoMapClasses());
        if (resetClassMapping) resetClassMapping.addEventListener('click', () => this.resetClassMapping());

        // Modal dƒ±≈üƒ±na tƒ±klama
        window.addEventListener('click', (e) => {
            const exportModal = document.getElementById('exportModal');
            if (e.target === exportModal) this.closeExportModal();
        });
    }

    showExportModal() {
        // Class mapping'i g√ºncelle
        this.updateClassMapping();
        
        // Export preview'ƒ± g√ºncelle
        this.updateExportPreview();
        
        const modal = document.getElementById('exportModal');
        if (modal) modal.classList.add('show');
    }

    closeExportModal() {
        const modal = document.getElementById('exportModal');
        if (modal) modal.classList.remove('show');
    }

    updateClassMapping() {
        const container = document.getElementById('classMapping');
        if (!container) return;
        container.innerHTML = '';

        (this.labelingTool.availableLabels || []).forEach((label, index) => {
            const mappingDiv = document.createElement('div');
            mappingDiv.style.margin = '5px 0';
            mappingDiv.innerHTML = `
                <label style="display: flex; align-items: center; gap: 10px; color: #ecf0f1; font-size: 14px;">
                    <span style="min-width: 100px;">${label}:</span>
                    <input type="number" name="class_${index}" class="input" 
                           style="width: 60px; text-align: center;" 
                           placeholder="ID" min="0" max="999">
                </label>
            `;
            container.appendChild(mappingDiv);
        });
    }

    getClassMapping() {
        const mapping = {};
        (this.labelingTool.availableLabels || []).forEach((label, index) => {
            const input = document.querySelector(`input[name="class_${index}"]`);
            const value = input ? parseInt(input.value) : null;
            if (value !== null && !isNaN(value)) {
                mapping[label] = value;
            }
        });
        return mapping;
    }

    getExportOptions() {
        const getElementValue = (id, defaultValue = false) => {
            const element = document.getElementById(id);
            return element ? element.checked || element.value : defaultValue;
        };

        return {
            includeImages: getElementValue('includeImages', false),
            includeCrops: getElementValue('includeCrops', false),
            includeDescriptions: getElementValue('includeDescriptions', false),
            normalizeCoordinates: getElementValue('normalizeCoordinates', false),
            includeMetadata: getElementValue('includeMetadata', false),
            compressOutput: getElementValue('compressOutput', false),
            imageQuality: parseInt(getElementValue('imageQuality', 100)) / 100,
            exportLabelCaseMode: getElementValue('exportLabelCaseMode', 'original'),
            exportFolderPath: this.labelingTool.exportFolderPath
        };
    }

    updateExportPreview() {
        // Export preview'ƒ± g√ºncelle
        const updateElement = (id, text) => {
            const element = document.getElementById(id);
            if (element) element.textContent = text;
        };

        try {
            // ImageManager kontrol√º
            let imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
            
            if (!imageManager) {
                updateElement('exportPreview', '‚ö†Ô∏è ImageManager bulunamadƒ±!');
                return;
            }
            
            if (!imageManager.currentProject) {
                updateElement('exportPreview', '‚ö†Ô∏è Aktif proje yok, preview g√ºncellenemiyor.');
                return;
            }
            
            // Proje bilgilerini al
            const project = imageManager.currentProject;
            const totalImages = project.total_images || 0;
            const labeledImages = project.labeled_images || 0;
            
            // Format bilgisini al
        const formatElement = document.querySelector('input[name="exportFormat"]:checked');
        const format = formatElement ? formatElement.value : 'yolo';
            
            // Train/val split bilgisini al
            const trainSplitElement = document.getElementById('trainSplit');
            const trainSplit = trainSplitElement ? parseInt(trainSplitElement.value) / 100 : 0.8;
            const valSplit = 1 - trainSplit;
            
            // Export se√ßeneklerini al
            const includeImages = document.getElementById('includeImages')?.checked || true;
            const normalizeCoordinates = document.getElementById('normalizeCoordinates')?.checked || true;
            
            // Preview metnini olu≈ütur
            let previewText = `üìä Proje: ${project.name}\n`;
            previewText += `üìà Toplam Resim: ${totalImages}\n`;
            previewText += `üè∑Ô∏è Etiketli Resim: ${labeledImages}\n`;
            previewText += `üìÅ Format: ${format.toUpperCase()}\n`;
            previewText += `üìä Train/Val: ${Math.round(trainSplit * 100)}%/${Math.round(valSplit * 100)}%\n`;
            previewText += `üñºÔ∏è Resimler Dahil: ${includeImages ? 'Evet' : 'Hayƒ±r'}\n`;
            previewText += `üìè Koordinat Normalize: ${normalizeCoordinates ? 'Evet' : 'Hayƒ±r'}`;
            
            updateElement('exportPreview', previewText);
            
        } catch (error) {
            console.error('Export preview g√ºncellenirken hata:', error);
            updateElement('exportPreview', '‚ùå Preview g√ºncellenemedi: ' + error.message);
        }
    }


    

    async previewExport() {
        try {
            // ImageManager kontrol√º
            if (!this.labelingTool.imageManager) {
                this.labelingTool.showError('ImageManager bulunamadƒ±! L√ºtfen sayfayƒ± yenileyin.');
                return;
            }
            
            if (!this.labelingTool.imageManager.currentProject) {
                this.labelingTool.showError('Aktif proje bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
                return;
            }
            
        const formatElement = document.querySelector('input[name="exportFormat"]:checked');
        const format = formatElement ? formatElement.value : 'yolo';
        const exportOptions = this.getExportOptions();
            
            // Proje verilerini al
            const projectData = await this.getProjectData();
            const { images, annotations } = projectData;
            const totalAnnotations = Object.values(annotations).flat().length;
            const totalImages = images.length;
        
        let preview = `üìã Export √ñnizleme:\n\n`;
        preview += `Format: ${format.toUpperCase()}\n`;
            preview += `Proje: ${this.labelingTool.imageManager.currentProject.name}\n`;
            preview += `Toplam Resim: ${totalImages}\n`;
            preview += `Toplam Etiket: ${totalAnnotations}\n`;
        preview += `Resimler: ${exportOptions.includeImages ? 'Dahil' : 'Dahil Deƒüil'}\n`;
        preview += `Kƒ±rpƒ±lmƒ±≈ü Resimler: ${exportOptions.includeCrops ? 'Dahil' : 'Dahil Deƒüil'}\n`;
        preview += `A√ßƒ±klamalar: ${exportOptions.includeDescriptions ? 'Dahil' : 'Dahil Deƒüil'}\n`;
        preview += `Koordinat Normalle≈ütirme: ${exportOptions.normalizeCoordinates ? 'A√ßƒ±k' : 'Kapalƒ±'}\n`;
        preview += `Metadata: ${exportOptions.includeMetadata ? 'Dahil' : 'Dahil Deƒüil'}\n`;
        preview += `Sƒ±kƒ±≈ütƒ±rma: ${exportOptions.compressOutput ? 'A√ßƒ±k' : 'Kapalƒ±'}\n`;
        preview += `Resim Kalitesi: ${Math.round(exportOptions.imageQuality * 100)}%\n`;
        preview += `Etiket Harf Durumu: ${exportOptions.exportLabelCaseMode === 'uppercase' ? 'B√ºy√ºk Harf' : exportOptions.exportLabelCaseMode === 'lowercase' ? 'K√º√ß√ºk Harf' : 'Default'}\n`;
        preview += `Kayƒ±t Konumu: ${exportOptions.exportFolderPath || 'ƒ∞ndirilenler klas√∂r√º'}\n`;
        
        this.labelingTool.showInfo(preview);
            
        } catch (error) {
            console.error('Export preview hatasƒ±:', error);
            this.labelingTool.showError('Export preview olu≈üturulamadƒ±: ' + error.message);
        }
    }

    autoMapClasses() {
        (this.labelingTool.availableLabels || []).forEach((label, index) => {
            const input = document.querySelector(`input[name="class_${index}"]`);
            if (input) {
                input.value = index;
            }
        });
        this.updateExportPreview();
        this.labelingTool.showToast('Sƒ±nƒ±f e≈üleme otomatik olarak yapƒ±ldƒ±!', 'success');
    }

    resetClassMapping() {
        (this.labelingTool.availableLabels || []).forEach((label, index) => {
            const input = document.querySelector(`input[name="class_${index}"]`);
            if (input) {
                input.value = '';
            }
        });
        this.updateExportPreview();
        this.labelingTool.showToast('Sƒ±nƒ±f e≈üleme sƒ±fƒ±rlandƒ±!', 'info');
    }

    async performExport() {
        const formatElement = document.querySelector('input[name="exportFormat"]:checked');
        const format = formatElement ? formatElement.value : 'yolo';
        
        const trainSplitElement = document.getElementById('trainSplit');
        const trainSplit = trainSplitElement ? parseInt(trainSplitElement.value) / 100 : 0.8;
        
        // Basit export options
        const exportOptions = {
            includeImages: document.getElementById('includeImages')?.checked || true,
            normalizeCoordinates: document.getElementById('normalizeCoordinates')?.checked || true,
            exportLabelCaseMode: 'original'
        };

        // Modal'ƒ± √∂nce kapat (showSaveFilePicker i√ßin gerekli)
        this.closeExportModal();

        try {
            // ImageManager kontrol√º - ana sayfadaki yoloExport gibi
            let imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager;
            
            if (!imageManager) {
                this.labelingTool.showError('ImageManager bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
                return;
            }
            
            // Auth kontrol√º - ana sayfadaki gibi
            if (!imageManager.auth) {
                if (window.labelingTool?.auth) {
                    imageManager.auth = window.labelingTool.auth;
                } else if (window.labelingAuth) {
                    imageManager.auth = window.labelingAuth;
                } else {
                    this.labelingTool.showError('Auth objesi bulunamadƒ±! L√ºtfen sayfayƒ± yenileyin.');
                    return;
                }
            }

            // Aktif proje yoksa otomatik proje se√ßmeye √ßalƒ±≈ü - ana sayfadaki gibi
            if (!imageManager.currentProject) {
                try {
                    const projectsResponse = await imageManager.auth.makeRequest(`${imageManager.baseURL}/projects`);
                    if (projectsResponse.ok) {
                        const projects = await projectsResponse.json();
                        if (projects.length > 0) {
                            await imageManager.setProject(projects[0].id);
                        } else {
                            this.labelingTool.showError('Hi√ß proje bulunamadƒ±! L√ºtfen √∂nce bir proje olu≈üturun.');
                            return;
                        }
                    } else {
                        this.labelingTool.showError('Projeler alƒ±namadƒ±! L√ºtfen sayfayƒ± yenileyin.');
                        return;
                    }
                } catch (error) {
                    this.labelingTool.showError('Proje kontrol edilemedi! L√ºtfen sayfayƒ± yenileyin.');
                    return;
                }
            }

            switch (format) {
                case 'yolo':
                    // Sidebar'daki yoloExport fonksiyonunu kullan
                    if (this.labelingTool.yoloExport) {
                        await this.labelingTool.yoloExport();
                    } else {
                        await this.exportYOLO(trainSplit, {}, exportOptions);
                    }
                    break;
                case 'yolo_segmentation':
                    await this.exportYOLOSegmentation(trainSplit, {}, exportOptions);
                    break;
                case 'coco':
                    await this.exportCOCO(trainSplit, {}, exportOptions);
                    break;
                default:
                    this.labelingTool.showError('Desteklenmeyen format: ' + format);
                    return;
            }
            
        } catch (error) {
            console.error('Export hatasƒ±:', error);
            this.labelingTool.showError('Export i≈ülemi sƒ±rasƒ±nda hata olu≈ütu: ' + error.message);
        }
    }

    // Export methods implementation
    async exportYOLO(trainSplit, classMapping, exportOptions) {
        if (!this.labelingTool.imageManager || !this.labelingTool.imageManager.currentProject) {
            this.labelingTool.showError('Proje bulunamadƒ±!');
            return;
        }

        try {
            this.labelingTool.showInfo('YOLO formatƒ±nda export ba≈ülatƒ±lƒ±yor...');
            
            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const projectName = this.labelingTool.imageManager.currentProject.name || 'dataset';
            const projectFolder = zip.folder(projectName);
            
            // T√ºm proje verilerini al
            const projectData = await this.getProjectData();
            const { images, annotations, weatherFilters } = projectData;
            
            // Class mapping olu≈ütur (eƒüer bo≈üsa)
            if (!classMapping || Object.keys(classMapping).length === 0) {
                const allLabels = new Set();
                Object.values(annotations).flat().forEach(annotation => {
                    if (annotation.label) {
                        allLabels.add(annotation.label);
                    }
                });
                
                classMapping = {};
                Array.from(allLabels).forEach((label, index) => {
                    classMapping[label] = index;
                });
                
                console.log('üìä Olu≈üturulan class mapping:', classMapping);
            }
            
            // Train/Val split hesapla
            const shuffledImages = this.shuffleArray([...images]);
            const trainCount = Math.floor(shuffledImages.length * trainSplit);
            const trainImages = shuffledImages.slice(0, trainCount);
            const valImages = shuffledImages.slice(trainCount);
            
            // YOLO format dosyalarƒ± olu≈ütur
            await this.createYOLOFiles(projectFolder, trainImages, valImages, annotations, classMapping, exportOptions, weatherFilters);
            
            // ZIP'i kaydet
            await this.saveZipFile(zip, `${projectName}_yolo.zip`);
            
            this.labelingTool.showInfo('YOLO export tamamlandƒ±! Sayfa yeniden ba≈ülatƒ±lƒ±yor...');
            
            // Export tamamlandƒ±ktan sonra sayfayƒ± yeniden ba≈ülat
            setTimeout(() => {
                window.location.reload();
            }, 1500);
            
        } catch (error) {
            console.error('YOLO export hatasƒ±:', error);
            this.labelingTool.showError('YOLO export hatasƒ±: ' + error.message);
        }
    }

    // YOLO Segmentation Export (polygon koordinatlarƒ± ile)
    async exportYOLOSegmentation(trainSplit, classMapping, exportOptions) {
        // ImageManager kontrol√º
        const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
        if (!imageManager || !imageManager.currentProject) {
            this.labelingTool.showError('Proje bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
            return;
        }

        try {
            this.labelingTool.showInfo('YOLO Segmentation formatƒ±nda export ba≈ülatƒ±lƒ±yor...');
            
            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const projectName = imageManager.currentProject.name || 'dataset';
            const projectFolder = zip.folder(projectName);
            
            // T√ºm proje verilerini al
            const projectData = await this.getProjectData();
            const { images, annotations, weatherFilters } = projectData;
            
            // Class mapping olu≈ütur (eƒüer bo≈üsa)
            if (!classMapping || Object.keys(classMapping).length === 0) {
                const allLabels = new Set();
                Object.values(annotations).flat().forEach(annotation => {
                    if (annotation.label) {
                        allLabels.add(annotation.label);
                    }
                });
                
                classMapping = {};
                Array.from(allLabels).forEach((label, index) => {
                    classMapping[label] = index;
                });
                
                console.log('üìä Olu≈üturulan class mapping:', classMapping);
            }
            
            // Train/Val split hesapla
            const shuffledImages = this.shuffleArray([...images]);
            const trainCount = Math.floor(shuffledImages.length * trainSplit);
            const trainImages = shuffledImages.slice(0, trainCount);
            const valImages = shuffledImages.slice(trainCount);
            
            // YOLO Segmentation format dosyalarƒ± olu≈ütur
            await this.createYOLOSegmentationFiles(projectFolder, trainImages, valImages, annotations, classMapping, exportOptions, weatherFilters);
            
            // ZIP'i kaydet
            await this.saveZipFile(zip, `${projectName}_yolo_segmentation.zip`);
            
            this.labelingTool.showInfo('YOLO Segmentation export tamamlandƒ±! Sayfa yeniden ba≈ülatƒ±lƒ±yor...');
            
            // Export tamamlandƒ±ktan sonra sayfayƒ± yeniden ba≈ülat
            setTimeout(() => {
                window.location.reload();
            }, 1500);
            
        } catch (error) {
            console.error('YOLO Segmentation export hatasƒ±:', error);
            this.labelingTool.showError('YOLO Segmentation export hatasƒ±: ' + error.message);
        }
    }

    async exportCOCO(trainSplit, classMapping, exportOptions) {
        const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
        if (!imageManager || !imageManager.currentProject) {
            this.labelingTool.showError('Proje bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
            return;
        }

        try {
            this.labelingTool.showInfo('COCO formatƒ±nda export ba≈ülatƒ±lƒ±yor...');
            
            // Proje verilerini al
            const projectData = await this.getProjectData();
            const { images, annotations } = projectData;
            
            // COCO format JSON olu≈ütur
            const cocoData = this.createCOCOFormat(images, annotations, classMapping, exportOptions);
            
            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const projectName = imageManager.currentProject.name || 'dataset';
            const projectFolder = zip.folder(projectName);
            
            // COCO JSON dosyasƒ±nƒ± ekle
            projectFolder.file('annotations.json', JSON.stringify(cocoData, null, 2));
            
            // Resimleri ekle (eƒüer isteniyorsa)
            if (exportOptions.includeImages) {
                await this.addImagesToZip(projectFolder, images, exportOptions);
            }
            
            // ZIP'i kaydet
            await this.saveZipFile(zip, `${projectName}_coco.zip`);
            
            this.labelingTool.showInfo('COCO export tamamlandƒ±! Sayfa yeniden ba≈ülatƒ±lƒ±yor...');
            
            // Export tamamlandƒ±ktan sonra sayfayƒ± yeniden ba≈ülat
            setTimeout(() => {
                window.location.reload();
            }, 1500);
            
        } catch (error) {
            console.error('COCO export hatasƒ±:', error);
            this.labelingTool.showError('COCO export hatasƒ±: ' + error.message);
        }
    }

    async exportPascalVOC(trainSplit, classMapping, exportOptions) {
        const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
        if (!imageManager || !imageManager.currentProject) {
            this.labelingTool.showError('Proje bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
            return;
        }

        try {
            this.labelingTool.showInfo('Pascal VOC formatƒ±nda export ba≈ülatƒ±lƒ±yor...');
            
            // Proje verilerini al
            const projectData = await this.getProjectData();
            const { images, annotations } = projectData;
            
            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const projectName = imageManager.currentProject.name || 'dataset';
            const projectFolder = zip.folder(projectName);
            
            // Pascal VOC XML dosyalarƒ± olu≈ütur
            await this.createPascalVOCFiles(projectFolder, images, annotations, classMapping, exportOptions);
            
            // ZIP'i kaydet
            await this.saveZipFile(zip, `${projectName}_pascal_voc.zip`);
            
            this.labelingTool.showInfo('Pascal VOC export tamamlandƒ±!');
            
        } catch (error) {
            console.error('Pascal VOC export hatasƒ±:', error);
            this.labelingTool.showError('Pascal VOC export hatasƒ±: ' + error.message);
        }
    }

    async exportJSON(exportOptions) {
        const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
        if (!imageManager || !imageManager.currentProject) {
            this.labelingTool.showError('Proje bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
            return;
        }

        try {
            this.labelingTool.showInfo('JSON formatƒ±nda export ba≈ülatƒ±lƒ±yor...');
            
            // Proje verilerini al
            const projectData = await this.getProjectData();
            const projectName = imageManager.currentProject.name || 'dataset';
            
            // JSON dosyasƒ±nƒ± olu≈ütur
            const jsonData = this.createJSONFormat(projectData, exportOptions);
            
            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const projectFolder = zip.folder(projectName);
            
            // JSON dosyasƒ±nƒ± ekle
            projectFolder.file('annotations.json', JSON.stringify(jsonData, null, 2));
            
            // Resimleri ekle (eƒüer isteniyorsa)
            if (exportOptions.includeImages) {
                await this.addImagesToZip(projectFolder, projectData.images, exportOptions);
            }
            
            // ZIP'i kaydet
            await this.saveZipFile(zip, `${projectName}_json.zip`);
            
            this.labelingTool.showInfo('JSON export tamamlandƒ±!');
            
        } catch (error) {
            console.error('JSON export hatasƒ±:', error);
            this.labelingTool.showError('JSON export hatasƒ±: ' + error.message);
        }
    }

    async exportCSV(classMapping, exportOptions) {
        const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
        if (!imageManager || !imageManager.currentProject) {
            this.labelingTool.showError('Proje bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
            return;
        }

        try {
            this.labelingTool.showInfo('CSV formatƒ±nda export ba≈ülatƒ±lƒ±yor...');
            
            // Proje verilerini al
            const projectData = await this.getProjectData();
            const { images, annotations } = projectData;
            
            // CSV dosyasƒ± olu≈ütur
            const csvData = this.createCSVFormat(images, annotations, classMapping, exportOptions);
            
            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const projectName = imageManager.currentProject.name || 'dataset';
            const projectFolder = zip.folder(projectName);
            
            // CSV dosyasƒ±nƒ± ekle
            projectFolder.file('annotations.csv', csvData);
            
            // Resimleri ekle (eƒüer isteniyorsa)
            if (exportOptions.includeImages) {
                await this.addImagesToZip(projectFolder, images, exportOptions);
            }
            
            // ZIP'i kaydet
            await this.saveZipFile(zip, `${projectName}_csv.zip`);
            
            this.labelingTool.showInfo('CSV export tamamlandƒ±!');
            
        } catch (error) {
            console.error('CSV export hatasƒ±:', error);
            this.labelingTool.showError('CSV export hatasƒ±: ' + error.message);
        }
    }

    // Export i√ßin etiket ismini d√∂n√º≈üt√ºr
    transformLabelForExport(labelName, exportOptions) {
        if (!labelName) return labelName;
        
        // √ñnce bo≈üluklarƒ± _ ile deƒüi≈ütir
        let transformedName = labelName.replace(/\s+/g, '_');
        
        // Sonra export harf durumunu uygula
        switch (exportOptions.exportLabelCaseMode) {
            case 'uppercase':
                return transformedName.toUpperCase();
            case 'lowercase':
                return transformedName.toLowerCase();
            case 'original':
            default:
                return transformedName;
        }
    }

    // Kullanƒ±cƒ±nƒ±n belirttiƒüi yere kaydet
    async saveAsExport() {
        try {
            this.labelingTool.showInfo('Export hazƒ±rlanƒ±yor...');
            
            // Export se√ßeneklerini al
            const exportOptions = this.getExportOptions();
            
            // Proje verilerini al
            const projectData = await this.prepareExportData();
            const { images, annotations } = projectData;
            
            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
            const projectName = imageManager?.currentProject?.name || 'dataset';
            const projectFolder = zip.folder(projectName);
            
            // Resimleri ekle (eƒüer isteniyorsa)
            if (exportOptions.includeImages) {
                await this.addImagesToZip(projectFolder, images, exportOptions);
            }
            
            // JSON formatƒ±nda annotation'larƒ± ekle
            const jsonData = this.createJSONFormat(projectData, exportOptions);
            projectFolder.file('annotations.json', JSON.stringify(jsonData, null, 2));
            
            // ZIP'i blob olarak olu≈ütur
            const content = await zip.generateAsync({type: "blob"});
            
            // Dosya adƒ±nƒ± olu≈ütur
            const fileName = `${projectName}_dataset.zip`;
            
            // Kullanƒ±cƒ±dan dosya konumu se√ßmesini iste
            if ('showSaveFilePicker' in window) {
                // Modern tarayƒ±cƒ±lar i√ßin File System Access API
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: fileName,
                        types: [{
                            description: 'ZIP dosyalarƒ±',
                            accept: {
                                'application/zip': ['.zip']
                            }
                        }]
                    });
                    
                    // Dosyayƒ± yaz
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    
                    this.labelingTool.showInfo('Dosya ba≈üarƒ±yla kaydedildi!');
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        this.labelingTool.showInfo('Kaydetme iptal edildi.');
                        return;
                    }
                    throw error;
                }
            } else {
                // Eski tarayƒ±cƒ±lar i√ßin fallback
                this.fallbackDownload(content, fileName);
            }
            
        } catch (error) {
            console.error('Save As export hatasƒ±:', error);
            this.labelingTool.showError('Export sƒ±rasƒ±nda hata olu≈ütu: ' + error.message);
        }
    }

    // Otomatik indirme fonksiyonu
    fallbackDownload(content, fileName) {
        try {
            console.log('üì• Dosya indiriliyor:', fileName, 'Boyut:', content.size, 'bytes');
            
            const blobUrl = URL.createObjectURL(content);
            const downloadLink = document.createElement('a');
            downloadLink.href = blobUrl;
            downloadLink.download = fileName;
            downloadLink.style.display = 'none';
            
            // DOM'a ekle ve tƒ±kla
            document.body.appendChild(downloadLink);
            downloadLink.click();
            
            // Temizle
            setTimeout(() => {
                document.body.removeChild(downloadLink);
                URL.revokeObjectURL(blobUrl);
                console.log('‚úÖ Dosya indirme tamamlandƒ±:', fileName);
            }, 1000);
            
        } catch (error) {
            console.error('‚ùå Dosya indirme hatasƒ±:', error);
            this.labelingTool.showError('Dosya indirilemedi: ' + error.message);
        }
    }

    // YOLO Format Export - T√ºm proje i√ßin (Optimize edilmi≈ü)
    async cropAndSaveAs() {
        try {
            console.log('üîç YOLO Format Export ba≈ülatƒ±lƒ±yor...');
            console.log('üîç labelingTool:', this.labelingTool);
            console.log('üîç imageManager:', this.labelingTool?.imageManager);
            console.log('üîç currentProject:', this.labelingTool?.imageManager?.currentProject);
            
            this.labelingTool.showInfo('YOLO formatƒ±nda dataset hazƒ±rlanƒ±yor...');
            
            // ImageManager kontrol√º - script.js'deki imageManager'ƒ± kullan
            const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager;
            if (!imageManager) {
                console.error('‚ùå ImageManager null!');
                this.labelingTool.showError('ImageManager bulunamadƒ±! L√ºtfen sayfayƒ± yenileyin.');
                return;
            }
            
            if (!imageManager.currentProject) {
                console.error('‚ùå currentProject null!');
                console.error('‚ùå imageManager detaylarƒ±:', {
                    currentProject: imageManager.currentProject,
                    totalImages: imageManager.totalImages,
                    currentImageIndex: imageManager.currentImageIndex
                });
                this.labelingTool.showError('Aktif proje bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
                return;
            }
            
            // Proje verilerini al
            const projectData = await this.getProjectData();
            const { images, annotations, weatherFilters = {} } = projectData;
            
            if (images.length === 0) {
                this.labelingTool.showWarning('Projede hi√ß resim bulunamadƒ±!');
                return;
            }
            
            console.log('üìä Export verileri:', {
                images: images.length,
                annotations: Object.keys(annotations).length,
                weatherFilters: Object.keys(weatherFilters).length
            });
            
            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const projectName = imageManager.currentProject.name || 'dataset';
            const datasetFolder = zip.folder(projectName);
            
            // YOLO klas√∂r yapƒ±sƒ±nƒ± olu≈ütur
            const imagesFolder = datasetFolder.folder('images');
            const labelsFolder = datasetFolder.folder('labels');
            const trainImagesFolder = imagesFolder.folder('train');
            const valImagesFolder = imagesFolder.folder('val');
            const trainLabelsFolder = labelsFolder.folder('train');
            const valLabelsFolder = labelsFolder.folder('val');
            
            // Train/Val split hesapla (80/20)
            const shuffledImages = this.shuffleArray([...images]);
            const trainCount = Math.floor(shuffledImages.length * 0.8);
            const trainImages = shuffledImages.slice(0, trainCount);
            const valImages = shuffledImages.slice(trainCount);
            
            // Sƒ±nƒ±f mapping'i olu≈ütur
            const allLabels = new Set();
            console.log('üîç Annotations yapƒ±sƒ±:', annotations);
            
            Object.values(annotations).flat().forEach(annotation => {
                console.log('üîç Annotation:', annotation);
                if (annotation.label) {
                    allLabels.add(annotation.label);
                }
            });
            
            console.log('üîç Bulunan etiketler:', Array.from(allLabels));
            
            // Eƒüer hi√ß etiket yoksa uyarƒ± ver
            if (allLabels.size === 0) {
                this.labelingTool.showWarning('‚ö†Ô∏è Projede hi√ß etiket bulunamadƒ±!\n\nL√ºtfen √∂nce resimlere etiket ekleyin:\n1. Resim se√ßin\n2. Dikd√∂rtgen √ßizin\n3. Etiket adƒ± girin\n4. Kaydedin\n\nSonra tekrar export yapƒ±n.');
                return;
            }
            
            const classMapping = {};
            Array.from(allLabels).forEach((label, index) => {
                classMapping[label] = index;
            });
            
            console.log('üîç Class mapping:', classMapping);
            
            // Train set'i i≈üle
            for (const image of trainImages) {
                await this.addImageToYOLO(trainImagesFolder, trainLabelsFolder, image, annotations[image.id] || [], classMapping, { includeImages: true }, weatherFilters);
            }
            
            // Val set'i i≈üle
            for (const image of valImages) {
                await this.addImageToYOLO(valImagesFolder, valLabelsFolder, image, annotations[image.id] || [], classMapping, { includeImages: true }, weatherFilters);
            }
            
            // classes.txt dosyasƒ± olu≈ütur
            const classesContent = Array.from(allLabels).join('\n');
            datasetFolder.file('classes.txt', classesContent);
            
            // data.yaml dosyasƒ± olu≈ütur
            const yamlContent = this.createYOLOYaml(classMapping);
            datasetFolder.file('data.yaml', yamlContent);
            
            // ZIP'i blob olarak olu≈ütur
            const content = await zip.generateAsync({type: "blob"});
            
            // Dosya adƒ±nƒ± olu≈ütur
            const fileName = `${projectName}_yolo_dataset.zip`;
            
            // Export i≈ülemi sƒ±rasƒ±nda showSaveFilePicker √ßalƒ±≈ümaz, otomatik indirme kullan
            console.log('üíæ YOLO dataset olu≈üturuldu, otomatik indirme ba≈ülatƒ±lƒ±yor:', fileName);
            this.fallbackDownload(content, fileName);
            
            this.labelingTool.showInfo(`YOLO dataset ba≈üarƒ±yla kaydedildi!\nToplam: ${images.length} resim\nTrain: ${trainImages.length} resim\nVal: ${valImages.length} resim\nSƒ±nƒ±f sayƒ±sƒ±: ${allLabels.size}\n\nSayfa yeniden ba≈ülatƒ±lƒ±yor...`);
            
            // Export tamamlandƒ±ktan sonra sayfayƒ± yeniden ba≈ülat
            setTimeout(() => {
                window.location.reload();
            }, 2000);
            
        } catch (error) {
            console.error('YOLO Export hatasƒ±:', error);
            this.labelingTool.showError('YOLO export sƒ±rasƒ±nda hata olu≈ütu: ' + error.message);
        }
    }


    // Kƒ±rpƒ±lmƒ±≈ü g√∂r√ºnt√ºler i√ßin metadata olu≈ütur - G√ºncellenmi≈ü
    generateCropMetadata(projectName, images, annotations, totalCroppedImages) {
        const metadata = {
            projectName: projectName,
            exportDate: new Date().toISOString(),
            totalImages: totalCroppedImages,
            totalSourceImages: images.length,
            labels: {},
            images: [],
            statistics: {
                imagesWithAnnotations: 0,
                averageAnnotationsPerImage: 0
            }
        };

            let globalIndex = 1;
        let totalAnnotations = 0;
        
        // Her resim i√ßin i≈ülem
        images.forEach((image, imageIndex) => {
            const imageAnnotations = annotations[image.id] || [];
            
            if (imageAnnotations.length > 0) {
                metadata.statistics.imagesWithAnnotations++;
                totalAnnotations += imageAnnotations.length;
                
                imageAnnotations.forEach(annotation => {
                    const labelName = this.transformLabelForExport(annotation.label, {});
                    
                    if (!metadata.labels[labelName]) {
                        metadata.labels[labelName] = 0;
                    }
                    metadata.labels[labelName]++;
                    
                    metadata.images.push({
                        id: annotation.id,
                        label: annotation.label,
                        transformedLabel: labelName,
                        type: annotation.type,
                        fileName: `${labelName}_${globalIndex.toString().padStart(4, '0')}.jpg`,
                        sourceImageId: image.id,
                        sourceImageName: image.fileName,
                        sourceImageIndex: imageIndex,
                        globalIndex: globalIndex,
                        coordinates: {
                            x: annotation.x,
                            y: annotation.y,
                            width: annotation.width,
                            height: annotation.height
                        }
                    });
                    
                    globalIndex++;
                });
            }
        });
        
        // ƒ∞statistikleri hesapla
        if (metadata.statistics.imagesWithAnnotations > 0) {
            metadata.statistics.averageAnnotationsPerImage = 
                Math.round((totalAnnotations / metadata.statistics.imagesWithAnnotations) * 100) / 100;
        }
        
        // Label istatistikleri
        metadata.labelStatistics = Object.entries(metadata.labels)
            .sort(([,a], [,b]) => b - a)
            .map(([label, count]) => ({ label, count }));

        return metadata;
    }

    // Export verilerini hazƒ±rla
    async prepareExportData() {
        try {
            console.log('üîç Export verileri hazƒ±rlanƒ±yor...');
            
            // ImageManager'ƒ± doƒüru ≈üekilde al
            const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
            if (!imageManager) {
                console.error('‚ùå ImageManager bulunamadƒ±');
                console.error('‚ùå labelingTool:', this.labelingTool);
                console.error('‚ùå window.labelingTool:', window.labelingTool);
                console.error('‚ùå window.imageManager:', window.imageManager);
                throw new Error('ImageManager bulunamadƒ±');
            }

            console.log('üîç ImageManager bulundu:', imageManager);
            console.log('üîç currentProject:', imageManager.currentProject);

            if (!imageManager.currentProject || !imageManager.currentProject.id) {
                console.error('‚ùå Aktif proje bulunamadƒ±');
                console.error('‚ùå currentProject:', imageManager.currentProject);
                
                // Proje yoksa, mevcut projeleri listele ve ilkini se√ß
                try {
                    console.log('üîç Mevcut projeler kontrol ediliyor...');
                    const projectsResponse = await imageManager.auth.makeRequest(`${imageManager.baseURL}/projects`);
                    if (projectsResponse.ok) {
                        const projects = await projectsResponse.json();
                        console.log('üìÅ Mevcut projeler:', projects);
                        
                        if (projects.length > 0) {
                            console.log('üìÅ ƒ∞lk proje se√ßiliyor:', projects[0]);
                            await imageManager.setProject(projects[0].id);
                            
                            // Tekrar kontrol et
                            if (imageManager.currentProject) {
                                console.log('‚úÖ Proje ba≈üarƒ±yla se√ßildi:', imageManager.currentProject);
                            } else {
                                throw new Error('Proje se√ßilemedi! L√ºtfen manuel olarak bir proje se√ßin.');
                            }
                        } else {
                            throw new Error('Hi√ß proje bulunamadƒ±! L√ºtfen √∂nce bir proje olu≈üturun.');
                        }
                    } else {
                        throw new Error('Projeler listelenemedi!');
                    }
                } catch (projectError) {
                    console.error('‚ùå Proje se√ßme hatasƒ±:', projectError);
                throw new Error('Aktif proje bulunamadƒ±. L√ºtfen √∂nce bir proje se√ßin.');
                }
            }

            const projectId = imageManager.currentProject.id;
            console.log('üìä Proje verileri alƒ±nƒ±yor, Project ID:', projectId);
            
            // Tek API √ßaƒürƒ±sƒ± ile t√ºm proje verilerini al
            const response = await imageManager.auth.makeRequest(
                `${imageManager.baseURL}/projects/${projectId}/export-data`
            );
            
            if (!response.ok) {
                // Fallback: eski y√∂ntemle al
                console.log('‚ö†Ô∏è Export endpoint bulunamadƒ±, fallback kullanƒ±lƒ±yor...');
                return await this.getProjectDataFallback(projectId);
            }

            const projectData = await response.json();
            console.log('üìä Alƒ±nan resim sayƒ±sƒ±:', projectData.images.length);
            console.log('üìä Toplam annotation sayƒ±sƒ±:', Object.values(projectData.annotations).flat().length);
            
            return projectData;
        } catch (error) {
            console.error('‚ùå Export verileri hazƒ±rlanƒ±rken hata:', error);
            throw error;
        }
    }

    // Yardƒ±mcƒ± fonksiyonlar - Optimize edilmi≈ü versiyon
    async getProjectData() {
        console.log('üîç getProjectData √ßaƒürƒ±ldƒ±');
        console.log('üîç labelingTool:', this.labelingTool);
        console.log('üîç imageManager:', this.labelingTool?.imageManager);
        console.log('üîç currentProject:', this.labelingTool?.imageManager?.currentProject);
        
        // ImageManager'ƒ± doƒüru ≈üekilde al
        const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
        if (!imageManager) {
            console.error('‚ùå ImageManager bulunamadƒ±');
            throw new Error('ImageManager bulunamadƒ±');
        }

        console.log('üîç ImageManager durumu:', {
            currentProject: imageManager.currentProject,
            totalImages: imageManager.totalImages,
            currentImageIndex: imageManager.currentImageIndex
        });

        if (!imageManager.currentProject || !imageManager.currentProject.id) {
            console.error('‚ùå Aktif proje bulunamadƒ±');
            console.error('‚ùå currentProject:', imageManager.currentProject);
            
            // Proje yoksa, mevcut projeleri listele ve ilkini se√ß
            try {
                console.log('üîç Mevcut projeler kontrol ediliyor...');
                const projectsResponse = await imageManager.auth.makeRequest(`${imageManager.baseURL}/projects`);
                if (projectsResponse.ok) {
                    const projects = await projectsResponse.json();
                    console.log('üìÅ Mevcut projeler:', projects);
                    
                    if (projects.length > 0) {
                        console.log('üìÅ ƒ∞lk proje se√ßiliyor:', projects[0]);
                        await imageManager.setProject(projects[0].id);
                        
                        // Tekrar kontrol et
                        if (imageManager.currentProject) {
                            console.log('‚úÖ Proje ba≈üarƒ±yla se√ßildi:', imageManager.currentProject);
                        } else {
                            throw new Error('Proje se√ßilemedi! L√ºtfen manuel olarak bir proje se√ßin.');
                        }
                    } else {
                        throw new Error('Hi√ß proje bulunamadƒ±! L√ºtfen √∂nce bir proje olu≈üturun.');
                    }
                } else {
                    throw new Error('Projeler listelenemedi!');
                }
            } catch (projectError) {
                console.error('‚ùå Proje se√ßme hatasƒ±:', projectError);
                throw new Error('Aktif proje bulunamadƒ±. L√ºtfen √∂nce bir proje se√ßin.');
            }
        }

        const projectId = imageManager.currentProject.id;
        console.log('üìä Proje verileri alƒ±nƒ±yor, Project ID:', projectId);
        
        // Tek API √ßaƒürƒ±sƒ± ile t√ºm proje verilerini al
        const response = await imageManager.auth.makeRequest(
            `${imageManager.baseURL}/projects/${projectId}/export-data`
        );
        
        if (!response.ok) {
            // Fallback: eski y√∂ntemle al
            console.log('‚ö†Ô∏è Export endpoint bulunamadƒ±, fallback kullanƒ±lƒ±yor...');
            return await this.getProjectDataFallback(projectId);
        }

        const projectData = await response.json();
        console.log('üìä Alƒ±nan resim sayƒ±sƒ±:', projectData.images.length);
        console.log('üìä Toplam annotation sayƒ±sƒ±:', Object.values(projectData.annotations).flat().length);
        console.log('üìä Weather filters sayƒ±sƒ±:', Object.keys(projectData.weatherFilters || {}).length);
        
        return projectData;
    }

    // Fallback: eski y√∂ntemle veri alma - Veritabanƒ±ndan d√ºzg√ºn √ßek
    async getProjectDataFallback(projectId) {
        const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
        
        try {
            // Resimleri al
            const imagesResponse = await imageManager.auth.makeRequest(
                `${imageManager.baseURL}/projects/${projectId}/images`
            );
            
            if (!imagesResponse.ok) {
                throw new Error(`Proje verileri alƒ±namadƒ±: ${imagesResponse.status} ${imagesResponse.statusText}`);
            }

            const images = await imagesResponse.json();
            console.log('üìä Alƒ±nan resim sayƒ±sƒ±:', images.length);
            
            // Her resim i√ßin annotation'larƒ± veritabanƒ±ndan al
            const annotations = {};
            const weatherFilters = {};
            
            for (const image of images) {
                try {
                    // Annotation'larƒ± veritabanƒ±ndan al
                    const annotationsResponse = await imageManager.auth.makeRequest(
                        `${imageManager.baseURL}/images/${image.id}/annotations`
                    );
                    
                    if (annotationsResponse.ok) {
                        const annotationsData = await annotationsResponse.json();
                        console.log(`üîç Resim ${image.id} i√ßin annotation'lar:`, annotationsData);
                        
                        // Annotation verilerini i≈üle
                        const processedAnnotations = [];
                        
                        if (Array.isArray(annotationsData)) {
                            // Her annotation record'ƒ±nƒ± i≈üle
                            annotationsData.forEach(annRecord => {
                                if (annRecord.annotation_data) {
                                    let annotationData;
                                    try {
                                        annotationData = typeof annRecord.annotation_data === 'string' 
                                            ? JSON.parse(annRecord.annotation_data) 
                                            : annRecord.annotation_data;
                                    } catch (error) {
                                        console.warn(`Annotation ${annRecord.id} parse edilemedi:`, error);
                                        return;
                                    }
                                    
                                    if (annotationData && annotationData.annotations && Array.isArray(annotationData.annotations)) {
                                        // Her annotation'ƒ± i≈üle
                                        annotationData.annotations.forEach(annData => {
                                            const processedAnn = {
                                                id: annData.id || annRecord.id,
                                                label: annData.label,
                                                type: annData.type || 'rectangle',
                                                color: annData.color || '#007AFF',
                                                x: parseFloat(annData.x) || 0,
                                                y: parseFloat(annData.y) || 0,
                                                width: parseFloat(annData.width) || 0,
                                                height: parseFloat(annData.height) || 0,
                                                points: annData.points || [],
                                                imageWidth: image.width || 1280,
                                                imageHeight: image.height || 720
                                            };
                                            
                                            console.log('üîç ƒ∞≈ülenmi≈ü annotation:', processedAnn);
                                            processedAnnotations.push(processedAnn);
                                        });
                                    }
                                }
                            });
                        }
                        
                        annotations[image.id] = processedAnnotations;
                        console.log(`‚úÖ Resim ${image.id} i√ßin ${processedAnnotations.length} annotation i≈ülendi`);
                        
                    } else {
                        console.warn(`Resim ${image.id} i√ßin annotation'lar alƒ±namadƒ±:`, annotationsResponse.status);
                        annotations[image.id] = [];
                    }
                    
                    // Weather filter'ƒ± al
                    try {
                        const filterResponse = await imageManager.auth.makeRequest(
                            `${imageManager.baseURL}/images/${image.id}/weather-filter`
                        );
                        
                        if (filterResponse.ok) {
                            const filterData = await filterResponse.json();
                            if (filterData && filterData.type && filterData.type !== 'none') {
                                weatherFilters[image.id] = {
                                    type: filterData.type,
                                    data: filterData
                                };
                            }
                        }
                    } catch (error) {
                        console.warn(`Resim ${image.id} i√ßin weather filter alƒ±namadƒ±:`, error);
                    }
                    
                } catch (error) {
                    console.error(`Resim ${image.id} i≈ülenirken hata:`, error);
                    annotations[image.id] = [];
                }
            }

            console.log('üìä Toplam annotation sayƒ±sƒ±:', Object.values(annotations).flat().length);
            console.log('üå§Ô∏è Weather filter sayƒ±sƒ±:', Object.keys(weatherFilters).length);
            
            return { images, annotations, weatherFilters };
            
        } catch (error) {
            console.error('‚ùå Fallback veri alma hatasƒ±:', error);
            throw error;
        }
    }

    shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    async createYOLOFiles(projectFolder, trainImages, valImages, annotations, classMapping, exportOptions, weatherFilters = {}) {
        // Train/Val klas√∂rleri olu≈ütur
        const trainFolder = projectFolder.folder('train');
        const valFolder = projectFolder.folder('val');
        const trainImagesFolder = trainFolder.folder('images');
        const valImagesFolder = valFolder.folder('images');
        const trainLabelsFolder = trainFolder.folder('labels');
        const valLabelsFolder = valFolder.folder('labels');

        // Etiket kontrol√º
        const allLabels = new Set();
        Object.values(annotations).flat().forEach(annotation => {
            if (annotation.label) {
                allLabels.add(annotation.label);
            }
        });
        
        if (allLabels.size === 0) {
            this.labelingTool.showWarning('‚ö†Ô∏è Projede hi√ß etiket bulunamadƒ±!\n\nL√ºtfen √∂nce resimlere etiket ekleyin.');
            return;
        }

        // Train set
        for (const image of trainImages) {
            const imageAnnotations = annotations[image.id] || [];
            console.log(`üîç Train resim ${image.id} i√ßin annotation'lar:`, imageAnnotations);
            await this.addImageToYOLO(trainImagesFolder, trainLabelsFolder, image, imageAnnotations, classMapping, exportOptions, weatherFilters);
        }

        // Val set
        for (const image of valImages) {
            const imageAnnotations = annotations[image.id] || [];
            console.log(`üîç Val resim ${image.id} i√ßin annotation'lar:`, imageAnnotations);
            await this.addImageToYOLO(valImagesFolder, valLabelsFolder, image, imageAnnotations, classMapping, exportOptions, weatherFilters);
        }

        // YAML dosyasƒ± olu≈ütur
        const yamlContent = this.createYOLOYaml(classMapping);
        projectFolder.file('data.yaml', yamlContent);
        
        // classes.txt dosyasƒ± olu≈ütur (YOLO i√ßin gerekli)
        const classes = Object.keys(classMapping).sort((a, b) => classMapping[a] - classMapping[b]);
        const classesContent = classes.join('\n');
        projectFolder.file('classes.txt', classesContent);
    }

    async createYOLOSegmentationFiles(projectFolder, trainImages, valImages, annotations, classMapping, exportOptions, weatherFilters = {}) {
        // YOLO segmentation klas√∂r yapƒ±sƒ±: images/ ve labels/ ana klas√∂rler
        const imagesFolder = projectFolder.folder('images');
        const labelsFolder = projectFolder.folder('labels');
        
        // Train/Val alt klas√∂rleri
        const trainImagesFolder = imagesFolder.folder('train');
        const valImagesFolder = imagesFolder.folder('val');
        const trainLabelsFolder = labelsFolder.folder('train');
        const valLabelsFolder = labelsFolder.folder('val');

        // Train set
        for (const image of trainImages) {
            const imageAnnotations = annotations[image.id] || [];
            console.log(`üîç Train resim ${image.id} i√ßin annotation'lar:`, imageAnnotations);
            await this.addImageToYOLOSegmentation(trainImagesFolder, trainLabelsFolder, image, imageAnnotations, classMapping, exportOptions, weatherFilters);
        }

        // Val set
        for (const image of valImages) {
            const imageAnnotations = annotations[image.id] || [];
            console.log(`üîç Val resim ${image.id} i√ßin annotation'lar:`, imageAnnotations);
            await this.addImageToYOLOSegmentation(valImagesFolder, valLabelsFolder, image, imageAnnotations, classMapping, exportOptions, weatherFilters);
        }

        // YAML dosyasƒ± olu≈ütur
        const yamlContent = this.createYOLOSegmentationYaml(classMapping);
        projectFolder.file('data.yaml', yamlContent);
        
        // classes.txt dosyasƒ± olu≈ütur (YOLO segmentation i√ßin gerekli)
        const classes = Object.keys(classMapping).sort((a, b) => classMapping[a] - classMapping[b]);
        const classesContent = classes.join('\n');
        projectFolder.file('classes.txt', classesContent);
    }

    async addImageToYOLO(imagesFolder, labelsFolder, image, imageAnnotations, classMapping, exportOptions, weatherFilters = {}) {
        // Resim dosyasƒ±nƒ± ekle
        if (exportOptions.includeImages) {
            const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
            
            // Weather filter kontrol√º - export data'dan al
            let imageBlob;
            const weatherFilter = weatherFilters[image.id];
            
            if (weatherFilter && weatherFilter.type && weatherFilter.type !== 'none') {
                console.log(`üå§Ô∏è Resim ${image.id} i√ßin filtre uygulanƒ±yor:`, weatherFilter.type);
                try {
                    // Filtrelenmi≈ü resmi al
                    imageBlob = await this.getFilteredImageBlob(image, weatherFilter.type);
                } catch (error) {
                    console.warn(`Resim ${image.id} i√ßin filtre uygulanamadƒ±:`, error);
                }
            }
            
            // Eƒüer filtre uygulanamadƒ±ysa orijinal resmi al
            if (!imageBlob) {
                const imageResponse = await imageManager.auth.makeRequest(
                    `${imageManager.baseURL}/images/${image.id}/file`
                );
                
                if (imageResponse.ok) {
                    imageBlob = await imageResponse.blob();
                }
            }
            
            if (imageBlob) {
                imagesFolder.file(image.fileName, imageBlob);
            }
        }

        // Annotation'larƒ± d√ºzg√ºn ≈üekilde al ve i≈üle
        let currentImageAnnotations = [];
        
        // Eƒüer imageAnnotations bir obje ise (image.id ile key'lenmi≈ü)
        if (imageAnnotations && typeof imageAnnotations === 'object' && imageAnnotations[image.id]) {
            currentImageAnnotations = imageAnnotations[image.id];
        } 
        // Eƒüer imageAnnotations bir array ise (direkt annotation'lar)
        else if (Array.isArray(imageAnnotations)) {
            currentImageAnnotations = imageAnnotations;
        }
        
        // Annotation'larƒ± i≈üle ve koordinatlarƒ± d√ºzelt
        currentImageAnnotations = currentImageAnnotations.map(annotation => {
            const processedAnnotation = {
                ...annotation,
                imageWidth: image.width || 1280,
                imageHeight: image.height || 720,
                x: parseFloat(annotation.x) || 0,
                y: parseFloat(annotation.y) || 0,
                width: parseFloat(annotation.width) || 0,
                height: parseFloat(annotation.height) || 0
            };
            
            return processedAnnotation;
        });

        console.log(`üîç Resim ${image.id} i√ßin i≈ülenmi≈ü annotation'lar:`, currentImageAnnotations);

        // Label dosyasƒ±nƒ± olu≈ütur
        const labelContent = this.createYOLLabelFile(currentImageAnnotations, classMapping, exportOptions);
        const labelFileName = image.fileName.replace(/\.[^/.]+$/, '.txt');
        labelsFolder.file(labelFileName, labelContent);
    }

    async addImageToYOLOSegmentation(imagesFolder, labelsFolder, image, imageAnnotations, classMapping, exportOptions, weatherFilters = {}) {
        // Resim dosyasƒ±nƒ± ekle
        if (exportOptions.includeImages) {
            const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
            
            // Weather filter kontrol√º - export data'dan al
            let imageBlob;
            const weatherFilter = weatherFilters[image.id];
            
            if (weatherFilter && weatherFilter.type && weatherFilter.type !== 'none') {
                console.log(`üå§Ô∏è Resim ${image.id} i√ßin filtre uygulanƒ±yor:`, weatherFilter.type);
                try {
                    // Filtrelenmi≈ü resmi al
                    imageBlob = await this.getFilteredImageBlob(image, weatherFilter.type);
                } catch (error) {
                    console.warn(`Resim ${image.id} i√ßin filtre uygulanamadƒ±:`, error);
                }
            }
            
            // Eƒüer filtre uygulanamadƒ±ysa orijinal resmi al
            if (!imageBlob) {
                const imageResponse = await imageManager.auth.makeRequest(
                    `${imageManager.baseURL}/images/${image.id}/file`
                );
                
                if (imageResponse.ok) {
                    imageBlob = await imageResponse.blob();
                }
            }
            
            if (imageBlob) {
                imagesFolder.file(image.fileName, imageBlob);
            }
        }

        // Annotation'larƒ± d√ºzg√ºn ≈üekilde al
        let currentImageAnnotations = [];
        
        // Eƒüer imageAnnotations bir obje ise (image.id ile key'lenmi≈ü)
        if (imageAnnotations && typeof imageAnnotations === 'object' && imageAnnotations[image.id]) {
            currentImageAnnotations = imageAnnotations[image.id];
        } 
        // Eƒüer imageAnnotations bir array ise (direkt annotation'lar)
        else if (Array.isArray(imageAnnotations)) {
            currentImageAnnotations = imageAnnotations;
        }
        
        // Annotation'lara image boyutlarƒ±nƒ± ekle ve koordinatlarƒ± d√ºzelt
        currentImageAnnotations = currentImageAnnotations.map(annotation => {
            const processedAnnotation = {
                ...annotation,
                imageWidth: image.width || 1280,
                imageHeight: image.height || 720,
                x: parseFloat(annotation.x) || 0,
                y: parseFloat(annotation.y) || 0,
                width: parseFloat(annotation.width) || 0,
                height: parseFloat(annotation.height) || 0
            };
            
            // Points verilerini kontrol et ve d√ºzelt
            if (annotation.points && Array.isArray(annotation.points)) {
                processedAnnotation.points = annotation.points.map(point => ({
                    x: parseFloat(point.x) || 0,
                    y: parseFloat(point.y) || 0
                }));
            }
            
            return processedAnnotation;
        });

        console.log(`üîç Resim ${image.id} i√ßin i≈ülenmi≈ü annotation'lar:`, currentImageAnnotations);

        // Segmentation label dosyasƒ±nƒ± olu≈ütur
        const labelContent = this.createYOLOSegmentationLabelFile(currentImageAnnotations, classMapping, exportOptions);
        const labelFileName = image.fileName.replace(/\.[^/.]+$/, '.txt');
        labelsFolder.file(labelFileName, labelContent);
    }

    createYOLLabelFile(annotations, classMapping, exportOptions) {
        console.log('üîç createYOLLabelFile √ßaƒürƒ±ldƒ±:', {
            annotationsCount: annotations?.length || 0,
            annotations: annotations,
            classMapping: classMapping
        });
        
        let content = '';
        
        if (!annotations || annotations.length === 0) {
            console.log('‚ö†Ô∏è Hi√ß annotation yok!');
            return content;
        }
        
        for (const annotation of annotations) {
            const labelName = this.transformLabelForExport(annotation.label, exportOptions);
            const classId = classMapping[labelName] || 0;
            
            // Debug: Annotation koordinatlarƒ±nƒ± kontrol et
            console.log('üîç YOLO annotation koordinatlarƒ±:', {
                annotationId: annotation.id,
                label: annotation.label,
                x: annotation.x,
                y: annotation.y,
                width: annotation.width,
                height: annotation.height,
                imageWidth: annotation.imageWidth,
                imageHeight: annotation.imageHeight
            });
            
            // Koordinat deƒüerlerini kontrol et
            const x = parseFloat(annotation.x) || 0;
            const y = parseFloat(annotation.y) || 0;
            const width = parseFloat(annotation.width) || 0;
            const height = parseFloat(annotation.height) || 0;
            const imageWidth = parseFloat(annotation.imageWidth) || 1280;
            const imageHeight = parseFloat(annotation.imageHeight) || 720;
            
            // Ge√ßerli koordinat kontrol√º
            if (width <= 0 || height <= 0 || imageWidth <= 0 || imageHeight <= 0) {
                console.warn('‚ö†Ô∏è Ge√ßersiz koordinat deƒüerleri, annotation atlanƒ±yor:', {
                    x, y, width, height, imageWidth, imageHeight
                });
                continue;
            }
            
            // YOLO format: class_id center_x center_y width height (normalized)
            const centerX = (x + width / 2) / imageWidth;
            const centerY = (y + height / 2) / imageHeight;
            const normalizedWidth = width / imageWidth;
            const normalizedHeight = height / imageHeight;
            
            // Normalize edilmi≈ü deƒüerleri 0-1 arasƒ±nda sƒ±nƒ±rla
            const clampedCenterX = Math.max(0, Math.min(1, centerX));
            const clampedCenterY = Math.max(0, Math.min(1, centerY));
            const clampedWidth = Math.max(0, Math.min(1, normalizedWidth));
            const clampedHeight = Math.max(0, Math.min(1, normalizedHeight));
            
            console.log('üîç YOLO normalize edilmi≈ü koordinatlar:', {
                centerX: clampedCenterX,
                centerY: clampedCenterY,
                width: clampedWidth,
                height: clampedHeight
            });
            
            content += `${classId} ${clampedCenterX.toFixed(6)} ${clampedCenterY.toFixed(6)} ${clampedWidth.toFixed(6)} ${clampedHeight.toFixed(6)}\n`;
        }
        
        console.log('üîç YOLO label content:', content);
        return content;
    }

    // YOLO Segmentation formatƒ±nda label dosyasƒ± olu≈ütur (polygon koordinatlarƒ± ile)
    createYOLOSegmentationLabelFile(annotations, classMapping, exportOptions) {
        console.log('üîç createYOLOSegmentationLabelFile √ßaƒürƒ±ldƒ±:', {
            annotationsCount: annotations?.length || 0,
            annotations: annotations,
            classMapping: classMapping
        });
        
        let content = '';
        
        if (!annotations || annotations.length === 0) {
            console.log('‚ö†Ô∏è Hi√ß annotation yok!');
            return content;
        }
        
        for (const annotation of annotations) {
            const labelName = this.transformLabelForExport(annotation.label, exportOptions);
            const classId = classMapping[labelName] || 0;
            
            // Debug: Annotation yapƒ±sƒ±nƒ± kontrol et
            console.log('üîç Annotation yapƒ±sƒ±:', {
                annotationId: annotation.id,
                type: annotation.type,
                hasPoints: !!annotation.points,
                pointsLength: annotation.points?.length,
                hasRectangle: !!(annotation.x !== undefined && annotation.y !== undefined),
                rectangle: { x: annotation.x, y: annotation.y, width: annotation.width, height: annotation.height },
                imageWidth: annotation.imageWidth,
                imageHeight: annotation.imageHeight
            });
            
            let points = [];
            
            // √ñnce mevcut points array'ini kontrol et (kullanƒ±cƒ± tarafƒ±ndan d√ºzenlenmi≈ü polygon)
            if (annotation.points && Array.isArray(annotation.points) && annotation.points.length >= 3) {
                // Kullanƒ±cƒ± tarafƒ±ndan d√ºzenlenmi≈ü polygon koordinatlarƒ±nƒ± kullan
                points = annotation.points;
                console.log('‚úÖ Mevcut points array kullanƒ±lƒ±yor:', points);
            } else if (annotation.x !== undefined && annotation.y !== undefined && 
                      annotation.width !== undefined && annotation.height !== undefined) {
                // Rectangle'ƒ± polygon'a √ßevir (4 k√∂≈üe noktasƒ±)
                points = this.convertRectangleToPolygon(annotation);
                console.log('‚ö†Ô∏è Rectangle\'dan polygon olu≈üturuluyor:', points);
            } else {
                console.warn('‚ö†Ô∏è Annotation\'da ge√ßerli koordinat verisi yok:', annotation);
                continue; // Bu annotation'ƒ± atla
            }
            
            // Points'larƒ± normalize et (0-1 arasƒ±)
            const normalizedPoints = points.map(point => ({
                x: Math.max(0, Math.min(1, (annotation?.imageWidth ? point.x / annotation.imageWidth : 0))),
                y: Math.max(0, Math.min(1, (annotation?.imageHeight ? point.y / annotation.imageHeight : 0)))
                }));
            // Noktalarƒ± saat y√∂n√ºnde sƒ±rala (YOLO segmentation gereksinimi)
            const sortedPoints = this.sortPointsClockwise(normalizedPoints);
            
            // Gereksiz noktalarƒ± temizle (√ßok yakƒ±n noktalar)
            const cleanedPoints = this.cleanPolygonPoints(sortedPoints);
            
            // En az 3 nokta olmalƒ±
            if (cleanedPoints.length < 3) {
                console.warn('‚ö†Ô∏è Yeterli nokta yok, annotation atlanƒ±yor:', cleanedPoints);
                continue;
            }
            
            // Debug: Final koordinatlar
            console.log('üîç Final YOLO segmentation koordinatlarƒ±:', {
                annotationId: annotation.id,
                originalPoints: points,
                normalizedPoints: normalizedPoints,
                sortedPoints: sortedPoints,
                cleanedPoints: cleanedPoints
            });
                
            // YOLO segmentation format: class_id x1 y1 x2 y2 x3 y3 ...
            let line = `${classId}`;
            cleanedPoints.forEach(point => {
                line += ` ${point.x.toFixed(6)} ${point.y.toFixed(6)}`;
            });
            content += line + '\n';
        }
        
        console.log('üîç YOLO Segmentation label content:', content);
        return content;
    }

    // Noktalarƒ± saat y√∂n√ºnde sƒ±rala (YOLO segmentation gereksinimi)
    sortPointsClockwise(points) {
        if (points.length < 3) return points;
        
        // Merkez noktasƒ±nƒ± hesapla
        const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
        
        // Her nokta i√ßin a√ßƒ± hesapla ve sƒ±rala (saat y√∂n√ºnde)
        return points.sort((a, b) => {
            const angleA = Math.atan2(a.y - centerY, a.x - centerX);
            const angleB = Math.atan2(b.y - centerY, b.x - centerX);
            return angleA - angleB;
        });
    }

    // Gereksiz noktalarƒ± temizle (√ßok yakƒ±n noktalar)
    cleanPolygonPoints(points) {
        if (points.length < 3) return points;
        
        const cleaned = [];
        const minDistance = 0.001; // Minimum mesafe (normalize edilmi≈ü koordinatlarda)
        
        for (let i = 0; i < points.length; i++) {
            const current = points[i];
            const next = points[(i + 1) % points.length];
            
            // Mesafe hesapla
            const distance = Math.sqrt(
                Math.pow(current.x - next.x, 2) + Math.pow(current.y - next.y, 2)
            );
            
            // Yeterince uzak noktalarƒ± ekle
            if (distance > minDistance) {
                cleaned.push(current);
            }
        }
        
        // En az 3 nokta olmalƒ±
        return cleaned.length >= 3 ? cleaned : points;
    }

    // Rectangle'ƒ± polygon'a √ßevir (4 k√∂≈üe noktasƒ±)
    convertRectangleToPolygon(annotation) {
        // Annotation yapƒ±sƒ±nƒ± kontrol et
        console.log('üîç convertRectangleToPolygon - annotation yapƒ±sƒ±:', annotation);
        
        let x, y, width, height;
        
        // Eƒüer annotation direkt olarak x, y, width, height i√ßeriyorsa
        if (annotation.x !== undefined && annotation.y !== undefined) {
            x = annotation.x;
            y = annotation.y;
            width = annotation.width;
            height = annotation.height;
            console.log('‚úÖ Direkt annotation deƒüerleri:', { x, y, width, height });
        }
        // Eƒüer annotation_data.annotations i√ßinde ise
        else if (annotation.annotation_data && annotation.annotation_data.annotations && annotation.annotation_data.annotations[0]) {
            const firstAnnotation = annotation.annotation_data.annotations[0];
            x = firstAnnotation.x;
            y = firstAnnotation.y;
            width = firstAnnotation.width;
            height = firstAnnotation.height;
            console.log('‚úÖ annotation_data.annotations deƒüerleri:', { x, y, width, height });
        }
        // Eƒüer hi√ßbiri yoksa hata
        else {
            console.error('‚ùå Rectangle koordinatlarƒ± bulunamadƒ±:', annotation);
            return [];
        }
        
        // Deƒüerleri kontrol et
        if (x === undefined || y === undefined || width === undefined || height === undefined) {
            console.error('‚ùå Eksik rectangle deƒüerleri:', { x, y, width, height });
            return [];
        }
        
        // 4 k√∂≈üe noktasƒ± olu≈ütur (saat y√∂n√ºnde)
        const points = [
            { x: x, y: y }, // Sol √ºst
            { x: x + width, y: y }, // Saƒü √ºst
            { x: x + width, y: y + height }, // Saƒü alt
            { x: x, y: y + height } // Sol alt
        ];
        
        console.log('‚úÖ Olu≈üturulan polygon noktalarƒ±:', points);
        return points;
    }

    // En g√ºncel annotation'larƒ± veritabanƒ±ndan al
    async getFreshAnnotations(imageId) {
        try {
            const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
            const response = await imageManager.auth.makeRequest(
                `${imageManager.baseURL}/images/${imageId}/annotations`
            );
            
            if (response.ok) {
                const data = await response.json();
                console.log(`üîç Resim ${imageId} i√ßin g√ºncel annotation verisi:`, data);
                
                // Veritabanƒ±ndan gelen yapƒ±yƒ± kontrol et
                if (Array.isArray(data)) {
                    // Eƒüer data direkt array ise, her annotation'ƒ±n annotation_data.annotations'ƒ±nƒ± al
                    const allAnnotations = [];
                    data.forEach(annotationRecord => {
                        if (annotationRecord.annotation_data && annotationRecord.annotation_data.annotations) {
                            allAnnotations.push(...annotationRecord.annotation_data.annotations);
                        }
                    });
                    return allAnnotations;
                } else if (data && data.annotations && Array.isArray(data.annotations)) {
                    // annotations array'ini d√∂nd√ºr
                    return data.annotations;
                } else {
                    console.warn(`Resim ${imageId} i√ßin beklenmeyen annotation yapƒ±sƒ±:`, data);
                    return [];
                }
            } else {
                console.warn(`Resim ${imageId} i√ßin annotation alƒ±namadƒ±:`, response.status);
                return [];
            }
        } catch (error) {
            console.error(`Resim ${imageId} i√ßin annotation hatasƒ±:`, error);
            return [];
        }
    }

    // Hatalarƒ± d√ºzeltmek i√ßin fonksiyonlarda eksik parantezler, hatalƒ± return, ve olasƒ± undefined kontrolleri eklendi.

    createYOLOYaml(classMapping) {
        // classMapping: {label: classId, ...}
        const classes = Object.keys(classMapping)
            .sort((a, b) => classMapping[a] - classMapping[b]);
        return `# YOLO Dataset Configuration
path: ./
train: train/images
val: val/images

nc: ${classes.length}
names: [${classes.map(c => `'${c}'`).join(', ')}]`;
    }

    createYOLOSegmentationYaml(classMapping) {
        const classes = Object.keys(classMapping)
            .sort((a, b) => classMapping[a] - classMapping[b]);
        return `# YOLO Segmentation Dataset Configuration
path:  # dataset root dir (leave empty for HUB)
train: images/train  # train images (relative to 'path')
val: images/val  # val images (relative to 'path')
test:  # test images (optional)

# Classes
names:
${classes.map((className, index) => `  ${index}: ${className}`).join('\n')}

# Segmentation specific - YOLOv8+ otomatik olarak anlar
# task: segment
# segments: true`;
    }

    createCOCOFormat(images, annotations, classMapping, exportOptions) {
        const cocoData = {
            info: {
                description: "Dataset exported from Labeling Tool",
                version: "1.0",
                year: new Date().getFullYear(),
                contributor: "Labeling Tool",
                date_created: new Date().toISOString()
            },
            licenses: [{
                id: 1,
                name: "Unknown",
                url: ""
            }],
            images: [],
            annotations: [],
            categories: []
        };

        // Categories
        const categories = Object.keys(classMapping).map((labelName, index) => ({
            id: classMapping[labelName] !== undefined ? classMapping[labelName] : index,
            name: this.transformLabelForExport ? this.transformLabelForExport(labelName, exportOptions) : labelName,
            supercategory: "object"
        }));
        cocoData.categories = categories;

        // Images and annotations
        let annotationId = 1;
        images.forEach((image, imageIndex) => {
            cocoData.images.push({
                id: imageIndex + 1,
                width: image.width || 1920,
                height: image.height || 1080,
                file_name: image.fileName,
                license: 1,
                date_captured: new Date().toISOString()
            });

            const imageAnnotations = (annotations && annotations[image.id]) ? annotations[image.id] : [];
            imageAnnotations.forEach(annotation => {
                const labelName = this.transformLabelForExport ? this.transformLabelForExport(annotation.label, exportOptions) : annotation.label;
                const categoryId = classMapping[labelName] !== undefined ? classMapping[labelName] : 0;

                cocoData.annotations.push({
                    id: annotationId++,
                    image_id: imageIndex + 1,
                    category_id: categoryId,
                    bbox: [
                        annotation.x !== undefined ? annotation.x : 0,
                        annotation.y !== undefined ? annotation.y : 0,
                        annotation.width !== undefined ? annotation.width : 0,
                        annotation.height !== undefined ? annotation.height : 0
                    ],
                    area: (annotation.width || 0) * (annotation.height || 0),
                    iscrowd: 0
                });
            });
        });

        return cocoData;
    }

    async createPascalVOCFiles(projectFolder, images, annotations, classMapping, exportOptions) {
        const annotationsFolder = projectFolder.folder('Annotations');
        const imagesFolder = projectFolder.folder('JPEGImages');

        for (const image of images) {
            // Resim dosyasƒ±nƒ± ekle
            if (exportOptions && exportOptions.includeImages) {
                const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
                const imageResponse = await imageManager.auth.makeRequest(
                    `${imageManager.baseURL}/images/${image.id}/file`
                );
                if (imageResponse.ok) {
                    const imageBlob = await imageResponse.blob();
                    imagesFolder.file(image.fileName, imageBlob);
                }
            }

            // XML dosyasƒ±nƒ± olu≈ütur
            const xmlContent = this.createPascalVOCXML(
                image,
                (annotations && annotations[image.id]) ? annotations[image.id] : [],
                classMapping,
                exportOptions
            );
            const xmlFileName = image.fileName.replace(/\.[^/.]+$/, '.xml');
            annotationsFolder.file(xmlFileName, xmlContent);
        }
    }

    createPascalVOCXML(image, imageAnnotations, classMapping, exportOptions) {
        let xml = `<?xml version="1.0" encoding="UTF-8"?>
<annotation>
    <folder>JPEGImages</folder>
    <filename>${image.fileName}</filename>
    <path>./JPEGImages/${image.fileName}</path>
    <source>
        <database>Labeling Tool</database>
    </source>
    <size>
        <width>${image.width || 1920}</width>
        <height>${image.height || 1080}</height>
        <depth>3</depth>
    </size>
    <segmented>0</segmented>`;

        if (Array.isArray(imageAnnotations)) {
            imageAnnotations.forEach(annotation => {
                const labelName = this.transformLabelForExport ? this.transformLabelForExport(annotation.label, exportOptions) : annotation.label;
                xml += `
    <object>
        <name>${labelName}</name>
        <pose>Unspecified</pose>
        <truncated>0</truncated>
        <difficult>0</difficult>
        <bndbox>
            <xmin>${Math.round(annotation.x || 0)}</xmin>
            <ymin>${Math.round(annotation.y || 0)}</ymin>
            <xmax>${Math.round((annotation.x || 0) + (annotation.width || 0))}</xmax>
            <ymax>${Math.round((annotation.y || 0) + (annotation.height || 0))}</ymax>
        </bndbox>
    </object>`;
            });
        }

        xml += `
</annotation>`;

        return xml;
    }

    createJSONFormat(projectData, exportOptions) {
        const { images, annotations } = projectData;
        const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
        return {
            project: {
                name: (imageManager && imageManager.currentProject && imageManager.currentProject.name) ? imageManager.currentProject.name : 'dataset',
                exportDate: new Date().toISOString(),
                totalImages: images.length,
                totalAnnotations: Object.values(annotations).reduce((acc, arr) => acc + (Array.isArray(arr) ? arr.length : 0), 0)
            },
            images: images.map(image => ({
                id: image.id,
                fileName: image.fileName,
                width: image.width || 1920,
                height: image.height || 1080,
                annotations: (annotations && annotations[image.id] ? annotations[image.id] : []).map(annotation => ({
                    id: annotation.id,
                    label: this.transformLabelForExport ? this.transformLabelForExport(annotation.label, exportOptions) : annotation.label,
                    type: annotation.type,
                    x: annotation.x,
                    y: annotation.y,
                    width: annotation.width,
                    height: annotation.height,
                    color: annotation.color
                }))
            }))
        };
    }

    createCSVFormat(images, annotations, classMapping, exportOptions) {
        let csv = 'image_id,image_name,annotation_id,label,class_id,x,y,width,height\n';
        images.forEach(image => {
            const imageAnnotations = (annotations && annotations[image.id]) ? annotations[image.id] : [];
            imageAnnotations.forEach(annotation => {
                const labelName = this.transformLabelForExport ? this.transformLabelForExport(annotation.label, exportOptions) : annotation.label;
                const classId = classMapping[labelName] !== undefined ? classMapping[labelName] : 0;
                csv += `${image.id},${image.fileName},${annotation.id},${labelName},${classId},${annotation.x},${annotation.y},${annotation.width},${annotation.height}\n`;
            });
        });
        return csv;
    }

    async addImagesToZip(projectFolder, images, exportOptions) {
        const imagesFolder = projectFolder.folder('images');
        const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;

        for (const image of images) {
            let imageBlob;
            try {
                const filterResponse = await imageManager.auth.makeRequest(
                    `${imageManager.baseURL}/images/${image.id}/weather-filter`
                );
                if (filterResponse.ok) {
                    const filterData = await filterResponse.json();
                    if (filterData && filterData.type && filterData.type !== 'none') {
                        console.log(`üå§Ô∏è Resim ${image.id} i√ßin filtre uygulanƒ±yor:`, filterData.type);
                        imageBlob = await this.getFilteredImageBlob(image, filterData.type);
                    }
                }
            } catch (error) {
                console.warn(`Resim ${image.id} i√ßin filtre kontrol√º ba≈üarƒ±sƒ±z:`, error);
            }

            if (!imageBlob) {
                const imageResponse = await imageManager.auth.makeRequest(
                    `${imageManager.baseURL}/images/${image.id}/file`
                );
                if (imageResponse.ok) {
                    imageBlob = await imageResponse.blob();
                }
            }

            if (imageBlob) {
                imagesFolder.file(image.fileName, imageBlob);
            }
        }
    }

    async saveZipFile(zip, fileName) {
        const content = await zip.generateAsync({ type: "blob" });
        // Export i≈ülemi sƒ±rasƒ±nda showSaveFilePicker √ßalƒ±≈ümaz, otomatik indirme kullan
        console.log('üíæ ZIP dosyasƒ± olu≈üturuldu, otomatik indirme ba≈ülatƒ±lƒ±yor:', fileName);
        if (this.fallbackDownload) {
            this.fallbackDownload(content, fileName);
        } else {
            // fallbackDownload fonksiyonu yoksa klasik indirme
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }
    }

    async getFilteredImageBlob(image, filterType) {
        try {
            console.log(`üì∏ Filtrelenmi≈ü resim olu≈üturuluyor: ${filterType} filtresi ile`);
            const imageManager = this.labelingTool.imageManager || window.labelingTool?.imageManager || window.imageManager;
            const imageResponse = await imageManager.auth.makeRequest(
                `${imageManager.baseURL}/images/${image.id}/file`
            );
            if (!imageResponse.ok) {
                throw new Error('Resim alƒ±namadƒ±');
            }
            const originalBlob = await imageResponse.blob();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.crossOrigin = 'anonymous';

            return new Promise((resolve, reject) => {
                img.onload = () => {
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);

                    if (this.labelingTool && this.labelingTool.applyWeatherFilter) {
                        console.log('üé® Renk filtresi uygulanƒ±yor:', filterType);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const filteredData = this.labelingTool.applyWeatherFilter(imageData, filterType);
                        if (filteredData && filteredData instanceof ImageData) {
                            ctx.putImageData(filteredData, 0, 0);
                            console.log('‚úÖ Renk filtresi uygulandƒ±');
                        }
                    }

                    // Canvas efektlerini uygula (kar/yaƒümur taneleri) - Pƒ∞KSEL DEƒûƒ∞≈ûƒ∞Mƒ∞ ƒ∞LE
                    if (this.addWeatherEffectToPixels) {
                        console.log('üé® Canvas efektleri uygulanƒ±yor (piksel deƒüi≈üimi ile):', filterType);
                        this.addWeatherEffectToPixels(ctx, filterType, canvas.width, canvas.height);
                        console.log('‚úÖ Canvas efektleri piksel olarak uygulandƒ±');
                    }

                    canvas.toBlob((blob) => {
                        if (blob) {
                            console.log(`‚úÖ Filtrelenmi≈ü resim olu≈üturuldu: ${blob.size} bytes`);
                            resolve(blob);
                        } else {
                            reject(new Error('Canvas blob olu≈üturulamadƒ±'));
                        }
                    }, 'image/jpeg', 0.9);
                };
                img.onerror = () => reject(new Error('Resim y√ºklenemedi'));
                img.src = URL.createObjectURL(originalBlob);
            });
        } catch (error) {
            console.error('Filtrelenmi≈ü resim olu≈üturulurken hata:', error);
            throw error;
        }
    }

    addWeatherEffectToPixels(ctx, filterType, width, height) {
        if (!filterType || filterType === 'none') {
            return;
        }
        console.log('üé® Piksel efektleri uygulanƒ±yor:', filterType, 'Boyutlar:', width, 'x', height);
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        switch (filterType) {
            case 'snowy':
                this.addNightPixels(data, width, height); // Gece efekti
                ctx.putImageData(imageData, 0, 0);
                this.drawSnowOnCanvas(ctx, width, height); // Kar tanelerini canvas'a √ßiz
                break;
            case 'rainy':
                this.addNightPixels(data, width, height); // Gece efekti
                ctx.putImageData(imageData, 0, 0);
                this.drawRainOnCanvas(ctx, width, height); // Yaƒümur damlalarƒ±nƒ± canvas'a √ßiz
                break;
            case 'night':
                this.addNightPixels(data, width, height);
                ctx.putImageData(imageData, 0, 0);
                break;
            case 'sunny':
                this.addSunnyPixels(data, width, height);
                ctx.putImageData(imageData, 0, 0);
                break;
            case 'foggy':
                this.addFogPixels(data, width, height);
                ctx.putImageData(imageData, 0, 0);
                break;
            case 'sunset':
                this.addSunsetPixels(data, width, height);
                ctx.putImageData(imageData, 0, 0);
                break;
            case 'cloudy':
                this.addCloudyPixels(data, width, height);
                ctx.putImageData(imageData, 0, 0);
                break;
        }
        console.log('‚úÖ Piksel efektleri tamamlandƒ±:', filterType);
    }

    addSnowPixels(data, width, height) {
        const snowflakes = [];
        // Daha fazla kar tanesi ve daha b√ºy√ºk boyutlar
        for (let i = 0; i < 500; i++) {
            snowflakes.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 6 + 2, // Daha b√ºy√ºk kar taneleri
                opacity: Math.random() * 0.9 + 0.3 // Daha opak
            });
        }
        snowflakes.forEach(flake => {
            const centerX = Math.floor(flake.x);
            const centerY = Math.floor(flake.y);
            const radius = Math.floor(flake.size);
            for (let x = -radius; x <= radius; x++) {
                for (let y = -radius; y <= radius; y++) {
                    if (x * x + y * y <= radius * radius) {
                        const pixelX = centerX + x;
                        const pixelY = centerY + y;
                        if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
                            const index = (pixelY * width + pixelX) * 4;
                            data[index] = Math.min(255, data[index] + (255 - data[index]) * flake.opacity);
                            data[index + 1] = Math.min(255, data[index + 1] + (255 - data[index + 1]) * flake.opacity);
                            data[index + 2] = Math.min(255, data[index + 2] + (255 - data[index + 2]) * flake.opacity);
                        }
                    }
                }
            }
        });
    }

    // Kar tanelerini canvas'a √ßiz
    drawSnowOnCanvas(ctx, width, height) {
        console.log('‚ùÑÔ∏è Kar taneleri canvas\'a √ßiziliyor...');
        
        // Canvas ayarlarƒ±
        ctx.save();
        ctx.globalAlpha = 0.8;
        
        // Kar taneleri olu≈ütur
        for (let i = 0; i < 300; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const size = Math.random() * 4 + 2;
            
            // Kar tanesini √ßiz (beyaz daire)
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
        }
        
        ctx.restore();
        console.log('‚úÖ Kar taneleri √ßizildi');
    }

    // Yaƒümur damlalarƒ±nƒ± canvas'a √ßiz
    drawRainOnCanvas(ctx, width, height) {
        console.log('üåßÔ∏è Yaƒümur damlalarƒ± canvas\'a √ßiziliyor...');
        
        // Canvas ayarlarƒ±
        ctx.save();
        ctx.strokeStyle = 'rgba(173, 216, 230, 0.6)'; // A√ßƒ±k mavi
        ctx.lineWidth = 1;
        ctx.lineCap = 'round';
        
        // Yaƒümur damlalarƒ± olu≈ütur
        for (let i = 0; i < 400; i++) {
            const startX = Math.random() * width;
            const startY = Math.random() * height;
            const length = Math.random() * 30 + 15;
            const angle = Math.random() * 0.4 + 0.1; // Hafif eƒüim
            
            // Yaƒümur damlasƒ±nƒ± √ßiz
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(
                startX + length * Math.sin(angle),
                startY + length * Math.cos(angle)
            );
            ctx.stroke();
        }
        
        ctx.restore();
        console.log('‚úÖ Yaƒümur damlalarƒ± √ßizildi');
    }

    addRainPixels(data, width, height) {
        const raindrops = [];
        // Daha fazla yaƒümur damlasƒ± ve daha belirgin
        for (let i = 0; i < 800; i++) {
            raindrops.push({
                x: Math.random() * width,
                y: Math.random() * height,
                length: Math.random() * 40 + 15, // Daha uzun damlalar
                opacity: Math.random() * 0.8 + 0.4, // Daha opak
                angle: Math.random() * 0.4 + 0.1 // Daha eƒüik
            });
        }
        raindrops.forEach(drop => {
            const startX = Math.floor(drop.x);
            const startY = Math.floor(drop.y);
            const length = Math.floor(drop.length);
            const angle = drop.angle;
            for (let i = 0; i < length; i++) {
                const x = Math.floor(startX + i * Math.sin(angle));
                const y = Math.floor(startY + i * Math.cos(angle));
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    const index = (y * width + x) * 4;
                    data[index] = Math.min(255, data[index] + (173 - data[index]) * drop.opacity);
                    data[index + 1] = Math.min(255, data[index + 1] + (216 - data[index + 1]) * drop.opacity);
                    data[index + 2] = Math.min(255, data[index + 2] + (230 - data[index + 2]) * drop.opacity);
                }
            }
        });
    }

    addNightPixels(data, width, height) {
        for (let i = 0; i < data.length; i += 4) {
            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
            data[i] = gray * 0.3;
            data[i + 1] = gray * 0.3;
            data[i + 2] = gray * 0.3;
        }
    }

    addSunnyPixels(data, width, height) {
        for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, data[i] * 1.2);
            data[i + 1] = Math.min(255, data[i + 1] * 1.1);
            data[i + 2] = Math.min(255, data[i + 2] * 0.9);
        }
    }

    addFogPixels(data, width, height) {
        for (let i = 0; i < data.length; i += 4) {
            const fogFactor = 0.3;
            data[i] = Math.min(255, data[i] + (255 - data[i]) * fogFactor);
            data[i + 1] = Math.min(255, data[i + 1] + (255 - data[i + 1]) * fogFactor);
            data[i + 2] = Math.min(255, data[i + 2] + (255 - data[i + 2]) * fogFactor);
        }
    }

    addSunsetPixels(data, width, height) {
        for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, data[i] * 1.3);
            data[i + 1] = Math.min(255, data[i + 1] * 0.8);
            data[i + 2] = Math.min(255, data[i + 2] * 0.6);
        }
    }

    addCloudyPixels(data, width, height) {
        for (let i = 0; i < data.length; i += 4) {
            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
            data[i] = gray * 0.7;
            data[i + 1] = gray * 0.7;
            data[i + 2] = gray * 0.7;
        }
    }
}

// Export for use in main script
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ExportManager;
} else {
    window.ExportManager = ExportManager;
}
