class LabelingTool {
    constructor() {
        console.log('üèóÔ∏è LabelingTool constructor ba≈ülatƒ±lƒ±yor...');
        
        // Auth kontrol√º artƒ±k auth sistemi tarafƒ±ndan yapƒ±lƒ±yor
        
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.image = null;
        this.currentTool = 'rectangle'; // Sadece rectangle tool
        this.isDrawing = false;
        this.annotations = [];
        this.currentAnnotation = null;
        this.focusedAnnotation = null; // Focuslanan etiket
        this.currentMousePos = null; // Mouse pozisyonu
        this.startX = 0;
        this.startY = 0;
        this.imageScale = 1;
        this.imageOffsetX = 0;
        this.imageOffsetY = 0;
        this.croppedImages = [];
        this.availableLabels = []; // Tanƒ±mlƒ± etiketler
        this.favoriteLabels = []; // Favori etiketler
        this.selectedFavoriteLabel = null; // Modal'da se√ßilen favori etiket
        this.activeLabel = null; // ≈ûu anda se√ßili etiket
        this.quickLabelMode = false; // Hƒ±zlƒ± etiket modu aktif mi?
        this.labelCaseMode = 'original'; // Etiket harf durumu: 'original', 'uppercase', 'lowercase'
        this.exportFolderPath = null; // Export klas√∂r√º yolu
        this.isSaved = true; // Kaydetme durumu (ba≈ülangƒ±√ßta kaydedilmi≈ü)
        
        // Undo/Redo sistemi
        this.history = []; // ƒ∞≈ülem ge√ßmi≈üi
        this.historyIndex = -1; // Mevcut ge√ßmi≈ü indeksi
        this.maxHistorySize = 50; // Maksimum ge√ßmi≈ü boyutu
        
        // Kopyala-Yapƒ±≈ütƒ±r sistemi
        this.copiedAnnotation = null; // Kopyalanan annotation
        this.cropFolderPath = null; // Kƒ±rp klas√∂r√º yolu
        
        // Multi-image support
        this.images = []; // T√ºm y√ºklenen resimler
        this.currentImageIndex = 0; // Aktif resim indexi
        this.imageAnnotations = {}; // Her resim i√ßin ayrƒ± annotationlar
        this.imageFilters = {}; // Her resim i√ßin ayrƒ± filtre ayarlarƒ±
        this.isMultiImageMode = false; // Klas√∂r modu aktif mi?
        this.totalImages = 0; // Toplam resim sayƒ±sƒ±
        
        // Performance optimizations
        this.imageCache = new Map(); // Resim cache'i
        this.filterCache = new Map(); // Filtre cache'i
        
        // Color filters
        this.originalImageData = null; // Orijinal resim verisi
        this.activeFilters = new Set(); // Aktif filtreler
        this.activeTextures = new Set(); // Aktif texture efektleri
        
        // Image Manager
        this.imageManager = null;
        this.debounceTimers = new Map(); // Debounce timer'larƒ±
        this.isProcessing = false; // ƒ∞≈ülem devam ediyor mu?
        this.needsRedraw = true; // Canvas yeniden √ßizim gerekli mi?
        this.lastRedrawTime = 0; // Son redraw zamanƒ±
        
        // Pagination
        this.currentPage = 1;
        this.itemsPerPage = 15;
        this.totalPages = 1;
        
        // Zoom/Pan support
        this.zoom = 1; // Zoom seviyesi
        this.panX = 0; // X ekseni kaydƒ±rma
        this.panY = 0; // Y ekseni kaydƒ±rma
        this.isPanning = false; // Pan modu aktif mi?
        this.lastPanX = 0; // Son pan pozisyonu X
        this.lastPanY = 0; // Son pan pozisyonu Y
        
        this.selectedAnnotation = null; // Se√ßili annotation         // Renk paleti
        this.colorPalette = ['#2ecc71', '#e74c3c', '#3498db', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
        this.currentColorIndex = 0; // Otomatik renk atama i√ßin index
        this.selectedColor = '#2ecc71'; // Modal'da se√ßilen renk
        
        // Annotation interaction system
        this.dragHandle = null; // S√ºr√ºklenen handle
        this.isDraggingHandle = false; // Handle s√ºr√ºkleniyor mu?
        this.dragAnnotation = null; // S√ºr√ºklenen annotation
        this.isDraggingAnnotation = false; // Annotation s√ºr√ºkleniyor mu?
        this.dragStartPos = null; // S√ºr√ºkleme ba≈ülangƒ±√ß pozisyonu
        
        // Initialize modules
        console.log('üöÄ CanvasManager ba≈ülatƒ±lƒ±yor...');
        if (window.CanvasManager) {
            this.canvasManager = new CanvasManager(this);
            console.log('‚úÖ CanvasManager ba≈ülatƒ±ldƒ±');
        } else {
            console.error('‚ùå CanvasManager bulunamadƒ±!');
        }
        
        console.log('üöÄ AnnotationManager ba≈ülatƒ±lƒ±yor...');
        if (window.AnnotationManager) {
            this.annotationManager = new AnnotationManager(this);
            console.log('‚úÖ AnnotationManager ba≈ülatƒ±ldƒ±');
        } else {
            console.error('‚ùå AnnotationManager bulunamadƒ±!');
        }
        
        console.log('üöÄ ExportManager ba≈ülatƒ±lƒ±yor...');
        if (window.ExportManager) {
            this.exportManager = new ExportManager(this);
            console.log('‚úÖ ExportManager ba≈ülatƒ±ldƒ±');
        } else {
            console.error('‚ùå ExportManager bulunamadƒ±!');
        }
        
        console.log('üöÄ UtilityManager ba≈ülatƒ±lƒ±yor...');
        if (window.UtilityManager) {
            this._utilityManager = new UtilityManager(this);
            console.log('‚úÖ UtilityManager ba≈ülatƒ±ldƒ±');
        } else {
            console.error('‚ùå UtilityManager bulunamadƒ±!');
        }
        
        // Auth objesini initialize et
        if (!window.labelingAuth) {
            console.log('üîß Auth objesi initialize ediliyor...');
            window.labelingAuth = {
                baseURL: 'http://localhost:3000/api',
                isLoggedIn: () => true,
                getProjects: async () => {
                    const response = await fetch(`${this.baseURL}/projects`);
                    return response.ok ? await response.json() : [];
                },
                setUserAndProject: (user, projectId) => {
                    console.log('üîß setUserAndProject √ßaƒürƒ±ldƒ±:', user, projectId);
                },
                authenticatedRequest: async (url, options = {}) => {
                    return fetch(url, {
                        ...options,
                        headers: {
                            'Content-Type': 'application/json',
                            ...options.headers
                        }
                    });
                },
                makeRequest: async (url, options = {}) => {
                    return fetch(url, {
                        ...options,
                        headers: {
                            'Content-Type': 'application/json',
                            ...options.headers
                        }
                    });
                },
                getCurrentProject: () => {
                    const urlParams = new URLSearchParams(window.location.search);
                    return urlParams.get('project');
                }
            };
            console.log('‚úÖ Auth objesi initialize edildi');
        }
        
        // Image Manager'ƒ± ba≈ülat
        this.imageManager = new ImageManager(window.labelingAuth);
        
        this.setupEventListeners();
        this.setupImageNavigationListeners();
        this.setupFavoriteLabelListeners();
        this.resizeCanvas();
        this.migrateAnnotationsColors();
        
        // ƒ∞lk history kaydƒ±nƒ± yap
        this.saveToHistory();
        
        // Kaydetmeden √ßƒ±kƒ±≈ü onayƒ±
        window.addEventListener('beforeunload', (e) => {
            if (this.annotations.length > 0 && !this.isSaved) {
                e.preventDefault();
                e.returnValue = 'Kaydedilmemi≈ü etiketlemeler var, sayfadan √ßƒ±kmak istediƒüinizden emin misiniz?';
            }
        });
        
        // Performance utility functions
        // Utility functions will be handled by UtilityManager
    }

    // Proje klas√∂r√ºn√º tara
    async scanProjectFolder() {
        if (!this.imageManager) {
            this.showError('Image Manager hen√ºz hazƒ±r deƒüil');
            return;
        }

        try {
            this.showInfo('Klas√∂r taranƒ±yor...');
            const success = await this.imageManager.scanFolder();
            
            if (success) {
                this.showSuccess('Klas√∂r ba≈üarƒ±yla tarandƒ±!');
                this.showImageNavigation();
            } else {
                this.showError('Klas√∂r tarama ba≈üarƒ±sƒ±z');
            }
        } catch (error) {
            console.error('‚ùå Klas√∂r tarama hatasƒ±:', error);
            this.showError('Klas√∂r tarama hatasƒ±: ' + error.message);
        }
    }


    // Mevcut fotoƒürafƒ± etiketli olarak i≈üaretle
    async markCurrentImageAsLabeled() {
        if (!this.imageManager) return;
        
        try {
            // Mevcut annotation'larƒ± al
            const annotationData = {
                annotations: this.annotations,
                timestamp: new Date().toISOString()
            };
            
            const success = await this.imageManager.markAsLabeled(annotationData);
            if (success) {
                this.showSuccess('Fotoƒüraf etiketli olarak i≈üaretlendi');
            }
        } catch (error) {
            console.error('‚ùå Etiketleme hatasƒ±:', error);
            this.showError('Fotoƒüraf etiketlenemedi');
        }
    }

    // Mevcut fotoƒürafƒ± etiketlenmemi≈ü olarak i≈üaretle
    async markCurrentImageAsUnlabeled() {
        if (!this.imageManager) return;
        
        try {
            const success = await this.imageManager.markAsUnlabeled();
            if (success) {
                this.showSuccess('Fotoƒüraf etiketlenmemi≈ü olarak i≈üaretlendi');
            }
        } catch (error) {
            console.error('‚ùå Etiketleme hatasƒ±:', error);
            this.showError('Fotoƒüraf etiketlenmemi≈ü olarak i≈üaretlenemedi');
        }
    }

    // Mevcut fotoƒürafƒ± canvas'a y√ºkle
    loadCurrentImageToCanvas() {
        if (!this.imageManager || !this.imageManager.currentImage) return;
        
        const imageElement = document.getElementById('currentImage');
        if (imageElement) {
            imageElement.style.display = 'block';
            this.canvas.style.display = 'none';
            
            // Canvas'ƒ± image boyutuna ayarla
            this.resizeCanvas();
        }
    }

    // Fotoƒüraf navigasyon panelini g√∂ster
    showImageNavigation() {
        const imageNavSection = document.getElementById('imageNavigationSection');
        if (imageNavSection) {
            imageNavSection.style.display = 'block';
        }
    }

    // Fotoƒüraf navigasyon panelini gizle
    hideImageNavigation() {
        const imageNavSection = document.getElementById('imageNavigationSection');
        if (imageNavSection) {
            imageNavSection.style.display = 'none';
        }
        
        // Start memory management timer - b√ºy√ºk dosya sayƒ±larƒ± i√ßin daha sƒ±k
        setInterval(() => {
            this.manageMemory();
        }, 10000); // Her 10 saniyede bir
        
        // Color Filter System
        this.originalImageData = null; // Orijinal resim verisi
        this.activeFilters = new Set(); // Aktif filtreler
        
        // DOM y√ºklendikten sonra filtreleri ayarla
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
        this.setupColorFilters();
            });
        } else {
            this.setupColorFilters();
        }
        
        // Texture Overlay System
        this.textureCanvas = document.createElement('canvas');
        this.textureCtx = this.textureCanvas.getContext('2d');
        this.activeTextures = new Set(); // Aktif texture'lar
        
        // Grid System
        this.showGrid = true; // Grid g√∂sterimi aktif mi?
        this.gridSize = 20; // Grid boyutu (piksel)
        this.majorGridSize = 100; // Ana grid boyutu
        
        // Rectangle System
        
        // Fullscreen Crosshair System
        this.showFullscreenCrosshair = true; // Fullscreen crosshair g√∂sterimi
        this.crosshairVisible = false; // Crosshair ≈üu anda g√∂r√ºn√ºr m√º?
        
        // Real-time senkronizasyon
        if (window.RealtimeSync) {
            this.realtimeSync = new RealtimeSync(this);
            console.log('‚úÖ Real-time senkronizasyon ba≈ülatƒ±ldƒ±');
        } else {
            console.error('‚ùå RealtimeSync bulunamadƒ±!');
        }
    }

    // Auth kontrol√º - Artƒ±k auth sistemi kendi kendini y√∂netiyor
    checkAuth() {
        console.log('üîç checkAuth √ßaƒürƒ±ldƒ± - Auth sistemi kendi kendini y√∂netiyor');
        
        if (!window.labelingAuth) {
            console.error('‚ùå labelingAuth bulunamadƒ±!');
            return;
        }
        
        // URL'den proje ID'sini al
        const urlParams = new URLSearchParams(window.location.search);
        const projectId = urlParams.get('project');
        
        if (projectId && window.labelingAuth.isLoggedIn()) {
            console.log('üîç Proje ID bulundu, y√ºkleniyor:', projectId);
            this.loadProject(projectId);
        }
        // Not loading first available project automatically anymore - start.js handles this
    }

    // ƒ∞lk mevcut projeyi y√ºkle
    async loadFirstAvailableProject() {
        try {
            const projects = await window.labelingAuth.getProjects();
            if (projects && projects.length > 0) {
                const firstProject = projects[0];
                console.log('üìÅ ƒ∞lk mevcut proje y√ºkleniyor:', firstProject.id, firstProject.name);
                window.labelingAuth.setUserAndProject('user', firstProject.id);
                this.loadProject(firstProject.id);
            } else {
                console.log('‚ö†Ô∏è Mevcut proje bulunamadƒ±');
            }
        } catch (error) {
            console.error('‚ùå Proje y√ºklenirken hata:', error);
        }
    }

    // Proje y√ºkle
    async loadProject(projectId) {
        try {
            console.log('üìÅ Proje y√ºkleniyor:', projectId);
            
            // Proje bilgilerini al (auth bypass)
            const response = await fetch(`http://localhost:3000/api/projects/${projectId}`);
            const project = await response.json();
            
            if (project) {
                console.log('‚úÖ Proje y√ºklendi:', project.name);
                this.showSuccess(`Proje y√ºklendi: ${project.name}`);
                
                // ImageManager'a proje bilgisini bildir
                await this.imageManager.setProject(projectId);
                
                // Sidebar'daki proje adƒ± input'unu g√ºncelle
                const projectNameInput = document.getElementById('projectName');
                if (projectNameInput) {
                    projectNameInput.value = project.name;
                }
                
                // Proje verilerini uygulamaya y√ºkle
                if (project.data) {
                    this.annotations = project.data.annotations || [];
                    this.availableLabels = project.data.settings?.availableLabels || [];
                    this.activeLabel = project.data.settings?.activeLabel;
                    this.selectedColor = project.data.settings?.selectedColor || '#2ecc71';
                    this.favoriteLabels = project.data.settings?.favoriteLabels || [];
                    this.currentImageIndex = project.data.settings?.currentImageIndex || 0;
                    this.croppedImages = project.data.settings?.croppedImages || [];
                    this.exportFolderPath = project.data.settings?.exportFolderPath;
                    
                    // Fotoƒüraf dosya bilgisini kontrol et ve otomatik y√ºkle
                    if (project.data.imageFile) {
                        console.log('üì∏ Proje fotoƒüraf bilgisi:', project.data.imageFile.fileName);
                        console.log('üìÅ Dosya yolu:', project.data.imageFile.fullPath);
                        this.projectImageFile = project.data.imageFile; // Fotoƒüraf bilgisini sakla
                        
                        // HTTP √ºzerinden dosya yolundan y√ºkle
                        console.log('üìÅ HTTP √ºzerinden dosya yolundan y√ºkleniyor...');
                        this.loadImageFromPath(project.data.imageFile.fullPath);
                    } else if (this.croppedImages.length > 0 && this.currentImageIndex < this.croppedImages.length) {
                        // Fallback: Eƒüer fotoƒüraf bilgisi yoksa, cropped image'ƒ± y√ºkle
                        this.loadImageFromIndex(this.currentImageIndex);
                    }
                    
                    // UI'yi g√ºncelle
                    this.updateLabelList();
                    this.updateAnnotationList();
                    this.updateAvailableLabels();
                    this.updateProjectStats(); // Proje istatistiklerini g√ºncelle
                    this.redraw();
                    
                    // Real-time senkronizasyona projeye katƒ±l
                    if (this.realtimeSync) {
                        this.realtimeSync.joinProject(projectId);
                    }
                    
                    console.log('‚úÖ Proje durumu y√ºklendi:', {
                        annotations: this.annotations.length,
                        labels: this.availableLabels.length,
                        imageFile: project.data.imageFile ? project.data.imageFile.fileName : 'Yok',
                        croppedImages: this.croppedImages.length,
                        currentImage: this.currentImageIndex
                    });
                }
            } else {
                this.showError('Proje y√ºklenemedi');
            }
        } catch (error) {
            console.error('‚ùå Proje y√ºkleme hatasƒ±:', error);
            this.showError('Proje y√ºkleme hatasƒ±: ' + error.message);
        }
    }

    // Orijinal fotoƒürafƒ± y√ºkle
    loadOriginalImage(imageInfo) {
        if (!imageInfo || !imageInfo.src) {
            console.log('‚ö†Ô∏è Orijinal fotoƒüraf bilgisi eksik');
            return;
        }

        console.log('üì∏ Orijinal fotoƒüraf y√ºkleniyor:', imageInfo.name);
        
        const img = new Image();
        img.onload = () => {
            this.image = img;
            this.initializeCoordinateSystem();
            this.redraw();
            console.log('‚úÖ Orijinal fotoƒüraf y√ºklendi:', {
                name: imageInfo.name,
                width: img.width,
                height: img.height
            });
        };
        
        img.onerror = () => {
            console.error('‚ùå Orijinal fotoƒüraf y√ºklenemedi:', imageInfo.src);
            this.showError('Orijinal fotoƒüraf y√ºklenemedi');
        };
        
        img.src = imageInfo.src;
        img.name = imageInfo.name;
    }

    // Proje fotoƒürafƒ±nƒ± y√ºkle
    loadProjectImage(imageFileInfo) {
        if (!imageFileInfo || !imageFileInfo.dataURL) {
            console.log('‚ö†Ô∏è Proje fotoƒüraf bilgisi eksik');
            return;
        }

        console.log('üì∏ Proje fotoƒürafƒ± y√ºkleniyor:', imageFileInfo.fileName);
        
        const img = new Image();
        img.onload = () => {
            this.image = img;
            
            // Dosya bilgilerini sakla
            this.image.name = imageFileInfo.fileName;
            this.image.filePath = imageFileInfo.filePath;
            this.image.lastModified = imageFileInfo.lastModified;
            
            this.initializeCoordinateSystem();
            this.redraw();
            
            console.log('‚úÖ Proje fotoƒürafƒ± y√ºklendi:', {
                name: imageFileInfo.fileName,
                width: img.width,
                height: img.height
            });
        };
        
        img.onerror = () => {
            console.error('‚ùå Proje fotoƒürafƒ± y√ºklenemedi:', imageFileInfo.fileName);
            this.showError('Proje fotoƒürafƒ± y√ºklenemedi');
        };
        
        img.src = imageFileInfo.dataURL;
    }

    // Fotoƒüraf y√ºklendiƒüinde proje etiketlerini kontrol et
    checkAndLoadProjectAnnotations(file) {
        // Eƒüer proje y√ºklendiyse ve aynƒ± fotoƒüraf ise
        if (this.projectImageFile && this.projectImageFile.fileName === file.name) {
            console.log('‚úÖ Aynƒ± fotoƒüraf y√ºklendi, etiketler g√∂steriliyor');
            this.showSuccess(`Etiketler y√ºklendi: ${this.annotations.length} adet`);
            this.redraw(); // Etiketleri g√∂ster
        }
    }

    // Sunucudan fotoƒüraf y√ºkle
    loadImageFromServer(filename) {
        console.log('üì∏ Sunucudan fotoƒüraf y√ºkleniyor:', filename);
        
        const img = new Image();
        img.onload = () => {
            this.image = img;
            
            // Dosya bilgilerini sakla
            this.image.name = filename;
            this.image.filePath = filename;
            this.image.lastModified = Date.now();
            
            this.initializeCoordinateSystem();
            this.redraw();
            
            console.log('‚úÖ Sunucudan fotoƒüraf y√ºklendi:', {
                name: filename,
                width: img.width,
                height: img.height
            });
            
            this.showSuccess(`Fotoƒüraf y√ºklendi: ${filename}`);
        };
        
        img.onerror = () => {
            console.error('‚ùå Sunucudan fotoƒüraf y√ºklenemedi:', filename);
            this.showError(`Fotoƒüraf y√ºklenemedi: ${filename}`);
        };
        
        // Backend'den fotoƒürafƒ± √ßek
        img.src = `${window.labelingAuth.baseURL}/files/${filename}`;
    }

    // Sunucu path fonksiyonu kaldƒ±rƒ±ldƒ± - sadece orijinal path kullanƒ±lƒ±yor

    // HTTP √ºzerinden dosya yolundan fotoƒüraf y√ºkle
    async loadImageFromPath(filePath) {
        console.log('üì∏ HTTP √ºzerinden dosya yolundan fotoƒüraf y√ºkleniyor:', filePath);
        
        // 1. √ñnce HTTP √ºzerinden dene
        const img = new Image();
        
        const tryHttpProtocol = () => {
            return new Promise((resolve, reject) => {
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('HTTP protocol failed'));
                
                // Server uploads dizininden direkt y√ºkle
                img.src = `${window.labelingAuth.baseURL}${filePath}`;
            });
        };
        
        try {
            await tryHttpProtocol();
            
            // Ba≈üarƒ±lƒ± oldu
            this.image = img;
            this.image.name = this.projectImageFile.fileName;
            this.image.filePath = filePath;
            this.image.fullPath = filePath;
            this.image.lastModified = this.projectImageFile.lastModified;
            
            this.initializeCoordinateSystem();
            this.redraw();
            
            console.log('‚úÖ HTTP √ºzerinden fotoƒüraf y√ºklendi:', {
                name: this.projectImageFile.fileName,
                path: filePath,
                width: img.width,
                height: img.height
            });
            
            this.showSuccess(`Fotoƒüraf y√ºklendi: ${this.projectImageFile.fileName}`);
            
        } catch (error) {
            console.error('‚ùå HTTP protocol ba≈üarƒ±sƒ±z, kullanƒ±cƒ±dan izin isteniyor...');
            
            // File System Access API ile izin iste
            await this.requestFilePermission(filePath);
        }
    }
    
    // Kullanƒ±cƒ±dan dosya se√ßmesini iste
    async requestFilePermission(filePath) {
        console.log('üìÅ Dosya bulunamadƒ±, kullanƒ±cƒ±dan se√ßim isteniyor...');
        this.showError(`Dosya bulunamadƒ±: ${filePath}. L√ºtfen dosyayƒ± tekrar se√ßin.`);
        this.showFileSelector();
    }

    // Base64 fonksiyonlarƒ± kaldƒ±rƒ±ldƒ± - sadece HTTP kullanƒ±lƒ±yor

    // Upload fonksiyonu kaldƒ±rƒ±ldƒ± - sadece path kullanƒ±lƒ±yor

    // Dosya se√ßiciyi g√∂ster (folder se√ßimi ile tam path almak i√ßin)
    showFileSelector() {
        const input = document.createElement('input');
        input.type = 'file';
        input.webkitdirectory = true; // Folder se√ßimi
        input.accept = 'image/*';
        input.style.display = 'none';
        
        input.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                // ƒ∞lk resim dosyasƒ±nƒ± al
                const imageFile = Array.from(e.target.files).find(file => 
                    file.type.startsWith('image/')
                );
                
                if (imageFile) {
                    this.loadSingleImage(imageFile);
                } else {
                    this.showError('Se√ßilen klas√∂rde resim dosyasƒ± bulunamadƒ±.');
                }
            }
        });
        
        document.body.appendChild(input);
        input.click();
        document.body.removeChild(input);
    }

    // √áoklu fotoƒüraf modunda mevcut fotoƒürafƒ±n etiketlerini kaydet
    async saveCurrentImageAnnotations() {
        if (!this.isMultiImageMode || !window.imageManager || !window.imageManager.currentImage) {
            console.log('‚ö†Ô∏è √áoklu fotoƒüraf modu deƒüil veya mevcut fotoƒüraf yok');
            return;
        }

        try {
            console.log('üíæ Mevcut fotoƒüraf etiketleri kaydediliyor...', {
                imageId: window.imageManager.currentImage.id,
                annotationsCount: this.annotations.length
            });

            // √ñnce mevcut etiketleri sil (auth bypass)
            await fetch(
                `http://localhost:3000/api/images/${window.imageManager.currentImage.id}/annotations`,
                { method: 'DELETE' }
            );

            // T√ºm etiketleri toplu olarak kaydet (doƒüru format)
            if (this.annotations.length > 0) {
                const annotationData = {
                    annotation_data: {
                        annotations: this.annotations // Array olarak g√∂nder
                    }
                };

                const response = await fetch(
                    `http://localhost:3000/api/images/${window.imageManager.currentImage.id}/annotations`,
                    {
                        method: 'POST',
                        body: JSON.stringify(annotationData),
                        headers: { 'Content-Type': 'application/json' }
                    }
                );

                if (!response.ok) {
                    console.error('‚ùå Etiketler kaydedilemedi:', response.statusText);
                } else {
                    console.log('‚úÖ T√ºm etiketler ba≈üarƒ±yla kaydedildi');
                }
            }

            console.log('‚úÖ Fotoƒüraf etiketleri ba≈üarƒ±yla kaydedildi');
            this.isSaved = true;
        } catch (error) {
            console.error('‚ùå Fotoƒüraf etiketleri kaydedilirken hata:', error);
            this.showError('Etiketler kaydedilirken hata olu≈ütu: ' + error.message);
        }
    }

    // Proje kaydet
    async saveProject() {
        if (!window.imageManager || !window.imageManager.currentProject) {
            console.log('‚ö†Ô∏è Aktif proje yok, kaydetme atlanƒ±yor');
            console.log('üîç ImageManager:', window.imageManager);
            console.log('üîç CurrentProject:', window.imageManager?.currentProject);
            return;
        }

        try {
            // √áoklu fotoƒüraf modunda, ImageManager √ºzerinden kaydet
            if (this.isMultiImageMode && window.imageManager) {
                await this.saveCurrentImageAnnotations();
                return;
            }

            // Sadece dosya path'i ve boyut bilgisi
            let imageFileInfo = null;
            if (this.image) {
                imageFileInfo = {
                    fileName: this.image.name || 'image.jpg',
                    filePath: this.image.filePath || this.image.name, // Dosya yolu
                    fullPath: this.image.fullPath || this.image.filePath || this.image.name, // Tam yol
                    width: this.image.width,
                    height: this.image.height,
                    lastModified: this.image.lastModified || Date.now()
                };
            }

            const projectData = {
                annotations: this.annotations,
                imageFile: imageFileInfo, // Sadece dosya bilgisi, fotoƒüraf deƒüil
                settings: {
                    quickLabelMode: this.quickLabelMode,
                    activeLabel: this.activeLabel,
                    selectedColor: this.selectedColor,
                    availableLabels: this.availableLabels,
                    favoriteLabels: this.favoriteLabels,
                    currentImageIndex: this.currentImageIndex,
                    croppedImages: this.croppedImages, // Export i√ßin ayrƒ± tutuluyor
                    exportFolderPath: this.exportFolderPath,
                    showGrid: this.showGrid,
                    showFullscreenCrosshair: this.showFullscreenCrosshair,
                    labelCaseMode: this.labelCaseMode
                }
            };

            console.log('üì§ Proje verisi g√∂nderiliyor:', {
                projectId: window.imageManager.currentProject,
                annotations: projectData.annotations.length,
                imageFile: projectData.imageFile ? projectData.imageFile.fileName : 'Yok',
                dataSize: JSON.stringify(projectData).length
            });

            // Auth bypass - basit fetch kullan
            const response = await fetch(
                `http://localhost:3000/api/projects/${window.imageManager.currentProject}`, 
                {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: projectData })
                }
            );
            
            if (response.ok) {
                this.isSaved = true;
                console.log('‚úÖ Proje kaydedildi');
            } else {
                const error = await response.json();
                console.error('‚ùå Proje kaydetme hatasƒ±:', error.error);
                this.showError('Proje kaydedilemedi: ' + error.error);
            }
        } catch (error) {
            console.error('‚ùå Proje kaydetme hatasƒ±:', error);
            this.showError('Proje kaydetme hatasƒ±: ' + error.message);
        }
    }

    setupEventListeners() {
        // DOM zaten y√ºkl√º olduƒüu i√ßin direkt setup yap
        this.setupFileEventListeners();
        this.setupLabelCaseModeListener();
        this.setupExportFolderSelector();
        this.setupShortcutsModalListeners();
        this.setupPaginationListeners();
        this.setupColorFilters();
    }

    setupPaginationListeners() {
        // Sayfalama butonlarƒ±
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => this.goToPreviousPage());
        }
        
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => this.goToNextPage());
        }
    }


    updateUserInfo() {
        // Auth sisteminden kullanƒ±cƒ± ve proje bilgilerini al
        if (window.startManager && window.startManager.auth) {
            console.log('üîÑ Script.js updateUserInfo √ßaƒürƒ±ldƒ±');
            window.startManager.updateUserInfo();
        } else {
            console.error('‚ùå startManager veya auth bulunamadƒ±');
        }
    }

    setupLabelCaseModeListener() {
        const labelCaseSelect = document.getElementById('labelCaseMode');
        if (labelCaseSelect) {
            labelCaseSelect.addEventListener('change', (e) => {
                this.labelCaseMode = e.target.value;
                this.showInfo(`Etiket harf durumu: ${e.target.options[e.target.selectedIndex].text}`);
            });
        }
    }

    setupExportFolderSelector() {
        const selectFolderBtn = document.getElementById('selectExportFolder');
        const folderPathInput = document.getElementById('exportFolderPath');
        
        if (selectFolderBtn && folderPathInput) {
            selectFolderBtn.addEventListener('click', () => {
                this.selectExportFolder();
            });
        }
    }

    setupShortcutsModalListeners() {
        // Shortcuts modal a√ßma butonu
        const showShortcutsBtn = document.getElementById('showShortcuts');
        if (showShortcutsBtn) {
            showShortcutsBtn.addEventListener('click', () => this.showShortcutsModal());
        }

        // Shortcuts modal kapatma butonlarƒ±
        const closeShortcutsModal = document.getElementById('closeShortcutsModal');
        const closeShortcutsBtn = document.getElementById('closeShortcutsBtn');
        
        if (closeShortcutsModal) {
            closeShortcutsModal.addEventListener('click', () => this.closeShortcutsModal());
        }
        
        if (closeShortcutsBtn) {
            closeShortcutsBtn.addEventListener('click', () => this.closeShortcutsModal());
        }

        // Modal dƒ±≈üƒ±na tƒ±klanƒ±nca kapat
        const shortcutsModal = document.getElementById('shortcutsModal');
        if (shortcutsModal) {
            shortcutsModal.addEventListener('click', (e) => {
                if (e.target === shortcutsModal) {
                    this.closeShortcutsModal();
                }
            });
        }
    }


    setupFavoriteLabelListeners() {
        // Favori Ekle butonu
        const addFavoriteBtn = document.getElementById('addFavoriteLabel');
        if (addFavoriteBtn) {
            addFavoriteBtn.addEventListener('click', () => this.showFavoriteLabelsModal());
        }

        // Favori etiketler modal event listeners
        const favoriteModal = document.getElementById('favoriteLabelsModal');
        const closeFavoriteModal = document.getElementById('closeFavoriteModal');
        const addFavoriteBtn2 = document.getElementById('addFavoriteBtn');
        const newFavoriteInput = document.getElementById('newFavoriteInput');

        if (closeFavoriteModal) {
            closeFavoriteModal.addEventListener('click', () => this.closeFavoriteLabelsModal());
        }

        if (addFavoriteBtn2) {
            addFavoriteBtn2.addEventListener('click', () => this.addFavoriteFromModal());
        }

        if (newFavoriteInput) {
            newFavoriteInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    this.addFavoriteFromModal();
                }
            });
        }

        // Modal dƒ±≈üƒ±na tƒ±klama ile kapatma
        if (favoriteModal) {
            favoriteModal.addEventListener('click', (e) => {
                if (e.target === favoriteModal) {
                    this.closeFavoriteLabelsModal();
                }
            });
        }
    }

    setupImageNavigationListeners() {
        // Navigasyon butonlarƒ±
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const markLabeledBtn = document.getElementById('markLabeledBtn');
        const markUnlabeledBtn = document.getElementById('markUnlabeledBtn');
        
        if (prevBtn) {
            prevBtn.addEventListener('click', () => {
                this.previousImage();
            });
        }
        
        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                this.nextImage();
            });
        }
        
        if (markLabeledBtn) {
            markLabeledBtn.addEventListener('click', () => {
                this.markCurrentImageAsLabeled();
            });
        }
        
        if (markUnlabeledBtn) {
            markUnlabeledBtn.addEventListener('click', () => {
                this.markCurrentImageAsUnlabeled();
            });
        }
    }

    setupFileEventListeners() {
        // Dosya y√ºkleme - g√ºvenli element kontrol√º
        const singleImageBtn = document.getElementById('singleImageBtn');
        const scanFolderBtn = document.getElementById('scanFolderBtn');
        const imageInput = document.getElementById('imageInput');
        
        if (singleImageBtn && imageInput) {
            singleImageBtn.addEventListener('click', () => {
                imageInput.click();
            });
        }
        
        if (scanFolderBtn) {
            scanFolderBtn.addEventListener('click', () => {
                this.scanProjectFolder();
            });
        }

        if (imageInput) {
            imageInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    this.uploadAndLoadImage(e.target.files[0]);
                }
            });
        }

        // folderInput kaldƒ±rƒ±ldƒ± - artƒ±k klas√∂r tarama API ile yapƒ±lƒ±yor

        // Ara√ß se√ßimi
        // Tool se√ßimi - Kaldƒ±rƒ±ldƒ±: Sadece dikd√∂rtgen kullanƒ±lƒ±yor
        

        // Hƒ±zlƒ± i≈ülemler

        // Hƒ±zlƒ± etiket modu toggle
        document.getElementById('quickLabelModeToggle').addEventListener('change', (e) => {
            this.quickLabelMode = e.target.checked;
            this.updateQuickModeUI();
        });


        document.getElementById('gridToggle').addEventListener('change', (e) => {
            this.showGrid = e.target.checked;
            this.updateGridDisplay();
        });

        document.getElementById('crosshairToggle').addEventListener('change', (e) => {
            this.showFullscreenCrosshair = e.target.checked;
            if (!this.showFullscreenCrosshair) {
                this.hideFullscreenCrosshairCursor();
            }
        });

        // Canvas olaylarƒ± artƒ±k CanvasManager'da kuruldu - duplikasyon kaldƒ±rƒ±ldƒ±

        // Diƒüer kontroller
        const addNewLabelBtn = document.getElementById('addNewLabel');
        const cropAndSaveBtn = document.getElementById('cropAndSave');
        const yoloExportBtn = document.getElementById('yoloExport');
        const exportDataBtn = document.getElementById('exportData');
        
        if (addNewLabelBtn) {
            addNewLabelBtn.addEventListener('click', () => this.showNewLabelModal());
        }
        
        const normalSaveBtn = document.getElementById('normalSave');
        if (normalSaveBtn) {
            normalSaveBtn.addEventListener('click', () => this.normalSave());
        }
        
        if (cropAndSaveBtn) {
            cropAndSaveBtn.addEventListener('click', () => this.cropAndSaveAll());
        }
        
        if (yoloExportBtn) {
            yoloExportBtn.addEventListener('click', () => this.yoloExport());
        }
        
        if (exportDataBtn) {
            exportDataBtn.addEventListener('click', () => this.showExportModal());
        }


        // Zoom kontrolleri
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomOutBtn = document.getElementById('zoomOut');
        const fitScreenBtn = document.getElementById('fitScreen');
        
        // Zoom kontrolleri - Kaldƒ±rƒ±ldƒ±: Mouse wheel ile zoom
        
        if (fitScreenBtn) {
            fitScreenBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.fitToScreen();
            });
        }

        // Modal kontrolleri
        this.setupModalListeners();



        // Pencere boyutu deƒüi≈ütiƒüinde canvas'ƒ± yeniden boyutlandƒ±r
        window.addEventListener('resize', () => this.resizeCanvas());

        // Keyboard shortcuts
        this.setupKeyboardShortcuts();

        // Export modal kontrolleri
        this.setupExportModalListeners();

        // YOLO √∂rnek modal
        this.setupYoloExampleModal();
        
    }

    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Modal a√ßƒ±kken shortcuts'larƒ± devre dƒ±≈üƒ± bƒ±rak
            const labelModal = document.getElementById('labelModal');
            if (labelModal && labelModal.style.display === 'block') return;
            
            // Input alanlarƒ±ndayken shortcuts'larƒ± devre dƒ±≈üƒ± bƒ±rak
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch (e.key) {
                // Etiket se√ßimi (1-9)
                case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9':
                    this.selectLabelByNumber(parseInt(e.key) - 1);
                    e.preventDefault();
                    break;
                
                case '0':
                    this.clearActiveLabel();
                    e.preventDefault();
                    break;

                // Ara√ß se√ßimi
                case 'r': case 'R':
                    this.setTool('rectangle');
                    e.preventDefault();
                    break;
                
                case 'p': case 'P':
                    // Polygon tool kaldƒ±rƒ±ldƒ±
                    e.preventDefault();
                    break;

                // ESC tu≈üu ile edit mode kapanmasƒ± iptal edildi
                // case 'Escape':
                //     this.cancelCurrentOperation();
                //     e.preventDefault();
                //     break;

                // Backspace tu≈üu ile focuslanan etiketi sil
                case 'Backspace':
                    if (this.focusedAnnotation) {
                        const label = this.focusedAnnotation.label;
                        this.deleteAnnotation(this.focusedAnnotation.id);
                        this.showInfo(`"${label}" etiketi silindi.`);
                        this.focusedAnnotation = null;
                        this.redraw();
                    }
                    e.preventDefault();
                    break;

                // Fotoƒüraf navigasyonu


                // Navigasyon (multi-image)
                case ' ': case 'Enter':
                    if (this.isMultiImageMode && !this.isProcessing) {
                        this.nextImage();
                        e.preventDefault();
                    }
                    break;
                
                case 'Backspace':
                    if (this.isMultiImageMode && !this.isProcessing) {
                        this.previousImage();
                        e.preventDefault();
                    }
                    break;

                case 'Home':
                    if (this.isMultiImageMode && !this.isProcessing) {
                        this.switchToImage(0);
                        e.preventDefault();
                    }
                    break;
                
                case 'End':
                    if (this.isMultiImageMode && !this.isProcessing) {
                        this.switchToImage(this.images ? this.images.length - 1 : 0);
                        e.preventDefault();
                    }
                    break;

                // Yeni etiket
                case 'n': case 'N':
                    this.showNewLabelModal();
                    e.preventDefault();
                    break;

                // Zoom kontrolleri
                case '+': case '=':
                    this.zoomIn();
                    e.preventDefault();
                    break;
                
                case '-': case '_':
                    this.zoomOut();
                    e.preventDefault();
                    break;

                case 'f': case 'F':
                    this.fitToScreen();
                    e.preventDefault();
                    break;

                // Genel
                case 'Delete':
                    this.deleteSelectedAnnotation();
                    e.preventDefault();
                    break;
            }

            // Ctrl/Command kombinasyonlarƒ± (Mac uyumlu)
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'z': case 'Z':
                        if (e.shiftKey) {
                            this.redo(); // Ctrl+Shift+Z veya Cmd+Shift+Z
                        } else {
                            this.undo(); // Ctrl+Z veya Cmd+Z
                        }
                        e.preventDefault();
                        break;
                    
                    case 'c': case 'C':
                        this.copyAnnotation();
                        e.preventDefault();
                        break;
                    
                    case 'v': case 'V':
                        this.pasteAnnotation();
                        e.preventDefault();
                        break;
                    
                    case 's': case 'S':
                        this.saveProject();
                        e.preventDefault();
                        break;
                }
            }
        });
    }

    selectLabelByNumber(index) {
        if (index >= 0 && index < (this.availableLabels ? this.availableLabels.length : 0)) {
            this.setActiveLabel(this.availableLabels[index]);
        }
    }

    clearActiveLabel() {
        this.activeLabel = null;
        this.updateLabelList();
    }

    cancelCurrentOperation() {
        // Edit modundan √ßƒ±k
        if (this.editMode) {
            this.exitEditMode();
            return;
        }
        
        if (this.currentAnnotation) {
            this.currentAnnotation = null;
            this.needsRedraw = true;
            this.redraw();
        }
        
    }

    exitEditMode() {
        this.editMode = false;
        this.editingAnnotation = null;
        this.selectedAnnotation = null;
        this.isDraggingHandle = false;
        this.dragHandle = null;
        this.canvas.style.cursor = 'crosshair';
        
        this.redraw();
    }

    deleteSelectedAnnotation() {
        // Bu √∂zellik i√ßin se√ßim sistemi gerekli - ≈üimdilik son annotation'ƒ± sil
        if (this.annotations && this.annotations.length > 0) {
            this.annotations.pop();
            this.updateAnnotationList();
            this.redraw();
            console.log('Son annotation silindi');
        }
    }

    // Geli≈ümi≈ü Undo/Redo sistemi
    saveToHistory() {
        // Mevcut durumu kaydet
        const state = {
            annotations: JSON.parse(JSON.stringify(this.annotations)),
            selectedAnnotation: this.selectedAnnotation ? this.selectedAnnotation.id : null,
            timestamp: Date.now()
        };
        
        // Ge√ßmi≈üte ileriye gitmi≈üsek, o noktadan sonraki ge√ßmi≈üi sil
        if (this.historyIndex < this.history.length - 1) {
            this.history = this.history.slice(0, this.historyIndex + 1);
        }
        
        // Yeni durumu ekle
        this.history.push(state);
        this.historyIndex = this.history.length - 1;
        
        // Maksimum ge√ßmi≈ü boyutunu kontrol et
        if (this.history.length > this.maxHistorySize) {
            this.history.shift();
            this.historyIndex--;
        }
    }
    
    undo() {
        if (this.historyIndex > 0) {
            this.historyIndex--;
            this.restoreFromHistory();
            console.log('Geri alƒ±ndƒ±');
        }
    }
    
    redo() {
        if (this.historyIndex < this.history.length - 1) {
            this.historyIndex++;
            this.restoreFromHistory();
            console.log('ƒ∞leri alƒ±ndƒ±');
        }
    }
    
    restoreFromHistory() {
        if (this.historyIndex >= 0 && this.historyIndex < this.history.length) {
            const state = this.history[this.historyIndex];
            this.annotations = JSON.parse(JSON.stringify(state.annotations));
            
            // Se√ßili annotation'ƒ± geri y√ºkle
            if (state.selectedAnnotation) {
                this.selectedAnnotation = this.annotations.find(ann => ann.id === state.selectedAnnotation);
            } else {
                this.selectedAnnotation = null;
            }
            
            this.updateAnnotationList();
            
            // Etiket listesini g√ºncelle - kullanƒ±lmayan etiketleri temizle
            this.updateLabelListFromAnnotations();
            
            this.redraw();
        }
    }
    
    // Kopyala-Yapƒ±≈ütƒ±r sistemi
    copyAnnotation() {
        if (this.selectedAnnotation) {
            this.copiedAnnotation = JSON.parse(JSON.stringify(this.selectedAnnotation));
            this.showSuccess(`"${this.selectedAnnotation.label}" kopyalandƒ±!`);
        }
    }
    
    pasteAnnotation() {
        if (this.copiedAnnotation && this.image) {
            // Yeni annotation olu≈ütur
            const newAnnotation = {
                ...this.copiedAnnotation,
                id: Date.now(), // Yeni ID
                x: this.copiedAnnotation.x + 20, // Biraz kaydƒ±r
                y: this.copiedAnnotation.y + 20,
                points: this.copiedAnnotation.points.map(point => ({
                    x: point.x + 20,
                    y: point.y + 20
                })),
                color: this.getNextAutoColor() // Yeni renk
            };
            
            this.annotations.push(newAnnotation);
            this.selectedAnnotation = newAnnotation;
            this.updateAnnotationList();
            
            // History'ye kaydet
            this.saveToHistory();
            
            this.redraw();
            this.showSuccess(`"${newAnnotation.label}" yapƒ±≈ütƒ±rƒ±ldƒ±!`);
        }
    }

    setupModalListeners() {
        const modal = document.getElementById('labelModal');
        const closeBtn = modal.querySelector('.close');
        const cancelBtn = document.getElementById('cancelLabel');
        const confirmBtn = document.getElementById('confirmLabel');
        const modalInput = document.getElementById('modalLabelInput');

        // Modal kapatma
        if (closeBtn) {
        closeBtn.addEventListener('click', () => this.closeModal());
        }
        if (cancelBtn) {
        cancelBtn.addEventListener('click', () => this.closeModal());
        }
        
        // Modal dƒ±≈üƒ±na tƒ±klama
        window.addEventListener('click', (e) => {
            if (e.target === modal) this.closeModal();
        });

        // Etiket onaylama
        confirmBtn.addEventListener('click', () => this.confirmNewLabel());
        
        // Enter tu≈üu ile onaylama
        modalInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.confirmNewLabel();
            }
        });

        // Etiket √∂nerileri i√ßin input event listener
        modalInput.addEventListener('input', (e) => {
            this.showLabelSuggestions(e.target.value);
        });

        // Focus olayƒ±
        modalInput.addEventListener('focus', () => {
            this.showLabelSuggestions(modalInput.value);
        });

        // Blur olayƒ± (biraz gecikme ile kapat)
        modalInput.addEventListener('blur', () => {
            setTimeout(() => {
                this.hideLabelSuggestions();
            }, 200);
        });
    }

    createModalElements() {
        console.log('üîß Modal elementleri olu≈üturuluyor...');
        
        // Label Modal olu≈ütur
        const labelModal = document.createElement('div');
        labelModal.id = 'labelModal';
        labelModal.className = 'modal';
        labelModal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Etiket Ekle</h3>
                    <button class="close">&times;</button>
                </div>
                <div class="input-group">
                    <label class="input-label">Favori Etiketler</label>
                    <div id="favoriteLabels" class="favorite-labels">
                        <!-- Favori etiketler burada g√∂r√ºnecek -->
                    </div>
                </div>
                <div class="input-group">
                    <div id="availableLabelsContainer" class="available-labels-container">
                        <!-- Mevcut etiketler burada g√∂r√ºnecek -->
                    </div>
                </div>
                <div class="input-group">
                    <label class="input-label" for="modalLabelInput">Etiket Adƒ± *</label>
                    <input type="text" class="input" id="modalLabelInput" placeholder="√∂rn: #arac" />
                    <div id="labelSuggestions" class="label-suggestions" style="display: none;">
                        <!-- Etiket √∂nerileri burada g√∂r√ºnecek -->
                    </div>
                </div>
                <div class="input-group">
                    <label class="input-label">Renk Se√ßimi</label>
                    <div class="color-picker-container">
                        <div class="color-options" id="colorOptions">
                            <div class="color-option" data-color="#2ecc71" style="background-color: #2ecc71;"></div>
                            <div class="color-option" data-color="#e74c3c" style="background-color: #e74c3c;"></div>
                            <div class="color-option" data-color="#3498db" style="background-color: #3498db;"></div>
                            <div class="color-option" data-color="#f39c12" style="background-color: #f39c12;"></div>
                            <div class="color-option" data-color="#9b59b6" style="background-color: #9b59b6;"></div>
                            <div class="color-option" data-color="#1abc9c" style="background-color: #1abc9c;"></div>
                            <div class="color-option" data-color="#e67e22" style="background-color: #e67e22;"></div>
                            <div class="color-option" data-color="#34495e" style="background-color: #34495e;"></div>
                        </div>
                        <div class="color-preview" id="selectedColorPreview" style="background-color: #2ecc71;"></div>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button class="btn" id="cancelLabel">ƒ∞ptal</button>
                    <button class="btn btn-primary" id="confirmLabel">Etiket Ekle</button>
                </div>
            </div>
        `;
        
        // Body'ye ekle
        document.body.appendChild(labelModal);
        console.log('‚úÖ Label Modal olu≈üturuldu ve eklendi');
        
        // Event listener'larƒ± ekle
        this.setupModalListeners();
        
        // Modal'ƒ± g√∂ster
        labelModal.classList.add('show');
    }

    showNewLabelModal() {
        console.log('üîç showNewLabelModal √ßaƒürƒ±ldƒ±');
        console.log('üîç Document ready state:', document.readyState);
        console.log('üîç Document body:', document.body);
        console.log('üîç All elements with id containing "Modal":', document.querySelectorAll('[id*="Modal"]'));
        
        // Modal elementlerini tekrar kontrol et
        console.log('üîç Tekrar kontrol - labelModal:', document.getElementById('labelModal'));
        console.log('üîç Tekrar kontrol - favoriteLabelsModal:', document.getElementById('favoriteLabelsModal'));
        console.log('üîç Tekrar kontrol - T√ºm modal elementleri:', document.querySelectorAll('.modal'));
        
        const modal = document.getElementById('labelModal');
        const modalInput = document.getElementById('modalLabelInput');
        
        console.log('üîç Modal element:', modal);
        console.log('üîç Modal input element:', modalInput);
        
        if (!modal) {
            console.error('‚ùå Modal bulunamadƒ±!');
            console.log('üîç T√ºm modal elementleri:', document.querySelectorAll('.modal'));
            console.log('üîç T√ºm div elementleri:', document.querySelectorAll('div'));
            
            // Modal elementlerini manuel olarak olu≈ütur
            console.log('üîß Modal elementlerini manuel olarak olu≈üturuyorum...');
            this.createModalElements();
            return;
        }
        
        if (!modalInput) {
            console.error('‚ùå Modal input bulunamadƒ±!');
            return;
        }
        
        modal.classList.add('show');
        modalInput.focus();
        modalInput.value = '';
        this.selectedFavoriteLabel = null; // Favori etiket se√ßimini sƒ±fƒ±rla
        this.showLabelSuggestions('');
        
        // Favori etiketleri g√∂ster
        this.showFavoriteLabelsInModal();
        
        // Mevcut etiket listesini g√∂ster
        this.showAvailableLabelsInModal();
        
        // Renk se√ßiciyi ba≈ülat
        this.setupColorPicker();
        
        console.log('‚úÖ Modal a√ßƒ±ldƒ±');
    }

    showLabelSuggestions(query) {
        const suggestionsContainer = document.getElementById('labelSuggestions');
        if (!suggestionsContainer) return;

        // Mevcut etiketleri filtrele
        const filteredLabels = (this.availableLabels || []).filter(label => 
            label.toLowerCase().includes(query.toLowerCase())
        );

        if ((filteredLabels ? filteredLabels.length : 0) === 0 || (query ? query.length : 0) === 0) {
            this.hideLabelSuggestions();
            return;
        }

        // √ñnerileri g√∂ster
        suggestionsContainer.innerHTML = '';
        suggestionsContainer.style.display = 'block';

        filteredLabels.forEach((label, index) => {
            const suggestionItem = document.createElement('div');
            suggestionItem.className = 'suggestion-item';
            
            // Etiket rengini al
            const colors = ['#2ecc71', '#e74c3c', '#3498db', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
            const color = colors[index % colors.length];

            suggestionItem.innerHTML = `
                <div class="suggestion-color" style="background-color: ${color}"></div>
                <div class="suggestion-text">${label}</div>
                <div class="suggestion-hint">Mevcut etiket</div>
            `;

            suggestionItem.addEventListener('click', () => {
                document.getElementById('modalLabelInput').value = label;
                this.hideLabelSuggestions();
            });

            suggestionsContainer.appendChild(suggestionItem);
        });
    }

    hideLabelSuggestions() {
        const suggestionsContainer = document.getElementById('labelSuggestions');
        if (suggestionsContainer) {
            suggestionsContainer.style.display = 'none';
        }
    }

    setupColorPicker() {
        const colorOptions = document.querySelectorAll('.color-option');
        const colorPreview = document.getElementById('selectedColorPreview');
        
        // Varsayƒ±lan rengi ayarla
        this.selectedColor = '#2ecc71';

        // ƒ∞lk rengi se√ßili yap
        colorOptions.forEach(option => option.classList.remove('selected'));
        if (colorOptions[0]) {
            colorOptions[0].classList.add('selected');
            this.selectedColor = colorOptions[0].dataset.color;
            if (colorPreview) colorPreview.style.backgroundColor = this.selectedColor;
        }

        // Renk se√ßimi event listener'larƒ±
        colorOptions.forEach(option => {
            option.addEventListener('click', () => {
                // T√ºm se√ßimleri kaldƒ±r
                colorOptions.forEach(opt => opt.classList.remove('selected'));
                
                // Se√ßili rengi i≈üaretle
                option.classList.add('selected');
                this.selectedColor = option.dataset.color;
                
                // Preview'ƒ± g√ºncelle
                if (colorPreview) {
                    colorPreview.style.backgroundColor = this.selectedColor;
                }
            });
        });
    }

    closeModal() {
        const modal = document.getElementById('labelModal');
        if (modal) {
            modal.classList.remove('show');
        }
        
        // Ge√ßici annotation'ƒ± temizle
        if (this.currentAnnotation) {
            this.currentAnnotation = null;
            this.redraw();
        }
        
        // √ñnerileri gizle
        this.hideLabelSuggestions();
    }

    confirmNewLabel() {
        const modalInput = document.getElementById('modalLabelInput');
        const label = modalInput.value.trim();

        // Favori etiket se√ßildiyse etiket ismi bo≈ü olsa bile devam et
        if (!label && !this.selectedFavoriteLabel) {
            this.showWarning('L√ºtfen etiket adƒ± girin!');
            return;
        }

        const finalLabel = label || this.selectedFavoriteLabel;
        const transformedLabel = this.transformLabelName(finalLabel);

        // Etiket zaten var mƒ± kontrol et
        if (!this.availableLabels.includes(transformedLabel)) {
            this.availableLabels.push(transformedLabel);
            this.updateLabelList();
        }

        // Eƒüer √ßizim bekleyen annotation varsa, bu etiketi ata
        if (this.currentAnnotation) {
            this.currentAnnotation.label = transformedLabel;
            // Se√ßili rengi kullan, yoksa otomatik renk
            this.currentAnnotation.color = this.selectedColor || this.getNextAutoColor();
            this.annotations.push(this.currentAnnotation);
            
            // Database'e kaydet (async olarak)
            console.log('üîµ Etiket eklendi, database\'e kaydediliyor...', this.currentAnnotation);
            this.saveAllAnnotationsToDatabase(); // Basit API kullan
            
            this.currentAnnotation = null;
            this.updateAnnotationList();
            
            // History'ye kaydet
            this.saveToHistory();
            
            this.redraw();
            
            // Yeni annotation olu≈üturuldu, onu se√ßili yap
            this.selectedAnnotation = this.annotations[this.annotations.length - 1];
            this.focusedAnnotation = this.annotations[this.annotations.length - 1];
        }

        // Yeni eklenen etiketi aktif yap
        this.setActiveLabel(transformedLabel);
        this.closeModal();
    }

    setupExportModalListeners() {
        // Export modal kontrolleri - g√ºvenli element kontrol√º
        const closeExport = document.getElementById('closeExport');
        const cancelExport = document.getElementById('cancelExport');
        const confirmExport = document.getElementById('confirmExport');
        const previewExport = document.getElementById('previewExport');

        if (closeExport) closeExport.addEventListener('click', () => this.closeExportModal());
        if (cancelExport) cancelExport.addEventListener('click', () => this.closeExportModal());
        if (confirmExport) confirmExport.addEventListener('click', () => this.performExport());
        if (previewExport) previewExport.addEventListener('click', () => this.previewExport());

        // Train split deƒüi≈ütiƒüinde val split'i g√ºncelle
        const trainSplit = document.getElementById('trainSplit');
        if (trainSplit) {
            trainSplit.addEventListener('input', (e) => {
                const trainValue = parseInt(e.target.value);
                const valSplit = document.getElementById('valSplit');
                if (valSplit) valSplit.value = 100 - trainValue;
                this.updateExportPreview();
            });
        }

        // Export options change - sadece mevcut element'ler i√ßin
        ['includeImages', 'normalizeCoordinates'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', () => this.updateExportPreview());
            }
        });

        // Format change
        document.querySelectorAll('input[name="exportFormat"]').forEach(radio => {
            radio.addEventListener('change', () => this.updateExportPreview());
        });

        // Modal dƒ±≈üƒ±na tƒ±klama
        window.addEventListener('click', (e) => {
            const exportModal = document.getElementById('exportModal');
            if (e.target === exportModal) this.closeExportModal();
        });
    }

    showExportModal() {
        // Export preview'ƒ± g√ºncelle
        this.updateExportPreview();
        
        const modal = document.getElementById('exportModal');
        if (modal) {
            modal.classList.add('show');
        }
    }

    closeExportModal() {
        const modal = document.getElementById('exportModal');
        if (modal) {
            modal.classList.remove('show');
        }
    }

    updateClassMapping() {
        const container = document.getElementById('classMapping');
        if (!container) return;
        container.innerHTML = '';

        this.availableLabels.forEach((label, index) => {
            const mappingDiv = document.createElement('div');
            mappingDiv.style.margin = '5px 0';
            mappingDiv.innerHTML = `
                <label style="display: flex; justify-content: space-between; align-items: center;">
                    <span>${label}</span>
                    <input type="number" value="${index}" min="0" max="99" style="width: 50px;" 
                           data-label="${label}" class="class-id-input">
                </label>
            `;
            container.appendChild(mappingDiv);
        });
    }

    getClassMapping() {
        const inputs = document.querySelectorAll('.class-id-input');
        const mapping = {};
        
        inputs.forEach(input => {
            const label = input.getAttribute('data-label');
            const classId = parseInt(input.value);
            mapping[label] = classId;
        });
        
        return mapping;
    }

    // Sonraki rengi al ve index'i artƒ±r
    getNextAutoColor() {
        const color = this.colorPalette[this.currentColorIndex];
        this.currentColorIndex = (this.currentColorIndex + 1) % this.colorPalette.length;
        return color;
    }

    // Yeni annotation olu≈ütururken otomatik renk ata
    createNewAnnotation(annotationData) {
        // Se√ßili renk varsa onu kullan, yoksa otomatik renk
        const color = this.selectedColor || this.getNextAutoColor();
        const annotation = {
            ...annotationData,
            color: color,
            locked: false // Varsayƒ±lan olarak kilitli deƒüil
        };
        
        // Label kontrol√º - bo≈üsa uyarƒ± ver ama devam et
        if (!annotation.label || annotation.label.trim() === '') {
            console.log('‚ö†Ô∏è Bo≈ü label tespit edildi, modal\'dan se√ßim yapƒ±lacak');
        } else {
            console.log('‚úÖ Label korundu:', annotation.label);
        }
        
        // En sol √ºst handle index'ini ba≈ülat (getLabelPosition tarafƒ±ndan hesaplanacak)
        if (annotation.points && annotation.points.length > 0) {
            // getLabelPosition √ßaƒürƒ±ldƒ±ƒüƒ±nda topLeftHandleIndex hesaplanacak
            annotation.topLeftHandleIndex = undefined;
        }
        
        // Etiket pozisyonunu sabit tutmak i√ßin labelPosition ekle
        if (!annotation.labelPosition) {
            // Sol √ºst k√∂≈üe pozisyonunu hesapla
            let leftTopPoint;
            if (annotation.points && annotation.points.length > 0) {
                const xs = annotation.points.map(p => p.x);
                const ys = annotation.points.map(p => p.y);
                const minX = Math.min(...xs);
                const minY = Math.min(...ys);
                leftTopPoint = { x: minX, y: minY - 20 }; // 20px yukarƒ±
            } else {
                leftTopPoint = { x: annotation.x, y: annotation.y - 20 }; // 20px yukarƒ±
            }
            annotation.labelPosition = leftTopPoint;
        }
        
        console.log('‚úÖ createNewAnnotation:', { 
            inputLabel: annotationData.label, 
            finalLabel: annotation.label, 
            color: annotation.color,
            labelPosition: annotation.labelPosition,
            fullAnnotationData: annotationData,
            fullFinalAnnotation: annotation
        });
        
        // Annotations listesine otomatik ekle
        this.annotations.push(annotation);
        this.isSaved = false; // Yeni annotation eklendi, kaydedilmemi≈ü
        
        // Projeyi kaydet
        this.saveProject();
        
        return annotation;
    }

    async performExport() {
        // ExportManager ile export yap
        if (this.exportManager) {
            await this.exportManager.performExport();
        } else {
            this.showError('ExportManager bulunamadƒ±!');
        }
    }

    getExportOptions() {
        return {
            includeImages: document.getElementById('includeImages').checked,
            includeCrops: document.getElementById('includeCrops').checked,
            normalizeCoordinates: document.getElementById('normalizeCoordinates').checked,
            includeMetadata: document.getElementById('includeMetadata').checked,
            compressOutput: document.getElementById('compressOutput').checked,
            imageQuality: parseInt(document.getElementById('imageQuality').value) / 100
        };
    }

    updateExportPreview() {
        const totalAnnotations = this.annotations ? this.annotations.length : 0;
        const formatElement = document.querySelector('input[name="exportFormat"]:checked');
        const format = formatElement ? formatElement.value : 'yolo';
        
        const includeImages = document.getElementById('includeImages')?.checked || true;
        
        // Dosya sayƒ±sƒ±nƒ± hesapla
        let totalFiles = 0;
        if (includeImages) totalFiles += (this.images ? this.images.length : 0) || 1;
        
        // Format'a g√∂re ek dosyalar
        switch (format) {
            case 'yolo':
            case 'yolo_segmentation':
                totalFiles += totalAnnotations + 1; // .txt files + .yaml
                break;
            case 'coco':
                totalFiles += 1; // .json
                break;
        }
        
        // Tahmini boyut hesapla (MB)
        let estimatedSize = 0;
        if (includeImages && this.image) {
            const imageSize = (this.image.width * this.image.height * 3) / (1024 * 1024); // Rough estimate
            estimatedSize += imageSize * ((this.images ? this.images.length : 0) || 1);
        }
        estimatedSize = Math.round(estimatedSize * 100) / 100;
        
        // Tahmini s√ºre hesapla (saniye)
        const estimatedTime = Math.max(1, Math.round(totalFiles * 0.1));
        
        // UI'yi g√ºncelle - g√ºvenli element kontrol√º
        const updateElement = (id, value) => {
            const element = document.getElementById(id);
            if (element) element.textContent = value;
        };
        
        updateElement('totalAnnotations', totalAnnotations);
        updateElement('totalFiles', totalFiles);
        updateElement('estimatedSize', estimatedSize + ' MB');
        updateElement('estimatedTime', estimatedTime + ' saniye');
    }

    previewExport() {
        const formatElement = document.querySelector('input[name="exportFormat"]:checked');
        const format = formatElement ? formatElement.value : 'yolo';
        
        const includeImages = document.getElementById('includeImages')?.checked || true;
        const normalizeCoordinates = document.getElementById('normalizeCoordinates')?.checked || true;
        
        let preview = `üìã Export √ñnizleme:\n\n`;
        preview += `Format: ${format.toUpperCase()}\n`;
        preview += `Toplam Etiket: ${this.annotations.length}\n`;
        preview += `Resimler: ${includeImages ? 'Dahil' : 'Dahil Deƒüil'}\n`;
        preview += `Koordinat Normalle≈ütirme: ${normalizeCoordinates ? 'A√ßƒ±k' : 'Kapalƒ±'}\n`;
        
        this.showInfo(preview);
    }

    autoMapClasses() {
        this.availableLabels.forEach((label, index) => {
            const input = document.querySelector(`input[name="class_${index}"]`);
            if (input) {
                input.value = index;
            }
        });
        this.updateExportPreview();
        this.showToast('Sƒ±nƒ±f e≈üleme otomatik olarak yapƒ±ldƒ±!', 'success');
    }

    resetClassMapping() {
        this.availableLabels.forEach((label, index) => {
            const input = document.querySelector(`input[name="class_${index}"]`);
            if (input) {
                input.value = '';
            }
        });
        this.updateExportPreview();
        this.showToast('Sƒ±nƒ±f e≈üleme sƒ±fƒ±rlandƒ±!', 'info');
    }

    setupYoloExampleModal() {
        // YOLO √∂rnek linki - g√ºvenli element kontrol√º
        const yoloExampleLink = document.getElementById('yoloExampleLink');
        if (yoloExampleLink) {
            yoloExampleLink.addEventListener('click', (e) => {
                e.preventDefault();
                this.showYoloExampleModal();
            });
        }

        // Modal kapatma kontrolleri - g√ºvenli element kontrol√º
        const closeYoloExample = document.getElementById('closeYoloExample');
        const closeYoloExampleBtn = document.getElementById('closeYoloExampleBtn');
        
        if (closeYoloExample) {
            closeYoloExample.addEventListener('click', () => this.closeYoloExampleModal());
        }
        if (closeYoloExampleBtn) {
            closeYoloExampleBtn.addEventListener('click', () => this.closeYoloExampleModal());
        }

        // Modal dƒ±≈üƒ±na tƒ±klama
        window.addEventListener('click', (e) => {
            const yoloModal = document.getElementById('yoloExampleModal');
            if (e.target === yoloModal) this.closeYoloExampleModal();
        });
    }


    showToast(message, type = 'info', duration = 3000) {
        const container = document.getElementById('toastContainer');
        
        // Toast element olu≈ütur
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        // Container'a ekle
        container.appendChild(toast);
        
        // Animasyon i√ßin kƒ±sa gecikme
        setTimeout(() => {
            toast.classList.add('show');
        }, 100);
        
        // Belirtilen s√ºre sonra kaldƒ±r
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                if (container.contains(toast)) {
                    container.removeChild(toast);
                }
            }, 300);
        }, duration);
    }

    // Alert'leri toast ile deƒüi≈ütir
    showAlert(message, type = 'info') {
        this.showToast(message, type);
    }

    showSuccess(message) {
        this.showToast(message, 'success');
    }

    showError(message) {
        this.showToast(message, 'error');
    }

    showWarning(message) {
        this.showToast(message, 'warning');
    }

    showInfo(message) {
        this.showToast(message, 'info');
    }

    showSuccess(message) {
        this.showToast(message, 'success');
    }

    showError(message) {
        this.showToast(message, 'error');
    }

    // Etiket ismi d√ºzenleme mimarisi kaldƒ±rƒ±ldƒ±. Artƒ±k etiket d√ºzenleme yok.

    // ID ile annotation d√ºzenleme ba≈ülat
    startEditingAnnotationById(annotationId) {
        const annotation = this.annotations.find(ann => ann.id === annotationId);
        if (annotation) {
            this.startEditingAnnotation(annotation);
        }
    }

    // Mevcut annotation'larƒ± eski renklerle uyumlu hale getir
    migrateAnnotationsColors() {
        this.annotations.forEach(annotation => {
            if (!annotation.color) {
                annotation.color = '#2ecc71'; // Varsayƒ±lan ye≈üil
            }
        });
    }

    showYoloExampleModal() {
        const modal = document.getElementById('yoloExampleModal');
        modal.classList.add('show');
    }

    closeYoloExampleModal() {
        const modal = document.getElementById('yoloExampleModal');
        modal.classList.remove('show');
    }


    setupColorFilters() {
        console.log('üîß setupColorFilters √ßaƒürƒ±ldƒ±');
        console.log('üîß setupColorFilters - DOM ready state:', document.readyState);
        console.log('üîß setupColorFilters - Document body:', document.body);
        
        // Filter radio button'larƒ±
        const filterInputs = document.querySelectorAll('input[data-filter]');
        console.log('üîç Bulunan filtre inputlarƒ±:', filterInputs.length);
        
        if (filterInputs.length === 0) {
            console.error('‚ùå Hi√ß filtre inputu bulunamadƒ±!');
            console.log('üîç T√ºm input elementleri:', document.querySelectorAll('input'));
            console.log('üîç Weather filter section:', document.querySelector('.section'));
            return;
        }
        
        filterInputs.forEach((radio, index) => {
            console.log(`üìª Filtre ${index + 1}:`, radio.getAttribute('data-filter'), radio);
            radio.addEventListener('change', (e) => {
                console.log('üîÑ Filtre change event tetiklendi:', e.target.getAttribute('data-filter'));
                const filterType = e.target.getAttribute('data-filter');
                
                if (e.target.checked) {
                    console.log('üéØ Filtre se√ßildi:', filterType);
                    
                    // Radio button olduƒüu i√ßin √∂nce t√ºm filtreleri temizle
                    this.activeFilters.clear();
                    this.activeTextures.clear();
                    
                    // Sadece se√ßilen filtreyi ekle
                    this.activeFilters.add(filterType);
                    
                    // Texture efektleri de set'e ekle
                    if (this.hasTextureEffect(filterType)) {
                        this.activeTextures.add(filterType);
                        console.log('üé® Texture efekti eklendi:', filterType);
                    }
                    
                    console.log('üìã Aktif filtreler:', Array.from(this.activeFilters));
                }
                
                this.applyColorFilters();
                
                // √áoklu fotoƒüraf modunda mevcut fotoƒürafƒ±n filtrelerini kaydet
                if (this.isMultiImageMode && this.currentImageIndex >= 0) {
                    this.imageFilters[this.currentImageIndex] = {
                        activeFilters: [...this.activeFilters],
                        activeTextures: [...this.activeTextures]
                    };
                }
            });
        });

        // Reset butonu
        const resetBtn = document.getElementById('resetFilters');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                console.log('üîÑ Reset filtreleri tƒ±klandƒ±');
            this.resetAllFilters();
        });
            console.log('‚úÖ Reset butonu baƒülandƒ±');
        } else {
            console.error('‚ùå resetFilters butonu bulunamadƒ±');
        }
    }

    // Orijinal resim verisini kaydet (resim y√ºklendiƒüinde √ßaƒürƒ±lacak)
    saveOriginalImageData() {
        if (this.image && this.canvas.width > 0 && this.canvas.height > 0) {
            try {
                // Temp canvas olu≈ütur
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.image.width;
                tempCanvas.height = this.image.height;
                
                // Orijinal resmi √ßiz
                tempCtx.drawImage(this.image, 0, 0);
                
                // ImageData'yƒ± kaydet - CORS hatasƒ± olabilir
                this.originalImageData = tempCtx.getImageData(0, 0, this.image.width, this.image.height);
            } catch (error) {
                console.warn('‚ö†Ô∏è Orijinal resim verisi kaydedilemedi (CORS):', error.message);
                // CORS hatasƒ± durumunda null olarak ayarla
                this.originalImageData = null;
            }
            
            // Orijinal fotoƒüraf bilgisini de sakla (kaydetme i√ßin)
            this.originalImageInfo = {
                width: this.image.width,
                height: this.image.height,
                src: this.image.src,
                name: this.image.name || 'original_image.jpg'
            };
            
            console.log('üì∏ Orijinal fotoƒüraf bilgisi kaydedildi:', this.originalImageInfo);
            console.log('üîç OriginalImageData boyutu:', this.originalImageData ? this.originalImageData.data.length : 'null');
            
            // Filtreler varsa hemen uygula
            if (this.activeFilters.size > 0) {
                console.log('üé® Kaydedilen orijinal veri ile filtreler uygulanƒ±yor...');
                this.applyColorFilters();
            }
        }
    }

    applyColorFilters() {
        console.log('üé® applyColorFilters √ßaƒürƒ±ldƒ±');
        console.log('üîç Durum kontrol√º:', {
            hasOriginalData: !!this.originalImageData,
            hasImage: !!this.image,
            activeFilters: Array.from(this.activeFilters),
            activeFiltersSize: this.activeFilters.size
        });
        
        if (!this.originalImageData || !this.image) {
            console.warn('‚ö†Ô∏è applyColorFilters: Orijinal veri veya resim yok', {
                hasOriginalData: !!this.originalImageData,
                hasImage: !!this.image,
                activeFilters: Array.from(this.activeFilters)
            });
            return;
        }
        
        if (this.activeFilters.size === 0) {
            console.log('üîÑ Aktif filtre yok, orijinal resmi g√∂ster');
            this.resetToOriginalImage();
            return;
        }
        
        console.log('üé® Filtreler uygulanƒ±yor:', Array.from(this.activeFilters));

        // Check cache first
        const cacheKey = `filters_${this.currentImageIndex}_${Array.from(this.activeFilters).sort().join('_')}_${Array.from(this.activeTextures).sort().join('_')}`;
        if (this.filterCache.has(cacheKey)) {
            this.image = this.filterCache.get(cacheKey);
            this.redraw();
            return;
        }

        // Orijinal veriyi kopyala
        const imageData = new ImageData(
            new Uint8ClampedArray(this.originalImageData.data),
            this.originalImageData.width,
            this.originalImageData.height
        );

        // Her aktif filtreyi uygula
        this.activeFilters.forEach(filterType => {
            this.applyFilter(imageData, filterType);
        });

        // Temp canvas olu≈ütur
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = imageData.width;
        tempCanvas.height = imageData.height;
        
        // Filtrelenmi≈ü renkleri √ßiz
        tempCtx.putImageData(imageData, 0, 0);
        
        // Texture overlay'leri ekle
        if (this.activeTextures.size > 0) {
            this.applyTextureOverlays(tempCtx, tempCanvas.width, tempCanvas.height);
        }
        
        // Yeni Image objesi olu≈ütur
        const filteredImage = new Image();
        filteredImage.onload = () => {
            this.image = filteredImage;
            // Cache'e kaydet
            this.filterCache.set(cacheKey, filteredImage);
            // Cache boyutunu kontrol et (max 10 item)
            if (this.filterCache.size > 10) {
                const firstKey = this.filterCache.keys().next().value;
                this.filterCache.delete(firstKey);
            }
            this.redraw();
        };
        filteredImage.src = tempCanvas.toDataURL('image/jpeg', 0.9);
    }

    resetAllFilters() {
        // T√ºm radio button'larƒ± temizle
        document.querySelectorAll('input[data-filter]').forEach(radio => {
            radio.checked = false;
        });
        
        // Aktif filtreleri temizle
        this.activeFilters.clear();
        this.activeTextures.clear();
        
        // √áoklu fotoƒüraf modunda mevcut fotoƒürafƒ±n filtrelerini de temizle
        if (this.isMultiImageMode && this.currentImageIndex >= 0) {
            this.imageFilters[this.currentImageIndex] = {
                activeFilters: [],
                activeTextures: []
            };
        }
        
        // Orijinal resmi geri y√ºkle
        if (this.originalImageData) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = this.originalImageData.width;
            tempCanvas.height = this.originalImageData.height;
            
            tempCtx.putImageData(this.originalImageData, 0, 0);
            
            const originalImage = new Image();
            originalImage.onload = () => {
                this.image = originalImage;
                this.redraw();
            };
            originalImage.src = tempCanvas.toDataURL('image/jpeg', 0.9);
        }
    }

    // Ana filtre uygulama metodu
    applyFilter(imageData, filterType) {
        const data = imageData.data;
        
        switch(filterType) {
            case 'sunny':
                this.applySunnyFilter(data);
                break;
            case 'cloudy':
                this.applyCloudyFilter(data);
                break;
            case 'rainy':
                this.applyRainyFilter(data);
                break;
            case 'snowy':
                this.applySnowyFilter(data);
                break;
            case 'foggy':
                this.applyFoggyFilter(data);
                break;
            case 'sunset':
                this.applySunsetFilter(data);
                break;
            case 'night':
                this.applyNightFilter(data);
                break;
        }
    }

    // ‚òÄÔ∏è G√úNE≈ûLƒ∞/A√áIK HAVA Fƒ∞LTRESƒ∞
    applySunnyFilter(data) {
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Sarƒ±/altƒ±n tonlarƒ± artƒ±r
            r = Math.min(255, r * 1.15 + 15);
            g = Math.min(255, g * 1.1 + 10);
            b = Math.min(255, b * 0.95);
            
            // Genel parlaklƒ±k artƒ±rma
            const brightness = (r + g + b) / 3;
            if (brightness < 200) {
                r = Math.min(255, r + 10);
                g = Math.min(255, g + 8);
                b = Math.min(255, b + 5);
            }
            
            // Kontrast hafif artƒ±r
            r = Math.min(255, (r - 128) * 1.1 + 128);
            g = Math.min(255, (g - 128) * 1.1 + 128);
            b = Math.min(255, (b - 128) * 1.1 + 128);
            
            data[i] = Math.max(0, r);
            data[i + 1] = Math.max(0, g);
            data[i + 2] = Math.max(0, b);
        }
    }

    // ‚òÅÔ∏è BULUTLU HAVA Fƒ∞LTRESƒ∞
    applyCloudyFilter(data) {
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Hafif gri cast
            const gray = (r + g + b) / 3;
            r = r * 0.9 + gray * 0.1;
            g = g * 0.9 + gray * 0.1;
            b = b * 0.9 + gray * 0.1;
            
            // Genel karartma (az)
            r *= 0.95;
            g *= 0.95;
            b *= 0.95;
            
            // Kontrast azaltma
            r = (r - 128) * 0.9 + 128;
            g = (g - 128) * 0.9 + 128;
            b = (b - 128) * 0.9 + 128;
            
            data[i] = Math.min(255, Math.max(0, r));
            data[i + 1] = Math.min(255, Math.max(0, g));
            data[i + 2] = Math.min(255, Math.max(0, b));
        }
    }

    // üåßÔ∏è YAƒûMURLU HAVA Fƒ∞LTRESƒ∞
    applyRainyFilter(data) {
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Soƒüuk, nemli atmosfer
            r *= 0.8;
            g *= 0.85;
            b = Math.min(255, b * 1.1);
            
            // Saturation azaltma (yaƒümur renkleri s√∂n√ºkle≈ütirir)
            const avg = (r + g + b) / 3;
            r = r * 0.7 + avg * 0.3;
            g = g * 0.7 + avg * 0.3;
            b = b * 0.7 + avg * 0.3;
            
            // Genel karartma
            r *= 0.85;
            g *= 0.85;
            b *= 0.9;
            
            data[i] = Math.max(0, r);
            data[i + 1] = Math.max(0, g);
            data[i + 2] = Math.max(0, b);
        }
    }

    // ‚ùÑÔ∏è KARLI HAVA Fƒ∞LTRESƒ∞ (ger√ßek√ßi kar taneleri ile)
    // K√º√ß√ºk, yoƒüun ve tutarlƒ± kar taneleri ekleyen filtre:
    applySnowyFilter(data) {
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // √ñnce atmosferik deƒüi≈üiklikleri uygula
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];

            // Soƒüuk hava: kƒ±rmƒ±zƒ± ve ye≈üil tonlarƒ± azalt, maviye hafif vurgu
            r *= 0.88;
            g *= 0.92;
            b = Math.min(255, b * 1.08);

            // Kapalƒ± hava: genel parlaklƒ±k azaltƒ±lƒ±r
            r *= 0.93;
            g *= 0.93;
            b *= 0.95;

            // Kar yansƒ±masƒ±: beyazƒ±msƒ± etki
            const snowReflection = 0.06;
            r = r + (255 - r) * snowReflection;
            g = g + (255 - g) * snowReflection;
            b = b + (255 - b) * (snowReflection + 0.01);

            // Sis efekti: renkler griye yakla≈üƒ±r
            const avgLuminance = (r * 0.299 + g * 0.587 + b * 0.114);
            const fogFactor = 0.18;
            r = r * (1 - fogFactor) + avgLuminance * fogFactor;
            g = g * (1 - fogFactor) + avgLuminance * fogFactor;
            b = b * (1 - fogFactor) + avgLuminance * fogFactor;

            // Kontrastƒ± d√º≈ü√ºr (kapalƒ± hava i√ßin)
            const contrastReduction = 0.89;
            r = (r - 128) * contrastReduction + 128;
            g = (g - 128) * contrastReduction + 128;
            b = (b - 128) * contrastReduction + 128;

            // Parlak alanlarƒ± ve g√∂lgeleri yumu≈üat
            const brightness = (r + g + b) / 3;
            if (brightness > 135) {
                r *= 0.97;
                g *= 0.97;
                b *= 0.98;
            } else if (brightness < 80) {
                r = Math.min(255, r * 1.015 + 2);
                g = Math.min(255, g * 1.015 + 2);
                b = Math.min(255, b * 1.015 + 3);
            }

            data[i] = Math.min(255, Math.max(0, r));
            data[i + 1] = Math.min(255, Math.max(0, g));
            data[i + 2] = Math.min(255, Math.max(0, b));
        }

        // Kar tanelerini ekle (fotoƒüraf boyutundan baƒüƒ±msƒ±z, tutarlƒ± boyut)
        this.addSnowflakes(data, width, height);
    }

    // Kar taneleri ekleme fonksiyonu
    addSnowflakes(data, width, height) {
        // Kar tanesi yoƒüunluƒüu (piksel ba≈üƒ±na kar tanesi sayƒ±sƒ±)
        const snowDensity = 0.0008; // Daha yoƒüun kar
        const totalPixels = width * height;
        const numSnowflakes = Math.floor(totalPixels * snowDensity);
        
        // Kar tanesi boyutlarƒ± (fotoƒüraf boyutundan baƒüƒ±msƒ±z, sabit)
        const minSize = 1; // Minimum kar tanesi boyutu
        const maxSize = 3; // Maksimum kar tanesi boyutu
        
        for (let i = 0; i < numSnowflakes; i++) {
            // Rastgele pozisyon
            const x = Math.floor(Math.random() * width);
            const y = Math.floor(Math.random() * height);
            
            // Rastgele boyut
            const size = minSize + Math.random() * (maxSize - minSize);
            
            // Kar tanesi ≈üeffaflƒ±ƒüƒ± (daha ger√ßek√ßi)
            const opacity = 0.6 + Math.random() * 0.4; // 0.6-1.0 arasƒ±
            
            // Kar tanesini √ßiz
            this.drawSnowflake(data, width, height, x, y, size, opacity);
        }
    }

    // Tek kar tanesi √ßizme fonksiyonu
    drawSnowflake(data, width, height, centerX, centerY, size, opacity) {
        const radius = Math.ceil(size);
        
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const x = centerX + dx;
                const y = centerY + dy;
                
                // Sƒ±nƒ±rlarƒ± kontrol et
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                
                // Dairesel kar tanesi ≈üekli
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= size) {
                    const index = (y * width + x) * 4;
                    
                    // Mevcut renkleri al
                    let r = data[index];
                    let g = data[index + 1];
                    let b = data[index + 2];
                    
                    // Kar tanesi rengi (beyaz, hafif mavi tonlu)
                    const snowR = 255;
                    const snowG = 255;
                    const snowB = 255;
                    
                    // Kar tanesini mevcut renge karƒ±≈ütƒ±r
                    const blendFactor = opacity * (1 - distance / size); // Merkezden uzakla≈ütƒ±k√ßa ≈üeffafla≈üƒ±r
                    r = r * (1 - blendFactor) + snowR * blendFactor;
                    g = g * (1 - blendFactor) + snowG * blendFactor;
                    b = b * (1 - blendFactor) + snowB * blendFactor;
                    
                    data[index] = Math.min(255, Math.max(0, r));
                    data[index + 1] = Math.min(255, Math.max(0, g));
                    data[index + 2] = Math.min(255, Math.max(0, b));
                }
            }
        }
    }


// üåô GECE Fƒ∞LTRESƒ∞ (Ara√ß i√ßin optimize edilmi≈ü)
applyNightFilter(data) {
    for (let i = 0; i < data.length; i += 4) {
        let r = data[i];
        let g = data[i + 1];
        let b = data[i + 2];
        
        // Yumu≈üak karartma uygulama: Gece atmosferi olu≈ütur
        const darknessFactor = 0.45; // Daha az karartma, ara√ßlar kaybolmasƒ±n
        r *= darknessFactor;
        g *= darknessFactor;
        b *= darknessFactor;

        // Hafif mavi ton ekleme (Gece g√∂ky√ºz√º etkisi, ama √ßok belirgin olmasƒ±n)
        b = Math.min(255, b * 1.15); // Hafif mavi tonlar ekleniyor, ama √ßok fazla deƒüil

        // Gece atmosferi i√ßin min parlaklƒ±k e≈üiƒüi: ara√ßlarƒ±n g√∂r√ºn√ºrl√ºƒü√ºn√º kaybetmemek i√ßin
        const brightness = (r + g + b) / 3;
        if (brightness < 45) { // Eƒüer √ßok karanlƒ±ksa, biraz daha parlaklƒ±k ekle
            r = Math.min(255, r + 25);
            g = Math.min(255, g + 25);
            b = Math.min(255, b + 30);
        }

        // Renkleri sƒ±fƒ±rlanmasƒ±n, negatif deƒüerleri engelle
        data[i] = Math.max(0, r);
        data[i + 1] = Math.max(0, g);
        data[i + 2] = Math.max(0, b);
    }
}

    // üåÖ G√úN BATIMI Fƒ∞LTRESƒ∞
    applySunsetFilter(data) {
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Turuncu/kƒ±rmƒ±zƒ± tonlarƒ± artƒ±r
            r = r * 1.3;
            g = g * 1.1;
            b = b * 0.8;
            
            // Sƒ±cak ton ekleme
            r = r + 20;
            g = g + 10;
            
            data[i] = Math.min(255, Math.max(0, r));
            data[i + 1] = Math.min(255, Math.max(0, g));
            data[i + 2] = Math.min(255, Math.max(0, b));
        }
    }

    // ‚ùÑÔ∏è SOƒûUK HAVA Fƒ∞LTRESƒ∞
    applyColdFilter(data) {
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Mavi/beyaz tonlarƒ± artƒ±r
            r = r * 0.9;
            g = g * 0.95;
            b = b * 1.2;
            
            // Soƒüuk ton ekleme
            b = b + 15;
            
            data[i] = Math.min(255, Math.max(0, r));
            data[i + 1] = Math.min(255, Math.max(0, g));
            data[i + 2] = Math.min(255, Math.max(0, b));
        }
    }

    // ‚òÄÔ∏è SICAK/G√úNE≈ûLƒ∞ Fƒ∞LTRESƒ∞
    applyWarmFilter(data) {
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Sarƒ±/kƒ±rmƒ±zƒ± tonlarƒ± artƒ±r
            r = r * 1.2;
            g = g * 1.1;
            b = b * 0.9;
            
            // Parlaklƒ±k artƒ±rma
            r = r + 10;
            g = g + 5;
            
            data[i] = Math.min(255, Math.max(0, r));
            data[i + 1] = Math.min(255, Math.max(0, g));
            data[i + 2] = Math.min(255, Math.max(0, b));
        }
    }

    // üå´Ô∏è Sƒ∞SLƒ∞/BULANIK Fƒ∞LTRESƒ∞
    applyFoggyFilter(data) {
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Desaturation (gri tonuna √ßekme)
            const gray = (r + g + b) / 3;
            r = r * 0.4 + gray * 0.6;
            g = g * 0.4 + gray * 0.6;
            b = b * 0.4 + gray * 0.6;
            
            // Hafif beyazlatma
            r = r + 20;
            g = g + 20;
            b = b + 20;
            
            data[i] = Math.min(255, Math.max(0, r));
            data[i + 1] = Math.min(255, Math.max(0, g));
            data[i + 2] = Math.min(255, Math.max(0, b));
        }
    }

    // üé≠ Vƒ∞NTAGE Fƒ∞LTRESƒ∞
    applyVintageFilter(data) {
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Sepia tonlarƒ±
            const newR = (r * 0.393) + (g * 0.769) + (b * 0.189);
            const newG = (r * 0.349) + (g * 0.686) + (b * 0.168);
            const newB = (r * 0.272) + (g * 0.534) + (b * 0.131);
            
            data[i] = Math.min(255, Math.max(0, newR));
            data[i + 1] = Math.min(255, Math.max(0, newG));
            data[i + 2] = Math.min(255, Math.max(0, newB));
        }
    }

    // üåà CANLI RENKLER Fƒ∞LTRESƒ∞
    applyVibrantFilter(data) {
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // Saturation artƒ±rma
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;
            
            if (diff > 0) {
                const saturation = 1.5; // %50 saturation artƒ±≈üƒ±
                r = min + (r - min) * saturation;
                g = min + (g - min) * saturation;
                b = min + (b - min) * saturation;
            }
            
            data[i] = Math.min(255, Math.max(0, r));
            data[i + 1] = Math.min(255, Math.max(0, g));
            data[i + 2] = Math.min(255, Math.max(0, b));
        }
    }

    // TEXTURE OVERLAY Sƒ∞STEMƒ∞
    
    // Hangi filtrelerin texture efekti olduƒüunu belirle
    hasTextureEffect(filterType) {
        return ['night', 'snowy', 'foggy', 'rainy'].includes(filterType);
    }

    // Belirli bir fotoƒürafƒ±n filtrelerini y√ºkle
    loadImageFilters(imageIndex) {
        if (this.imageFilters[imageIndex]) {
            // Filtreleri y√ºkle
            this.activeFilters.clear();
            this.activeFilters = new Set(this.imageFilters[imageIndex].activeFilters);
            
            // Texture'larƒ± y√ºkle
            this.activeTextures.clear();
            this.activeTextures = new Set(this.imageFilters[imageIndex].activeTextures);
            
            // Filtreleri uygula
            this.applyColorFilters();
        } else {
            // Yeni fotoƒüraf i√ßin filtreleri temizle
            this.activeFilters.clear();
            this.activeTextures.clear();
            
            // Orijinal resmi g√∂ster
            this.resetToOriginalImage();
        }
    }

    // Orijinal resmi geri y√ºkle (filtre olmadan)
    resetToOriginalImage() {
        if (this.originalImageData) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = this.originalImageData.width;
            tempCanvas.height = this.originalImageData.height;
            
            tempCtx.putImageData(this.originalImageData, 0, 0);
            
            const originalImage = new Image();
            originalImage.onload = () => {
                this.image = originalImage;
                this.redraw();
            };
            originalImage.src = tempCanvas.toDataURL('image/jpeg', 0.9);
        }
    }

    // Filtre UI'ƒ±nƒ± g√ºncelle (mevcut fotoƒürafƒ±n filtrelerine g√∂re)
    updateFilterUI() {
        if (this.isMultiImageMode && this.currentImageIndex >= 0 && this.imageFilters[this.currentImageIndex]) {
            const currentFilters = this.imageFilters[this.currentImageIndex];
            
            // T√ºm radio button'larƒ± temizle
            document.querySelectorAll('input[data-filter]').forEach(radio => {
                radio.checked = false;
            });
            
            // Mevcut filtreleri i≈üaretle
            currentFilters.activeFilters.forEach(filterType => {
                const radio = document.querySelector(`input[data-filter="${filterType}"]`);
                if (radio) {
                    radio.checked = true;
                }
            });
        } else {
            // Tek fotoƒüraf modunda veya filtre yoksa t√ºm radio button'larƒ± temizle
            document.querySelectorAll('input[data-filter]').forEach(radio => {
                radio.checked = false;
            });
        }
    }

    // Ana texture overlay metodu
    applyTextureOverlays(ctx, width, height) {
        this.activeTextures.forEach(textureType => {
            switch(textureType) {
                case 'night':
                    this.addStarTexture(ctx, width, height);
                    break;
                case 'snowy':
                    this.addSnowTexture(ctx, width, height);
                    break;
                case 'foggy':
                    this.addFogTexture(ctx, width, height);
                    break;
                case 'rainy':
                    this.addRainTexture(ctx, width, height);
                    break;
            }
        });
    }

    // üåô GECE ATMOSFERƒ∞ (sadece renk, yƒ±ldƒ±z yok)
    addStarTexture(ctx, width, height) {
        ctx.save();
        
        // Sadece hafif gece atmosferi (yƒ±ldƒ±z yok) - daha d√º≈ü√ºk opaklƒ±k
        const nightAtmosphere = ctx.createLinearGradient(0, 0, 0, height);
        nightAtmosphere.addColorStop(0, 'rgba(20, 20, 30, 0.02)'); // √úst kƒ±sƒ±m √ßok hafif
        nightAtmosphere.addColorStop(0.5, 'rgba(15, 15, 25, 0.015)'); // Orta kƒ±sƒ±m
        nightAtmosphere.addColorStop(1, 'rgba(10, 10, 20, 0.03)'); // Alt kƒ±sƒ±m
        ctx.fillStyle = nightAtmosphere;
        ctx.fillRect(0, 0, width, height);
        
        ctx.restore();
    }

    // ‚ùÑÔ∏è KAR TEXTURE
    addSnowTexture(ctx, width, height) {
        ctx.save();
        
        // 1. YOƒûUN KAR TANELERƒ∞ (arka plan) - Ger√ßek√ßi boyut ve yoƒüunluk
        const denseSnowCount = Math.floor((width * height) / 3000); // Daha az yoƒüun
        for (let i = 0; i < denseSnowCount; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const baseSize = Math.random() * 1.2 + 0.5; // Daha k√º√ß√ºk ve ger√ßek√ßi
            const opacity = Math.random() * 0.4 + 0.2; // Daha hafif
            
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.beginPath();
            
            // D√ºzensiz kar tanesi - k√º√ß√ºk taneler i√ßin basit organik ≈üekil
            const points = 6 + Math.floor(Math.random() * 4); // 6-9 nokta
            ctx.moveTo(x + baseSize, y);
            
            for (let j = 1; j <= points; j++) {
                const angle = (j * 2 * Math.PI) / points;
                const radiusVariation = 0.7 + Math.random() * 0.6; // %70-130 boyut varyasyonu
                const radius = baseSize * radiusVariation;
                const pointX = x + Math.cos(angle) * radius;
                const pointY = y + Math.sin(angle) * radius;
                ctx.lineTo(pointX, pointY);
            }
            ctx.closePath();
            ctx.fill();
        }
        
        // 2. ORTA BOYUT KAR TANELERƒ∞ - Ger√ßek√ßi boyut
        const mediumSnowCount = Math.floor((width * height) / 8000); // Daha az yoƒüun
        for (let i = 0; i < mediumSnowCount; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const baseSize = Math.random() * 2.5 + 1.5; // Daha k√º√ß√ºk
            const opacity = Math.random() * 0.6 + 0.3; // Daha hafif
            
            // Ana organik kar tanesi
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.beginPath();
            
            // Daha karma≈üƒ±k organik ≈üekil
            const points = 8 + Math.floor(Math.random() * 6); // 8-13 nokta
            const angleStep = (2 * Math.PI) / points;
            
            for (let j = 0; j < points; j++) {
                const angle = j * angleStep + (Math.random() - 0.5) * 0.3; // A√ßƒ± varyasyonu
                const radiusVariation = 0.5 + Math.random() * 0.8; // %50-130 boyut varyasyonu
                const radius = baseSize * radiusVariation;
                
                // Bezier eƒürilerle yumu≈üak ge√ßi≈üler
                const pointX = x + Math.cos(angle) * radius;
                const pointY = y + Math.sin(angle) * radius;
                
                if (j === 0) {
                    ctx.moveTo(pointX, pointY);
                } else {
                    // √ñnceki noktadan smooth ge√ßi≈ü
                    const prevAngle = (j-1) * angleStep + (Math.random() - 0.5) * 0.3;
                    const prevRadius = baseSize * (0.5 + Math.random() * 0.8);
                    const controlX = x + Math.cos(prevAngle + angleStep/2) * (prevRadius + radius) * 0.3;
                    const controlY = y + Math.sin(prevAngle + angleStep/2) * (prevRadius + radius) * 0.3;
                    
                    ctx.quadraticCurveTo(controlX, controlY, pointX, pointY);
                }
            }
            ctx.closePath();
            ctx.fill();
            
            // Hafif blur efekti - organik halo
            ctx.fillStyle = `rgba(245, 250, 255, ${opacity * 0.2})`;
            ctx.beginPath();
            
            for (let j = 0; j < points; j++) {
                const angle = j * angleStep;
                const haloRadius = baseSize * 1.8 * (0.8 + Math.random() * 0.4);
                const haloX = x + Math.cos(angle) * haloRadius;
                const haloY = y + Math.sin(angle) * haloRadius;
                
                if (j === 0) {
                    ctx.moveTo(haloX, haloY);
                } else {
                    ctx.lineTo(haloX, haloY);
                }
            }
            ctx.closePath();
            ctx.fill();
        }
        
        // 3. B√úY√úK KAR TANELERƒ∞ (√∂n plan) - Ger√ßek√ßi boyut
        const largeSnowCount = Math.floor((width * height) / 20000); // Daha az yoƒüun
        for (let i = 0; i < largeSnowCount; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const baseSize = Math.random() * 3.5 + 2.5; // Daha k√º√ß√ºk
            const opacity = Math.random() * 0.7 + 0.4; // Daha hafif
            
            // Ana b√ºy√ºk organik kar tanesi
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.beginPath();
            
            // √áok d√ºzensiz, doƒüal kar tanesi ≈üekli
            const mainPoints = 10 + Math.floor(Math.random() * 8); // 10-17 nokta
            const angleStep = (2 * Math.PI) / mainPoints;
            
            // ƒ∞lk nokta
            let firstX, firstY;
            
            for (let j = 0; j < mainPoints; j++) {
                const baseAngle = j * angleStep;
                const angleNoise = (Math.random() - 0.5) * 0.6; // B√ºy√ºk a√ßƒ± varyasyonu
                const angle = baseAngle + angleNoise;
                
                // √áok deƒüi≈üken radius - doƒüal d√ºzensizlik
                const radiusBase = 0.3 + Math.random() * 1.2; // %30-150 varyasyon
                const radiusNoise = (Math.random() - 0.5) * 0.4;
                const radius = baseSize * (radiusBase + radiusNoise);
                
                const pointX = x + Math.cos(angle) * radius;
                const pointY = y + Math.sin(angle) * radius;
                
                if (j === 0) {
                    ctx.moveTo(pointX, pointY);
                    firstX = pointX;
                    firstY = pointY;
                } else {
                    // Organik eƒüriler - kontrols√ºz Bezier
                    const prevAngle = ((j-1) * angleStep) + (Math.random() - 0.5) * 0.6;
                    const controlDistance = baseSize * (0.2 + Math.random() * 0.6);
                    const controlAngle = (baseAngle + prevAngle) / 2 + (Math.random() - 0.5) * 1.0;
                    
                    const controlX = x + Math.cos(controlAngle) * controlDistance;
                    const controlY = y + Math.sin(controlAngle) * controlDistance;
                    
                    ctx.quadraticCurveTo(controlX, controlY, pointX, pointY);
                }
            }
            
            // ≈ûekli kapatmak i√ßin son noktayƒ± ilk noktaya baƒüla
            const finalControlAngle = Math.random() * 2 * Math.PI;
            const finalControlDistance = baseSize * (0.2 + Math.random() * 0.4);
            const finalControlX = x + Math.cos(finalControlAngle) * finalControlDistance;
            const finalControlY = y + Math.sin(finalControlAngle) * finalControlDistance;
            
            ctx.quadraticCurveTo(finalControlX, finalControlY, firstX, firstY);
            ctx.closePath();
            ctx.fill();
            
            // Detaylƒ± kar kristali - ger√ßek√ßi 6 noktalƒ± yapƒ±
            if (Math.random() < 0.5) {
                ctx.strokeStyle = `rgba(230, 240, 255, ${opacity * 0.8})`;
                ctx.lineWidth = 0.6;
                ctx.beginPath();
                
                // 6 ana kol
                for (let angle = 0; angle < 6; angle++) {
                    const rad = (angle * 60) * Math.PI / 180;
                    const mainLength = baseSize * 0.9;
                    
                    // Ana √ßizgi
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(rad) * mainLength, y + Math.sin(rad) * mainLength);
                    
                    // Her ana kol i√ßin yan dallar
                    for (let branch = 0.3; branch <= 0.7; branch += 0.4) {
                        const branchX = x + Math.cos(rad) * mainLength * branch;
                        const branchY = y + Math.sin(rad) * mainLength * branch;
                        const branchLength = baseSize * 0.3;
                        
                        // Sol dal
                        const leftAngle = rad + Math.PI / 4;
                        ctx.moveTo(branchX, branchY);
                        ctx.lineTo(branchX + Math.cos(leftAngle) * branchLength, 
                                  branchY + Math.sin(leftAngle) * branchLength);
                        
                        // Saƒü dal
                        const rightAngle = rad - Math.PI / 4;
                        ctx.moveTo(branchX, branchY);
                        ctx.lineTo(branchX + Math.cos(rightAngle) * branchLength, 
                                  branchY + Math.sin(rightAngle) * branchLength);
                    }
                }
                ctx.stroke();
            }
            
            // Organik soft glow efekti
            const glowSize = baseSize * (2.0 + Math.random() * 1.0); // Deƒüi≈üken glow boyutu
            const glowOpacity = opacity * (0.08 + Math.random() * 0.05);
            
            // D√ºzensiz glow gradient
            const glowOffsetX = (Math.random() - 0.5) * baseSize * 0.4;
            const glowOffsetY = (Math.random() - 0.5) * baseSize * 0.4;
            const glowGradient = ctx.createRadialGradient(
                x + glowOffsetX, y + glowOffsetY, 0,
                x, y, glowSize
            );
            glowGradient.addColorStop(0, `rgba(255, 255, 255, ${glowOpacity})`);
            glowGradient.addColorStop(0.7, `rgba(245, 250, 255, ${glowOpacity * 0.6})`);
            glowGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(x, y, glowSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // 4. √áOK B√úY√úK BULANIK TANELER (kameraya √ßok yakƒ±n, odak dƒ±≈üƒ± efekti)
        const blurrySnowCount = Math.floor((width * height) / 60000); // Daha az yoƒüun
        for (let i = 0; i < blurrySnowCount; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const baseSize = Math.random() * 8 + 4; // Daha k√º√ß√ºk
            const opacity = Math.random() * 0.15 + 0.03; // Daha hafif
            
            // Organik bulanƒ±k kar tanesi - d√ºzensiz gradient
            const offsetX = (Math.random() - 0.5) * baseSize * 0.3; // Merkez kaymasƒ±
            const offsetY = (Math.random() - 0.5) * baseSize * 0.3;
            const gradientCenterX = x + offsetX;
            const gradientCenterY = y + offsetY;
            
            // D√ºzensiz boyutlar
            const radiusX = baseSize * (0.8 + Math.random() * 0.4); // X ekseni
            const radiusY = baseSize * (0.8 + Math.random() * 0.4); // Y ekseni
            const maxRadius = Math.max(radiusX, radiusY);
            
            const gradient = ctx.createRadialGradient(
                gradientCenterX, gradientCenterY, 0, 
                gradientCenterX, gradientCenterY, maxRadius
            );
            gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
            gradient.addColorStop(0.3, `rgba(255, 255, 255, ${opacity * 0.8})`);
            gradient.addColorStop(0.6, `rgba(250, 252, 255, ${opacity * 0.5})`);
            gradient.addColorStop(0.9, `rgba(248, 250, 255, ${opacity * 0.2})`);
            gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
            
            ctx.fillStyle = gradient;
            
            // Organik elips ≈üekli
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.random() * Math.PI * 2); // Rastgele rotasyon
            ctx.scale(radiusX / maxRadius, radiusY / maxRadius); // Oval ≈üekil
            ctx.beginPath();
            ctx.arc(0, 0, maxRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // 5. ATMOSFERIK KAR EFEKTƒ∞ (genel kar yoƒüunluƒüu) - Daha hafif
        if (Math.random() < 0.6) { // %60 ≈üans
            const atmosphereOpacity = Math.random() * 0.03 + 0.01; // Daha hafif
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, `rgba(250, 252, 255, ${atmosphereOpacity * 0.5})`);
            gradient.addColorStop(0.5, `rgba(248, 250, 255, ${atmosphereOpacity})`);
            gradient.addColorStop(1, `rgba(245, 248, 255, ${atmosphereOpacity * 0.7})`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }
        
        // 6. RASTGELE KAR R√úZGARI EFEKTƒ∞ - Daha hafif
        if (Math.random() < 0.2) { // %20 ≈üans
            const windSnowCount = Math.floor((width * height) / 25000); // Daha az yoƒüun
            for (let i = 0; i < windSnowCount; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const length = Math.random() * 6 + 3; // Daha kƒ±sa
                const angle = Math.random() * 0.3 + 0.1; // Hafif eƒüik r√ºzgar
                const opacity = Math.random() * 0.3 + 0.1; // Daha hafif
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.lineWidth = Math.random() * 1.0 + 0.5; // Daha ince
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                ctx.stroke();
            }
        }
        
        // 7. BASƒ∞T KAR TANELERƒ∞ - Ger√ßek√ßi boyut ve yoƒüunluk
        const testSnowCount = Math.floor((width * height) / 12000); // Daha az yoƒüun
        for (let i = 0; i < testSnowCount; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const size = Math.random() * 1.5 + 0.8; // Daha k√º√ß√ºk
            const opacity = Math.random() * 0.5 + 0.3; // Daha hafif
            
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }

    // üå´Ô∏è Sƒ∞S TEXTURE
    addFogTexture(ctx, width, height) {
        ctx.save();
        
        // √áoklu sis katmanlarƒ±
        for (let layer = 0; layer < 3; layer++) {
            const opacity = 0.1 + layer * 0.05;
            const yOffset = height * (0.3 + layer * 0.2);
            
            // Gradient sis bulutlarƒ±
            for (let i = 0; i < 5; i++) {
                const centerX = (width / 6) * (i + 1) + (Math.random() - 0.5) * 100;
                const centerY = yOffset + (Math.random() - 0.5) * 50;
                const radius = width * 0.2 + Math.random() * 100;
                
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, radius
                );
                gradient.addColorStop(0, `rgba(220, 220, 220, ${opacity})`);
                gradient.addColorStop(0.5, `rgba(200, 200, 200, ${opacity * 0.5})`);
                gradient.addColorStop(1, 'rgba(200, 200, 200, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.restore();
    }

    // üåßÔ∏è YAƒûMUR TEXTURE
    addRainTexture(ctx, width, height) {
        const rainDrops = Math.floor((width * height) / 8000);
        
        ctx.save();
        
        for (let i = 0; i < rainDrops; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const length = Math.random() * 20 + 10;
            const opacity = Math.random() * 0.6 + 0.2;
            const thickness = Math.random() * 1.5 + 0.5;
            
            // Yaƒümur damlasƒ± √ßizgisi
            ctx.strokeStyle = `rgba(180, 200, 220, ${opacity})`;
            ctx.lineWidth = thickness;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 3, y + length); // Hafif eƒüik
            ctx.stroke();
        }
        
        ctx.restore();
    }





    // Basit etiket atama sistemi
    assignLabelToCurrentAnnotation(label = null, color = null) {
        console.log('üîç assignLabelToCurrentAnnotation √ßaƒürƒ±ldƒ±:', { 
            quickLabelMode: this.quickLabelMode, 
            activeLabel: this.activeLabel,
            currentAnnotation: this.currentAnnotation 
        });
        
        if (!this.currentAnnotation) {
            console.log('‚ùå currentAnnotation yok!');
            return;
        }

        if (this.quickLabelMode) {
            // Hƒ±zlƒ± etiket modu: √ñnceki etiketin ismini direkt al
            if (this.activeLabel) {
                // √ñnceki etiketin ismini kullan
                this.currentAnnotation.label = this.activeLabel;
                // Otomatik farklƒ± renk ata
                this.currentAnnotation.color = this.getNextAutoColor();
                // createNewAnnotation zaten annotations listesine ekliyor
                this.currentAnnotation = null;
                this.updateAnnotationList();
                this.redraw();
                
                // Yeni annotation'ƒ± se√ßili ve focuslanmƒ±≈ü yap
                this.selectedAnnotation = this.annotations[this.annotations.length - 1];
                this.focusedAnnotation = this.annotations[this.annotations.length - 1];
                this.showSuccess(`"${this.activeLabel}" etiketi eklendi!`);
            } else {
                // Aktif etiket yoksa modal g√∂ster
                this.showNewLabelModal();
            }
        } else {
            // Normal mod: Her seferinde etiket se√ß - modal g√∂ster
            this.showNewLabelModal();
        }
    }

    // Modal'dan gelen etiket atamasƒ±
    assignLabelFromModal(label, color) {
        if (!this.currentAnnotation) {
            console.log('‚ùå currentAnnotation yok!');
            return;
        }

        console.log('‚úÖ assignLabelFromModal √ßaƒürƒ±ldƒ±:', { 
            label, 
            color, 
            currentAnnotationBefore: { ...this.currentAnnotation } 
        });

        // Etiketi ata
        console.log('üîç Etiket atanmadan √∂nce:', { 
            currentAnnotationLabel: this.currentAnnotation.label,
            newLabel: label,
            newColor: color 
        });
        
        this.currentAnnotation.label = label;
        this.currentAnnotation.color = color;
        
        console.log('‚úÖ Etiket atandƒ± - currentAnnotation.label:', this.currentAnnotation.label);
        console.log('‚úÖ Etiket atandƒ± - currentAnnotation.color:', this.currentAnnotation.color);
        
        // Etiket pozisyonunu sabit tutmak i√ßin labelPosition ekle
        if (!this.currentAnnotation.labelPosition) {
            // Sol √ºst k√∂≈üe pozisyonunu hesapla
            let leftTopPoint;
            if (this.currentAnnotation.points && this.currentAnnotation.points.length > 0) {
                const xs = this.currentAnnotation.points.map(p => p.x);
                const ys = this.currentAnnotation.points.map(p => p.y);
                const minX = Math.min(...xs);
                const minY = Math.min(...ys);
                leftTopPoint = { x: minX, y: minY - 20 }; // 20px yukarƒ±
            } else {
                leftTopPoint = { x: this.currentAnnotation.x, y: this.currentAnnotation.y - 20 }; // 20px yukarƒ±
            }
            this.currentAnnotation.labelPosition = leftTopPoint;
        }
        
        console.log('‚úÖ Etiket atandƒ±:', this.currentAnnotation);
        
        // Etiket listesine ekle
        if (!this.availableLabels.includes(label)) {
            this.availableLabels.push(label);
        }
        
        // Annotation'ƒ± tamamla - direkt listeye ekle
        this.annotations.push(this.currentAnnotation);
        console.log('‚úÖ Yeni annotation olu≈üturuldu:', this.currentAnnotation);
        
        this.currentAnnotation = null;
        this.updateAnnotationList();
        this.updateLabelListFromAnnotations();
        this.redraw();
        
        // Yeni annotation'ƒ± se√ßili yap
        this.selectedAnnotation = this.annotations[this.annotations.length - 1];
        
        // Projeyi kaydet
        this.isSaved = false; // Yeni annotation eklendi, kaydedilmemi≈ü
        this.saveProject();
        
        // Database'e de kaydet (WebSocket bildirimi i√ßin)
        console.log('üîµ Etiket modal\'dan eklendi, database\'e kaydediliyor...', this.currentAnnotation);
        this.saveAllAnnotationsToDatabase();
        
        this.showSuccess(`"${label}" etiketi eklendi!`);
    }

    // Basit etiket se√ßimi - modal olmadan
    showSimpleLabelSelection() {
        if (this.availableLabels.length === 0) {
            // Hi√ß etiket yok, hƒ±zlƒ± etiket ekleme
            const labelName = prompt('Etiket adƒ± girin:', 'yeni_etiket');
            if (labelName && labelName.trim()) {
                this.addNewLabel(labelName.trim());
                this.currentAnnotation.label = labelName.trim();
                this.currentAnnotation.color = this.getNextAutoColor();
                this.annotations.push(this.currentAnnotation);
                this.currentAnnotation = null;
                this.updateAnnotationList();
                this.redraw();
                
                // Database'e kaydet (WebSocket bildirimi i√ßin)
                console.log('üîµ Hƒ±zlƒ± etiket eklendi, database\'e kaydediliyor...', labelName.trim());
                this.saveAllAnnotationsToDatabase();
                
                this.showSuccess(`"${labelName}" etiketi eklendi!`);
            } else {
                this.currentAnnotation = null;
                this.redraw();
            }
        } else {
            // Mevcut etiketlerden se√ßim yap
            const labelOptions = this.availableLabels.map((label, index) => 
                `${index + 1}. ${label}`
            ).join('\n');
            
            const choice = prompt(`Etiket se√ßin:\n\n${labelOptions}\n\n0. Yeni etiket ekle\n\nNumara girin:`);
            const choiceNum = parseInt(choice);
            
            if (choiceNum > 0 && choiceNum <= this.availableLabels.length) {
                // Mevcut etiket se√ßildi
                const selectedLabel = this.availableLabels[choiceNum - 1];
                this.currentAnnotation.label = selectedLabel;
                this.currentAnnotation.color = this.getNextAutoColor();
                this.annotations.push(this.currentAnnotation);
                this.currentAnnotation = null;
                this.updateAnnotationList();
                this.redraw();
                
                // Database'e kaydet (WebSocket bildirimi i√ßin)
                console.log('üîµ Etiket basit se√ßimden eklendi, database\'e kaydediliyor...', selectedLabel);
                this.saveAllAnnotationsToDatabase();
                
                this.showSuccess(`"${selectedLabel}" etiketi eklendi!`);
            } else if (choiceNum === 0) {
                // Yeni etiket ekle
                const labelName = prompt('Yeni etiket adƒ± girin:', 'yeni_etiket');
                if (labelName && labelName.trim()) {
                    this.addNewLabel(labelName.trim());
                    this.currentAnnotation.label = labelName.trim();
                    this.currentAnnotation.color = this.getNextAutoColor();
                    this.annotations.push(this.currentAnnotation);
                    this.currentAnnotation = null;
                    this.updateAnnotationList();
                    this.redraw();
                    
                    // Database'e kaydet (WebSocket bildirimi i√ßin)
                    console.log('üîµ Yeni etiket basit se√ßimden eklendi, database\'e kaydediliyor...', labelName.trim());
                    this.saveAllAnnotationsToDatabase();
                    
                    this.showSuccess(`"${labelName}" etiketi eklendi!`);
                } else {
                    this.currentAnnotation = null;
                    this.redraw();
                }
            } else {
                // Ge√ßersiz se√ßim
                this.currentAnnotation = null;
                this.redraw();
            }
        }
    }

    setActiveLabel(label) {
        const transformedLabel = this.transformLabelName(label);
        this.activeLabel = transformedLabel;
        this.updateLabelList();
        this.showSuccess(`Aktif etiket: "${transformedLabel}"`);
        
        // Eƒüer mevcut bir annotation varsa ve etiket atanmamƒ±≈üsa, otomatik ata
        if (this.currentAnnotation && !this.currentAnnotation.label) {
            this.currentAnnotation.label = transformedLabel;
            // Se√ßili rengi kullan, yoksa otomatik renk
            this.currentAnnotation.color = this.selectedColor || this.getNextAutoColor();
            this.updateAnnotationList();
            this.redraw();
            console.log(`Etiket otomatik atandƒ±: ${label}`);
            
            // Etiket atandƒ±, annotation'ƒ± se√ßili yap
            this.selectedAnnotation = this.currentAnnotation;
            
            // Database'e kaydet (WebSocket bildirimi i√ßin)
            console.log('üîµ Etiket aktif etiket olarak atandƒ±, database\'e kaydediliyor...', transformedLabel);
            this.saveAllAnnotationsToDatabase();
        }
    }

    // Basit etiket ekleme fonksiyonu
    addNewLabel(labelName) {
        if (!labelName || labelName.trim() === '') return false;
        
        const cleanLabel = labelName.trim();
        
        // Aynƒ± etiket var mƒ± kontrol et
        if (this.availableLabels.includes(cleanLabel)) {
            this.showWarning(`"${cleanLabel}" etiketi zaten mevcut!`);
            return false;
        }
        
        // Etiketi ekle
        this.availableLabels.push(cleanLabel);
        this.updateLabelList();
        
        // Yeni eklenen etiketi aktif yap
        this.setActiveLabel(cleanLabel);
        
        return true;
    }

    updateQuickModeUI() {
        const toggle = document.getElementById('quickLabelModeToggle');
        const labelText = toggle.parentElement.querySelector('span');
        
    }


    updateLabelList() {
        const container = document.getElementById('labelList');
        container.innerHTML = '';

        if (this.availableLabels.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'empty-state';
            emptyMessage.innerHTML = `
                <div class="empty-state-content">
                    <i class="fas fa-tags" style="font-size: 32px; color: #7f8c8d; margin-bottom: 12px;"></i>
                    <h4 style="color: #95a5a6; margin: 0 0 6px 0;">Etiket Bulunamadƒ±</h4>
                    <p style="color: #7f8c8d; margin: 0; font-size: 12px;">Hen√ºz hi√ß etiket olu≈üturulmamƒ±≈ü. ƒ∞lk etiketinizi olu≈üturun.</p>
                </div>
            `;
            container.appendChild(emptyMessage);
            return;
        }

        this.availableLabels.forEach((label, index) => {
            const labelItem = document.createElement('div');
            labelItem.className = 'label-item';
            
            // Aktif etiket kontrol√º
            if (this.activeLabel === label) {
                labelItem.classList.add('active');
            }

            // Etiket rengini al (varsayƒ±lan renkler)
            const colors = ['#2ecc71', '#e74c3c', '#3498db', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
            const color = colors[index % colors.length];

            labelItem.innerHTML = `
                <div class="label-info">
                    <div class="label-color-indicator" style="background-color: ${color}"></div>
                    <div class="label-name">${label}</div>
                </div>
                <div class="label-actions">
                    <button class="label-delete-btn" title="Etiketi sil">√ó</button>
                </div>
            `;

            // Tƒ±klama olayƒ±
            labelItem.addEventListener('click', (e) => {
                if (!e.target.classList.contains('label-delete-btn')) {
                    this.setActiveLabel(label);
                }
            });

            // Silme butonu
            const deleteBtn = labelItem.querySelector('.label-delete-btn');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteLabel(label);
            });

            container.appendChild(labelItem);
        });
    }

    // Available labels'ƒ± g√ºncelle (updateLabelList ile aynƒ± i≈ülevi g√∂r√ºr)
    updateAvailableLabels() {
        this.updateLabelList();
    }

    // Belirli bir index'teki resmi y√ºkle
    loadImageFromIndex(index) {
        if (this.croppedImages && index >= 0 && index < this.croppedImages.length) {
            const imageData = this.croppedImages[index];
            if (imageData && imageData.image) {
                this.image = imageData.image;
                this.currentImageIndex = index;
                this.redraw();
                console.log(`‚úÖ Resim y√ºklendi: ${index + 1}/${this.croppedImages.length}`);
            }
        }
    }

    // Annotation silindikten sonra etiket listesini g√ºncelle
    updateLabelListAfterDeletion(deletedLabel) {
        if (!deletedLabel) return;
        
        // Silinen etiketin ba≈üka annotation'larda kullanƒ±lƒ±p kullanƒ±lmadƒ±ƒüƒ±nƒ± kontrol et
        const isLabelStillUsed = this.annotations.some(ann => ann.label === deletedLabel);
        
        // Eƒüer etiket artƒ±k kullanƒ±lmƒ±yorsa, etiket listesinden de sil
        if (!isLabelStillUsed) {
            this.availableLabels = this.availableLabels.filter(label => label !== deletedLabel);
            
            // Eƒüer silinen etiket aktif etiketse, aktif etiketi temizle
            if (this.activeLabel === deletedLabel) {
                this.activeLabel = this.availableLabels.length > 0 ? this.availableLabels[0] : null;
            }
            
            // Etiket listesini g√ºncelle
            this.updateLabelList();
            
            this.showSuccess(`"${deletedLabel}" etiketi artƒ±k kullanƒ±lmadƒ±ƒüƒ± i√ßin listeden silindi.`);
        }
    }

    // Etiket kilitleme fonksiyonlarƒ±
    isLabelLocked(label) {
        // Bu etiketin t√ºm annotation'larƒ±nƒ±n kilitli olup olmadƒ±ƒüƒ±nƒ± kontrol et
        const labelAnnotations = this.annotations.filter(ann => ann.label === label);
        if (labelAnnotations.length === 0) return false;
        
        // Eƒüer annotation'larda locked √∂zelliƒüi yoksa, false d√∂nd√ºr
        return labelAnnotations.every(ann => ann.locked === true);
    }

    toggleLabelLock(label) {
        // Bu etiketin t√ºm annotation'larƒ±nƒ± bul
        const labelAnnotations = this.annotations.filter(ann => ann.label === label);
        
        if (labelAnnotations.length === 0) {
            this.showWarning(`"${label}" etiketi i√ßin annotation bulunamadƒ±.`);
            return;
        }
        
        // T√ºm annotation'larƒ±n kilit durumunu kontrol et
        const allLocked = labelAnnotations.every(ann => ann.locked === true);
        const newLockState = !allLocked;
        
        // T√ºm annotation'larƒ± aynƒ± kilit durumuna getir
        labelAnnotations.forEach(ann => {
            ann.locked = newLockState;
        });
        
        // Etiket listesini g√ºncelle
        this.updateLabelList();
        
        // Canvas'ƒ± yeniden √ßiz
        this.redraw();
        
        // Toast mesajƒ±
        const message = newLockState ? `"${label}" etiketi kilitlendi` : `"${label}" etiketi kilidi a√ßƒ±ldƒ±`;
        this.showInfo(message);
    }

    updateLabelListFromAnnotations() {
        // Mevcut annotation'lardan kullanƒ±lan etiketleri topla
        const usedLabels = new Set();
        this.annotations.forEach(annotation => {
            if (annotation.label && annotation.label.trim() !== '') {
                usedLabels.add(annotation.label);
            }
        });
        
        // Kullanƒ±lmayan etiketleri temizle
        const oldAvailableLabels = [...this.availableLabels];
        this.availableLabels = this.availableLabels.filter(label => usedLabels.has(label));
        
        // Eƒüer aktif etiket artƒ±k kullanƒ±lmƒ±yorsa, temizle
        if (this.activeLabel && !usedLabels.has(this.activeLabel)) {
            this.activeLabel = this.availableLabels.length > 0 ? this.availableLabels[0] : null;
        }
        
        // Etiket listesini g√ºncelle
        this.updateLabelList();
        
        // Sidebar'daki etiket listesini g√ºncelle
        this.updateSidebarLabelList();
        
        // Eƒüer etiketler silindiyse kullanƒ±cƒ±ya bildir
        const removedLabels = oldAvailableLabels.filter(label => !usedLabels.has(label));
        if (removedLabels.length > 0) {
            console.log('Kullanƒ±lmayan etiketler temizlendi:', removedLabels);
        }
    }

    updateSidebarLabelList() {
        const labelListContainer = document.getElementById('labelList');
        if (!labelListContainer) return;

        // Mevcut listeyi temizle
        labelListContainer.innerHTML = '';

        if (this.availableLabels.length === 0) {
            // Etiket yoksa bo≈ü mesaj g√∂ster
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'empty-message';
            emptyMessage.textContent = 'Etiket Bulunamadƒ±';
            labelListContainer.appendChild(emptyMessage);
            return;
        }

        // Her etiket i√ßin liste √∂ƒüesi olu≈ütur
        this.availableLabels.forEach(label => {
            const labelItem = document.createElement('div');
            labelItem.className = 'label-item';
            labelItem.innerHTML = `
                <span class="label-name">${label}</span>
                <button class="delete-btn" onclick="event.stopPropagation(); labelingTool.deleteLabel('${label}')" title="Etiketi Sil">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3,6 5,6 21,6"></polyline>
                        <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
                    </svg>
                </button>
            `;

            // Etiket se√ßimi i√ßin tƒ±klama olayƒ±
            labelItem.addEventListener('click', () => {
                this.selectLabelFromSidebar(label);
            });

            // Aktif etiket vurgulama
            if (label === this.activeLabel) {
                labelItem.classList.add('active');
            }

            labelListContainer.appendChild(labelItem);
        });
    }

    selectLabelFromSidebar(label) {
        // Sidebar'dan etiket se√ßimi
        this.activeLabel = label;
        this.updateSidebarLabelList(); // Aktif etiket vurgulamasƒ± i√ßin
        this.updateLabelList(); // Ana etiket listesini g√ºncelle
        
        console.log('‚úÖ Sidebar\'dan etiket se√ßildi:', label);
        this.showToast(`"${label}" etiketi se√ßildi`, 'success');
    }

    showAvailableLabelsInModal() {
        const availableLabelsContainer = document.getElementById('availableLabelsContainer');
        if (!availableLabelsContainer) return;

        // Mevcut listeyi temizle
        availableLabelsContainer.innerHTML = '';

        // Mevcut annotation'lardan kullanƒ±lan etiketleri topla
        const usedLabels = new Set();
        this.annotations.forEach(annotation => {
            if (annotation.label && annotation.label.trim() !== '') {
                usedLabels.add(annotation.label);
            }
        });

        const availableLabels = Array.from(usedLabels);
        
        console.log('üîç Modal i√ßin availableLabels:', {
            annotations: this.annotations,
            usedLabels: usedLabels,
            availableLabels: availableLabels
        });

        if (availableLabels.length === 0) {
            // Etiket yoksa bo≈ü mesaj g√∂ster
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'empty-message';
            emptyMessage.textContent = 'Hen√ºz etiket yok';
            availableLabelsContainer.appendChild(emptyMessage);
            return;
        }

        // Ba≈ülƒ±k ekle
        const title = document.createElement('div');
        title.className = 'available-labels-title';
        title.textContent = 'Mevcut Etiketler';
        availableLabelsContainer.appendChild(title);

        // Her etiket i√ßin buton stili olu≈ütur
        availableLabels.forEach(label => {
            const labelButton = document.createElement('button');
            labelButton.className = 'label-selection-button';
            
            // Etiket rengini al (annotation'dan)
            const annotation = this.annotations.find(ann => ann.label === label);
            const labelColor = annotation ? annotation.color : '#007AFF';
            
            labelButton.innerHTML = `
                <div class="label-button-color" style="background-color: ${labelColor}"></div>
                <span class="label-button-text">${label}</span>
            `;

            // Etiket se√ßimi i√ßin tƒ±klama olayƒ±
            labelButton.addEventListener('click', () => {
                console.log('üñ±Ô∏è Modal buton tƒ±klandƒ±:', { 
                    label, 
                    labelType: typeof label,
                    labelLength: label ? label.length : 'undefined',
                    labelColor, 
                    currentAnnotation: this.currentAnnotation,
                    currentAnnotationLabel: this.currentAnnotation?.label 
                });
                
                // Modal input'u doldur ve rengi se√ß
                document.getElementById('modalLabelInput').value = label;
                this.selectedColor = labelColor;
                this.updateColorPreview();
                
                // √ñnce etiketi ata, sonra modal'ƒ± kapat
                this.assignLabelFromModal(label, labelColor);
                this.closeModal();
                console.log('‚úÖ Modal\'dan etiket se√ßildi:', label);
            });

            availableLabelsContainer.appendChild(labelButton);
        });
    }

    updateColorPreview() {
        const colorPreview = document.getElementById('selectedColorPreview');
        if (colorPreview) {
            colorPreview.style.backgroundColor = this.selectedColor;
        }
    }

    deleteLabel(labelToDelete) {
        // Onay alert'i g√∂ster
        const confirmDelete = confirm(`"${labelToDelete}" isimdeki t√ºm etiketler silinecektir, onaylƒ±yor musunuz?`);
        
        if (!confirmDelete) {
            return; // Kullanƒ±cƒ± onaylamadƒ±ysa i≈ülemi iptal et
        }

        // Etiket listesinden √ßƒ±kar
        this.availableLabels = this.availableLabels.filter(label => label !== labelToDelete);

        // Bu etiketle ili≈ükili t√ºm annotationlarƒ± sil
        this.annotations = this.annotations.filter(annotation => annotation.label !== labelToDelete);

        // Bu etiketle ili≈ükili kƒ±rpƒ±lmƒ±≈ü g√∂r√ºnt√ºleri sil
        this.croppedImages = this.croppedImages.filter(img => {
            const annotation = this.annotations.find(ann => ann.id === img.annotationId);
            return annotation && annotation.label !== labelToDelete;
        });

        // Eƒüer silinen etiket aktifse, yeni aktif etiket se√ß
        if (this.activeLabel === labelToDelete) {
            this.activeLabel = this.availableLabels.length > 0 ? this.availableLabels[0] : null;
        }

        // UI'yi g√ºncelle
        this.updateLabelList();
        this.updateAnnotationList();
        this.redraw();

        // Database'e kaydet (WebSocket bildirimi i√ßin)
        console.log('üîµ Etiket silindi, database\'e kaydediliyor...', labelToDelete);
        this.saveAllAnnotationsToDatabase();

        // Bilgilendirme mesajƒ±
        this.showSuccess(`"${labelToDelete}" etiketi silindi.`);
    }



    async uploadAndLoadImage(file) {
        if (!file) return;
        
        try {
            console.log('üì§ Dosya backend\'e y√ºkleniyor:', file.name);
            this.showInfo('Dosya y√ºkleniyor...');
            
            // FormData olu≈ütur
            const formData = new FormData();
            formData.append('image', file);
            
            // Backend'e y√ºkle  
            const response = await fetch(`${window.labelingAuth.baseURL}/api/upload`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                },
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('‚úÖ Dosya y√ºklendi:', result.file);
                
                // Y√ºklenen dosya bilgisiyle resmi y√ºkle
                const serverPath = result.file.filePath; // `/uploads/timestamp_filename.jpg`
                const fullServerUrl = `${window.labelingAuth.baseURL}${serverPath}`;
                
                await this.loadImageFromServerPath(serverPath, result.file);
                
                this.showSuccess(`Dosya y√ºklendi: ${result.file.fileName}`);
                
                // Otomatik kaydet
                if (window.imageManager && window.imageManager.currentProject) {
                    this.saveProject();
                }
                
            } else {
                throw new Error(result.error || 'Dosya y√ºkleme ba≈üarƒ±sƒ±z');
            }
            
        } catch (error) {
            console.error('‚ùå Dosya y√ºkleme hatasƒ±:', error);
            this.showError('Dosya y√ºkleme hatasƒ±: ' + error.message);
            
            // Fallback: Eski sistemi kullan
            this.loadSingleImage(file);
        }
    }

    async loadImageFromServerPath(serverPath, fileInfo) {
        console.log('üì∏ Server\'dan resim y√ºkleniyor:', serverPath);
        
        return new Promise((resolve, reject) => {
            const img = new Image();
            
            img.onload = () => {
                this.image = img;
                
                // Sunucudan gelen dosya bilgisini sakla
                this.image.name = fileInfo.fileName;
                this.image.filePath = serverPath;
                this.image.fullPath = serverPath;
                this.image.lastModified = Date.parse(fileInfo.uploadedAt) || Date.now();
                this.image.serverFile = fileInfo; // Server bilgilerini sakla
                
                this.isMultiImageMode = false;
                this.images = [];
                this.currentImageIndex = 0;
                this.hideImageList();
                
                this.initializeCoordinateSystem();
                this.resizeCanvas();
                
                setTimeout(() => {
                    this.zoomToPhoto();
                    this.updateGridDisplay();
                    this.redraw();
                }, 50);
                
                this.saveOriginalImageData();
                
                console.log('‚úÖ Server\'dan resim y√ºklendi:', {
                    name: fileInfo.fileName,
                    path: serverPath,
                    width: img.width,
                    height: img.height
                });
                
                resolve(img);
            };
            
            img.onerror = (error) => {
                console.error('‚ùå Server resim y√ºkleme hatasƒ±:', error);
                reject(error);
            };
            
            // Server path'ini tam URL'ye √ßevir
            img.src = `${window.labelingAuth.baseURL}${serverPath}`;
        });
    }

    loadSingleImage(file) {
        if (!file) return;
        
        this.isMultiImageMode = false;
        this.images = [];
        this.currentImageIndex = 0;
        this.hideImageList();

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.image = img;
                
                // Dosya bilgisini sakla
                this.image.name = file.name;
                
                // File System Access API ile tam path almaya √ßalƒ±≈ü
                let fullPath = file.name;
                if (file.webkitRelativePath) {
                    fullPath = file.webkitRelativePath;
                } else if (window.showOpenFilePicker && file.handle) {
                    // Modern browsers ile tam path
                    fullPath = file.handle.name;
                } else if (file.path) {
                    // Electron gibi desktop uygulamalarda
                    fullPath = file.path;
                }
                
                this.image.filePath = fullPath;
                this.image.fullPath = fullPath;
                this.image.lastModified = file.lastModified;
                
                console.log('üìÅ Dosya yolu bilgisi:', {
                    name: file.name,
                    filePath: fullPath,
                    webkitRelativePath: file.webkitRelativePath,
                    hasPath: !!file.path
                });
                
                this.initializeCoordinateSystem();
                
                // Canvas'ƒ± boyutlandƒ±r ve resmi g√∂ster
                this.resizeCanvas();
                
                // Kƒ±sa bir gecikme ile resmi ortala
                setTimeout(() => {
                    this.zoomToPhoto();
                    this.updateGridDisplay();
                    this.redraw(); // Resmi g√∂ster
                }, 50);
                
                // Orijinal resim verisini kaydet
                this.saveOriginalImageData();
                
                console.log('üì∏ Fotoƒüraf y√ºklendi:', {
                    name: file.name,
                    size: file.size,
                    lastModified: new Date(file.lastModified).toLocaleString()
                });
                
                // Eƒüer proje y√ºklendiyse ve aynƒ± fotoƒüraf ise, etiketleri g√∂ster
                this.checkAndLoadProjectAnnotations(file);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    async loadImageFolder(files) {
        if (!files || files.length === 0) return;

        // Sadece resim dosyalarƒ±nƒ± filtrele
        const imageFiles = Array.from(files).filter(file => 
            file.type.startsWith('image/')
        );

        if (imageFiles.length === 0) {
            this.showWarning('Se√ßilen klas√∂rde resim dosyasƒ± bulunamadƒ±!');
            return;
        }

        // Y√ºkleme i≈ülemini ba≈ülat
        this.isLoading = true;
        this.loadingProgress = 0;
        this.totalImages = imageFiles.length;
        this.loadedImages = 0;
        this.cancelLoading = false;
        this.loadingStartTime = Date.now();

        this.isMultiImageMode = true;
        this.images = [];
        this.imageAnnotations = {};
        
        // Progress bar g√∂ster
        this.showLoadingProgress();
        
        try {
            // Sadece dosya listesi olu≈ütur - hi√ßbir resim y√ºkleme!
            this.initializeImageList(imageFiles);
            
            // Progress'i hemen 100% yap
            this.loadedImages = imageFiles.length;
            this.updateLoadingProgress();
            
            // Progress bar'ƒ± kƒ±sa bir s√ºre sonra kapat
            setTimeout(() => {
                this.hideLoadingProgress();
            }, 500);
            
            if (this.cancelLoading) {
                this.showInfo('Y√ºkleme iptal edildi.');
                return;
            }
            
            // ƒ∞lk resmi aktif yap (lazy loading ile y√ºklenecek)
        this.currentImageIndex = 0;
        this.showImageList();
            // ƒ∞lk resmi lazy loading ile y√ºkle
        this.switchToImage(0);
        
            this.showSuccess(`${this.totalImages} adet dosya listelendi! Resimler tƒ±klandƒ±ƒüƒ±nda y√ºklenecek.`);
            
        } catch (error) {
            console.error('Klas√∂r y√ºkleme hatasƒ±:', error);
            this.showError('Klas√∂r y√ºklenirken hata olu≈ütu!');
        } finally {
            this.isLoading = false;
        }
    }

    loadImageFile(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    resolve({
                        image: img,
                        dataURL: e.target.result
                    });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    loadImageFileOptimized(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // √áok b√ºy√ºk resimleri otomatik olarak k√º√ß√ºlt
                    let processedImage = img;
                    let processedDataURL = e.target.result;
                    
                    // Maksimum boyut kontrol√º (4K: 3840x2160)
                    const maxWidth = 3840;
                    const maxHeight = 2160;
                    
                    if (img.width > maxWidth || img.height > maxHeight) {
                        const resized = this.resizeImageIfNeeded(img, maxWidth, maxHeight);
                        processedImage = resized.image;
                        processedDataURL = resized.dataURL;
                    }
                    
                    // Thumbnail olu≈ütur (150x150 piksel)
                    const thumbnail = this.createThumbnail(processedImage, 150, 150);
                    
                    resolve({
                        image: processedImage,
                        dataURL: processedDataURL,
                        thumbnail: thumbnail,
                        originalSize: { width: img.width, height: img.height },
                        processedSize: { width: processedImage.width, height: processedImage.height }
                    });
                };
                img.onerror = () => {
                    reject(new Error(`Resim y√ºklenemedi: ${file.name}`));
                };
                img.src = e.target.result;
            };
            reader.onerror = () => {
                reject(new Error(`Dosya okunamadƒ±: ${file.name}`));
            };
            reader.readAsDataURL(file);
        });
    }

    resizeImageIfNeeded(img, maxWidth, maxHeight) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Oranlarƒ± koruyarak boyutlarƒ± hesapla
        let { width, height } = this.calculateThumbnailSize(img.width, img.height, maxWidth, maxHeight);
        
        canvas.width = width;
        canvas.height = height;
        
        // Resmi √ßiz
        ctx.drawImage(img, 0, 0, width, height);
        
        return {
            image: canvas,
            dataURL: canvas.toDataURL('image/jpeg', 0.9) // %90 kalite
        };
    }

    initializeImageList(imageFiles) {
        // T√ºm resimler i√ßin placeholder olu≈ütur (√ßok hƒ±zlƒ± - sadece dosya bilgileri)
        this.images = imageFiles.map((file, index) => ({
            file: file,
            name: file.name,
            image: null,
            dataURL: null,
            thumbnail: null,
            index: index,
            loaded: false,
            thumbnailLoaded: false,
            size: file.size,
            type: file.type,
            lastModified: file.lastModified
        }));
        
        // Her resim i√ßin bo≈ü annotation ve filtre listesi olu≈ütur
        imageFiles.forEach((file, index) => {
            this.imageAnnotations[index] = [];
            this.imageFilters[index] = {
                activeFilters: [],
                activeTextures: []
            };
        });
        
        // ƒ∞lk UI g√ºncellemesi
        this.updateImageList();
    }

    async loadFirstImage(file) {
        try {
            // ƒ∞lk resmi tam olarak y√ºkle
            const imageData = await this.loadImageFileOptimized(file);
            
            // ƒ∞lk resim bilgilerini g√ºncelle
            this.images[0].image = imageData.image;
            this.images[0].dataURL = imageData.dataURL;
            this.images[0].thumbnail = imageData.thumbnail;
            this.images[0].loaded = true;
            this.images[0].thumbnailLoaded = true;
            
            // ƒ∞lk resmi aktif yap
            this.currentImageIndex = 0;
            this.image = imageData.image;
            
            // Cache'e ekle
            this.imageCache.set('image_0', imageData.image);
            
        } catch (error) {
            console.error(`ƒ∞lk resim y√ºkleme hatasƒ± (${file.name}):`, error);
            this.showWarning(`ƒ∞lk resim y√ºklenemedi: ${file.name}`);
        }
    }

    async loadThumbnailLazy(imageData) {
        if (imageData.thumbnailLoaded) return;
        
        try {
            imageData.thumbnailLoaded = true; // ƒ∞≈ülem ba≈üladƒ± olarak i≈üaretle
            
            const thumbnail = await this.loadImageThumbnailOnly(imageData.file);
            imageData.thumbnail = thumbnail.thumbnail;
            
            // UI'yi g√ºncelle
            this.updateImageList();
            
        } catch (error) {
            console.error(`Thumbnail y√ºkleme hatasƒ± (${imageData.name}):`, error);
            imageData.thumbnailLoaded = false; // Hata durumunda tekrar deneyebilsin
        }
    }

    loadImageThumbnailOnly(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Sadece k√º√ß√ºk thumbnail olu≈ütur (100x100 piksel)
                    const thumbnail = this.createThumbnail(img, 100, 100);
                    
                    resolve({
                        thumbnail: thumbnail
                    });
                };
                img.onerror = () => {
                    reject(new Error(`Resim y√ºklenemedi: ${file.name}`));
                };
                img.src = e.target.result;
            };
            reader.onerror = () => {
                reject(new Error(`Dosya okunamadƒ±: ${file.name}`));
            };
            reader.readAsDataURL(file);
        });
    }

    createThumbnail(img, maxWidth, maxHeight) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Oranlarƒ± koruyarak boyutlarƒ± hesapla
        let { width, height } = this.calculateThumbnailSize(img.width, img.height, maxWidth, maxHeight);
        
        canvas.width = width;
        canvas.height = height;
        
        // Resmi √ßiz
        ctx.drawImage(img, 0, 0, width, height);
        
        return canvas.toDataURL('image/jpeg', 0.8); // JPEG formatƒ±nda, %80 kalite
    }

    calculateThumbnailSize(originalWidth, originalHeight, maxWidth, maxHeight) {
        let width = originalWidth;
        let height = originalHeight;
        
        // Oranlarƒ± koruyarak boyutlarƒ± ayarla
        if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
        }
        
        if (height > maxHeight) {
            width = (width * maxHeight) / height;
            height = maxHeight;
        }
        
        return { width: Math.round(width), height: Math.round(height) };
    }

    showLoadingProgress() {
        // Progress bar HTML'i olu≈ütur
        const progressHTML = `
            <div id="loadingProgress" style="
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 1px solid var(--border-primary);
                border-radius: var(--radius-lg);
                padding: var(--spacing-xl);
                z-index: 2000;
                min-width: 400px;
                text-align: center;
                box-shadow: var(--shadow-lg);
            ">
                <div style="margin-bottom: var(--spacing-md);">
                    <i class="fas fa-spinner fa-spin" style="font-size: 24px; color: var(--accent-primary);"></i>
                </div>
                <h3 style="color: var(--text-primary); margin-bottom: var(--spacing-md);">
                    <span id="loadingTitle">Resimler Y√ºkleniyor...</span>
                </h3>
                <div style="
                    background: var(--bg-tertiary);
                    border-radius: var(--radius-sm);
                    height: 8px;
                    margin-bottom: var(--spacing-sm);
                    overflow: hidden;
                ">
                    <div id="progressBar" style="
                        background: var(--accent-primary);
                        height: 100%;
                        width: 0%;
                        transition: width 0.3s ease;
                    "></div>
                </div>
                <div style="color: var(--text-secondary); font-size: 14px; margin-bottom: var(--spacing-md);">
                    <div id="progressText">0 / 0 resim y√ºklendi</div>
                    <div id="progressDetails" style="font-size: 12px; margin-top: 4px; color: var(--text-muted);">
                        Hazƒ±rlanƒ±yor...
                    </div>
                </div>
                <button id="cancelLoadingBtn" style="
                    background: var(--accent-error);
                    color: white;
                    border: none;
                    padding: var(--spacing-sm) var(--spacing-md);
                    border-radius: var(--radius-sm);
                    cursor: pointer;
                    font-size: 14px;
                ">
                    <i class="fas fa-times"></i> ƒ∞ptal Et
                </button>
            </div>
        `;
        
        // Progress bar'ƒ± ekle
        document.body.insertAdjacentHTML('beforeend', progressHTML);
        
        // ƒ∞ptal butonu event listener'ƒ±
        document.getElementById('cancelLoadingBtn').addEventListener('click', () => {
            this.cancelLoading = true;
        });
    }

    updateLoadingProgress() {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const progressDetails = document.getElementById('progressDetails');
        const loadingTitle = document.getElementById('loadingTitle');
        
        if (progressBar && progressText) {
            const percentage = (this.loadedImages / this.totalImages) * 100;
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = `${this.loadedImages} / ${this.totalImages} dosya listelendi`;
            
            if (progressDetails) {
                const remaining = this.totalImages - this.loadedImages;
                if (remaining > 0) {
                    progressDetails.textContent = `${remaining} dosya kaldƒ±`;
                } else {
                    progressDetails.textContent = 'Klas√∂r hazƒ±r!';
                }
            }
            
            if (loadingTitle) {
                if (this.totalImages > 1000) {
                    loadingTitle.textContent = `B√ºy√ºk Klas√∂r Listeleniyor (${this.totalImages} dosya)...`;
                } else {
                    loadingTitle.textContent = 'Klas√∂r Listeleniyor...';
                }
            }
        }
    }

    estimateRemainingTime(remaining) {
        if (this.loadedImages === 0) return null;
        
        const startTime = this.loadingStartTime || Date.now();
        const elapsed = Date.now() - startTime;
        const avgTimePerImage = elapsed / this.loadedImages;
        const estimatedRemaining = Math.round((remaining * avgTimePerImage) / 1000);
        
        if (estimatedRemaining < 60) {
            return `~${estimatedRemaining}s`;
        } else {
            const minutes = Math.round(estimatedRemaining / 60);
            return `~${minutes}dk`;
        }
    }

    hideLoadingProgress() {
        const progressElement = document.getElementById('loadingProgress');
        if (progressElement) {
            progressElement.remove();
        }
    }

    showImageList() {
        document.getElementById('imageListSection').style.display = 'block';
        this.updateImageList();
        this.updateImageNavigation();
    }

    hideImageList() {
        document.getElementById('imageListSection').style.display = 'none';
    }

    updateImageList() {
        const container = document.getElementById('imageList');
        const countSpan = document.getElementById('imageCount');
        
        // ImageManager'dan fotoƒüraflarƒ± al
        if (this.imageManager && this.imageManager.images) {
            this.images = this.imageManager.images;
        }
        
        // Y√ºkleme sƒ±rasƒ±nda totalImages kullan, yoksa images.length kullan
        const totalCount = this.totalImages || (this.images ? this.images.length : 0);
        if (countSpan) {
        countSpan.textContent = totalCount;
        }

        // Sayfalama ile normal rendering (virtual scrolling kaldƒ±rƒ±ldƒ±)
            this.updateImageListNormal(container);
    }

    updateImageListVirtual(container) {
        // Sadece g√∂r√ºnen alan + buffer i√ßin DOM elementleri olu≈ütur
        const containerHeight = container.clientHeight || 300;
        const itemHeight = 33; // Her thumbnail yakla≈üƒ±k 33px (32px + 1px margin)
        const visibleCount = Math.ceil(containerHeight / itemHeight) + 10; // +10 buffer
        
        // Mevcut DOM elementlerini temizle
        container.innerHTML = '';
        
        // Sadece g√∂r√ºnen aralƒ±ktaki resimleri olu≈ütur
        const startIndex = Math.max(0, this.currentImageIndex - Math.floor(visibleCount / 2));
        const endIndex = Math.min(this.images ? this.images.length : 0, startIndex + visibleCount);
        
        // Toplam y√ºkseklik i√ßin spacer olu≈ütur
        const totalHeight = (this.images ? this.images.length : 0) * itemHeight;
        const spacerTop = document.createElement('div');
        spacerTop.style.height = `${startIndex * itemHeight}px`;
        container.appendChild(spacerTop);
        
        // G√∂r√ºnen elementleri olu≈ütur
        for (let i = startIndex; i < endIndex; i++) {
            const imageData = this.images[i];
            const thumbnail = this.createThumbnailElement(imageData, i);
            container.appendChild(thumbnail);
        }
        
        // Alt spacer
        const spacerBottom = document.createElement('div');
        spacerBottom.style.height = `${(this.images ? this.images.length : 0) - endIndex}px`;
        container.appendChild(spacerBottom);
        
        // Scroll pozisyonunu ayarla
        const scrollTop = startIndex * itemHeight;
        container.scrollTop = scrollTop;
        
        console.log(`üì± Virtual scrolling: ${startIndex}-${endIndex} / ${this.images.length} (${visibleCount} g√∂r√ºn√ºr)`);
    }

    updateImageListNormal(container) {
        container.innerHTML = '';

        if (!this.images || this.images.length === 0) {
            container.innerHTML = `
                <div style="
                    text-align: center; 
                    color: var(--text-muted); 
                    padding: 1rem;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 0.5rem;
                    font-size: 0.8rem;
                ">
                    <i class="fas fa-images" style="font-size: 1.5rem; opacity: 0.5;"></i>
                    <div>Hen√ºz fotoƒüraf y√ºklenmedi</div>
                </div>
            `;
            this.totalPages = 1;
            this.currentPage = 1;
            this.updatePaginationInfo();
            this.updatePaginationControls();
            return;
        }

        // Sayfalama hesapla
        const totalCount = this.totalImages || this.images.length;
        this.totalPages = Math.ceil(totalCount / this.itemsPerPage);
        if (this.currentPage > this.totalPages) {
            this.currentPage = this.totalPages;
        }
        if (this.currentPage < 1) {
            this.currentPage = 1;
        }

        // Mevcut sayfa i√ßin fotoƒüraflarƒ± al
        const startIndex = (this.currentPage - 1) * this.itemsPerPage;
        const endIndex = Math.min(startIndex + this.itemsPerPage, totalCount);
        const currentPageImages = this.images.slice(startIndex, endIndex);

        // Sayfa fotoƒüraflarƒ±nƒ± render et
        currentPageImages.forEach((imageData, index) => {
            const globalIndex = startIndex + index;
            const thumbnail = this.createThumbnailElement(imageData, globalIndex);
            container.appendChild(thumbnail);
        });

        // Sayfalama bilgilerini g√ºncelle
        this.updatePaginationInfo();
        this.updatePaginationControls();
    }

    // Sayfalama bilgilerini g√ºncelle
    updatePaginationInfo() {
        const currentPageEl = document.getElementById('currentPage');
        const totalPagesEl = document.getElementById('totalPages');
        
        if (currentPageEl) {
            currentPageEl.textContent = this.currentPage;
        }
        
        if (totalPagesEl) {
            totalPagesEl.textContent = this.totalPages;
        }
    }

    // Sayfalama kontrollerini g√ºncelle
    updatePaginationControls() {
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        
        if (prevPageBtn) {
            prevPageBtn.disabled = this.currentPage <= 1;
        }
        
        if (nextPageBtn) {
            nextPageBtn.disabled = this.currentPage >= this.totalPages;
        }
    }

    // Belirli sayfaya git
    goToPage(page) {
        if (page >= 1 && page <= this.totalPages && page !== this.currentPage) {
            this.currentPage = page;
            this.updateImageList();
        }
    }

    // √ñnceki sayfa
    goToPreviousPage() {
        if (this.currentPage > 1) {
            this.goToPage(this.currentPage - 1);
        }
    }

    // Sonraki sayfa
    goToNextPage() {
        if (this.currentPage < this.totalPages) {
            this.goToPage(this.currentPage + 1);
        }
    }

    createThumbnailElement(imageData, index) {
            const thumbnail = document.createElement('div');
            thumbnail.className = 'image-thumbnail';
            
            if (index === this.currentImageIndex) {
                thumbnail.classList.add('active');
            }

        // K√º√ß√ºk √∂nizleme resmi (24x24px)
        const preview = document.createElement('img');
        preview.className = 'image-preview';
        if (imageData.thumbnail) {
            preview.src = imageData.thumbnail;
        } else {
            // Placeholder resim
            preview.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiBmaWxsPSIjMzMzIi8+PHRleHQgeD0iMTIiIHk9IjEyIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iOCIgZmlsbD0iIzY2NiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltZzwvdGV4dD48L3N2Zz4=';
        }
        preview.alt = imageData.name;
        thumbnail.appendChild(preview);

        // Resim bilgileri container'ƒ±
            const info = document.createElement('div');
            info.className = 'image-info';
            
        // Resim adƒ±
            const name = document.createElement('div');
            name.className = 'image-name';
        name.textContent = imageData.name;
        info.appendChild(name);

        // Badge'ler container'ƒ±
        const badges = document.createElement('div');
        badges.className = 'image-badges';

        // Resim numarasƒ±
        const number = document.createElement('div');
        number.className = 'image-number';
        number.textContent = index + 1;
        badges.appendChild(number);

        // Etiket sayƒ±sƒ± (eƒüer varsa)
        const annotationCount = (this.imageAnnotations && this.imageAnnotations[index]) ? this.imageAnnotations[index].length : 0;
        if (annotationCount > 0) {
            const annotationBadge = document.createElement('div');
            annotationBadge.className = 'annotation-count';
            annotationBadge.textContent = annotationCount;
            badges.appendChild(annotationBadge);
        }

        info.appendChild(badges);
            thumbnail.appendChild(info);
            
            thumbnail.addEventListener('click', () => this.switchToImage(index));
        
        return thumbnail;
    }

    updateImageNavigation() {
        document.getElementById('currentImageIndex').textContent = this.currentImageIndex + 1;
        document.getElementById('totalImages').textContent = this.images ? this.images.length : 0;
        
        // Ana navigasyon butonlarƒ±
        const prevImageBtn = document.getElementById('prevImage');
        const nextImageBtn = document.getElementById('nextImage');
        if (prevImageBtn) prevImageBtn.disabled = this.currentImageIndex === 0;
        if (nextImageBtn) nextImageBtn.disabled = this.currentImageIndex === (this.images ? this.images.length - 1 : 0);
    }

    switchToImage(index) {
        // Use optimized version
        this.switchToImageOptimized(index);
    }


    async previousImage() {
        if (!this.imageManager) return;
        
        // Direkt ImageManager'ƒ±n previousImage fonksiyonunu kullan
        await this.imageManager.previousImage();
    }

    async nextImage() {
        if (!this.imageManager) return;
        
        // Direkt ImageManager'ƒ±n nextImage fonksiyonunu kullan
        await this.imageManager.nextImage();
    }

    deleteImage(index) {
        if (!this.isMultiImageMode || !this.images || index < 0 || index >= this.images.length) return;
        
        // Silinecek fotoƒürafƒ±n adƒ±nƒ± al
        const imageToDelete = this.images[index];
        const deletedImageName = imageToDelete.name;
        
        // Onay alert'i g√∂ster
        const confirmDelete = confirm(`"${deletedImageName}" fotoƒürafƒ±nƒ± silmek istediƒüinizden emin misiniz?\n\nBu i≈ülem geri alƒ±namaz ve fotoƒürafa ait t√ºm etiketler de silinecektir.`);
        
        if (!confirmDelete) {
            return; // Kullanƒ±cƒ± iptal etti
        }
        
        // Eƒüer tek fotoƒüraf kaldƒ±ysa, tek resim moduna ge√ß
        if (this.images && this.images.length === 1) {
            this.images = [];
            this.imageAnnotations = {};
            this.annotations = [];
            this.image = null;
            this.isMultiImageMode = false;
            this.hideImageList();
            this.redraw();
            this.showSuccess('Son fotoƒüraf silindi. Tekrar fotoƒüraf y√ºkleyebilirsiniz.');
            return;
        }

        // Fotoƒürafƒ± ve annotation'larƒ±nƒ± sil
        this.images.splice(index, 1);
        delete this.imageAnnotations[index];
        
        // Annotation indexlerini yeniden d√ºzenle
        const newImageAnnotations = {};
        Object.keys(this.imageAnnotations).forEach(key => {
            const oldIndex = parseInt(key);
            if (oldIndex > index) {
                newImageAnnotations[oldIndex - 1] = this.imageAnnotations[key];
            } else if (oldIndex < index) {
                newImageAnnotations[oldIndex] = this.imageAnnotations[key];
            }
        });
        this.imageAnnotations = newImageAnnotations;
        
        // Fotoƒüraf indexlerini g√ºncelle
        this.images.forEach((img, i) => {
            img.index = i;
        });
        
        // Aktif fotoƒüraf indexini ayarla
        if (this.images && this.currentImageIndex >= this.images.length) {
            // Son fotoƒüraftaysak, bir √∂ncekine ge√ß
            this.currentImageIndex = this.images.length - 1;
        } else if (this.currentImageIndex > index) {
            // Silinen fotoƒüraftan sonraki bir fotoƒüraftaysak, index'i bir azalt
            this.currentImageIndex--;
        }
        // Silinen fotoƒüraftan √∂nceki bir fotoƒüraftaysak, index aynƒ± kalƒ±r
        
        // UI'yi g√ºncelle
        this.switchToImage(this.currentImageIndex);
        this.showSuccess(`"${deletedImageName}" fotoƒürafƒ± silindi.`);
    }

    resizeCanvas() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth - 4;
        this.canvas.height = container.clientHeight - 4;
        this.redraw();
    }

    setTool(tool) {
        // Sadece rectangle tool desteklenir
        if (tool !== 'rectangle') {
            this.showWarning('Sadece dikd√∂rtgen aracƒ± desteklenir!');
            return;
        }
        
        this.currentTool = 'rectangle';
        
        // Buton durumlarƒ±nƒ± g√ºncelle (sadece mevcut butonlar i√ßin)
        const buttons = document.querySelectorAll('.btn');
        if (buttons) {
            buttons.forEach(btn => {
                if (btn && btn.classList) {
                    btn.classList.remove('active');
                }
            });
        }
        
        // Canvas cursor'ƒ±nƒ± g√ºncelle
        this.updateCanvasCursor();
    }

    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        // Raw canvas koordinatlarƒ±
        const canvasX = e.clientX - rect.left;
        const canvasY = e.clientY - rect.top;
        
        // Canvas koordinatlarƒ±nƒ± g√∂rsel koordinatlarƒ±na d√∂n√º≈üt√ºr
        const imageX = (canvasX - this.panX) / this.zoom;
        const imageY = (canvasY - this.panY) / this.zoom;
        
        return { x: imageX, y: imageY };
    }

    getRawMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }

    // Canvas koordinatlarƒ±nƒ± g√∂rsel koordinatlara d√∂n√º≈üt√ºr
    canvasToImage(canvasX, canvasY) {
        return {
            x: (canvasX - this.panX) / this.zoom,
            y: (canvasY - this.panY) / this.zoom
        };
    }

    // G√∂rsel koordinatlarƒ± canvas koordinatlarƒ±na d√∂n√º≈üt√ºr
    imageToCanvas(imageX, imageY) {
        return {
            x: imageX * this.zoom + this.panX,
            y: imageY * this.zoom + this.panY
        };
    }

    // Canvas koordinatlarƒ±nƒ± g√∂rsel koordinatlarƒ±na d√∂n√º≈üt√ºr
    canvasToImageCoords(canvasX, canvasY) {
        if (!this.image) return { x: canvasX, y: canvasY };
        
        // Raw canvas koordinatlarƒ±nƒ± g√∂rsel koordinatlarƒ±na d√∂n√º≈üt√ºr
        const imageX = (canvasX - this.panX) / this.zoom;
        const imageY = (canvasY - this.panY) / this.zoom;
        
        // G√∂rsel boyutlarƒ±na g√∂re sƒ±nƒ±rla
        const imageWidth = this.image.width;
        const imageHeight = this.image.height;
        
        return {
            x: Math.max(0, Math.min(imageWidth, imageX)),
            y: Math.max(0, Math.min(imageHeight, imageY))
        };
    }

    // G√∂rsel koordinatlarƒ±nƒ± canvas koordinatlarƒ±na d√∂n√º≈üt√ºr
    imageToCanvasCoords(imageX, imageY) {
        if (!this.image) return { x: imageX, y: imageY };
        
        // Zoom ve pan d√∂n√º≈ü√ºm√º
        const canvasX = imageX * this.zoom + this.panX;
        const canvasY = imageY * this.zoom + this.panY;
        
        return { x: canvasX, y: canvasY };
    }

    handleMouseDown(e) {
        console.log('üñ±Ô∏è Script.js handleMouseDown √ßaƒürƒ±ldƒ±!', e);
        if (!this.image) {
            console.log('‚ùå Image yok, mouse down iptal edildi');
            return;
        }

        const rawPos = this.getRawMousePos(e);
        
        // Ctrl + sol tƒ±k = pan modu ba≈ülat
        if (e.ctrlKey && e.button === 0) {
            this.isPanning = true;
            this.lastPanX = rawPos.x;
            this.lastPanY = rawPos.y;
            this.canvas.style.cursor = 'grabbing';
            e.preventDefault();
            return;
        }

        // 1. Handle kontrol√º - t√ºm annotation'larƒ± kontrol et
        const rect = this.canvas.getBoundingClientRect();
        const canvasPos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        console.log('üîç Handle detection ba≈ülatƒ±lƒ±yor...', { canvasPos, annotations: this.annotations.length });
        const handle = this.getHandleAt(canvasPos);
        console.log('üîç Handle detection sonucu:', handle);
        
        if (handle) {
            console.log('üéØ Handle bulundu!', handle);
            // Handle'a tƒ±klandƒ± - boyut deƒüi≈ütirme ba≈ülat
            // Handle bulunduƒüunda annotation'ƒ± se√ß
            if (this.selectedAnnotation || this.focusedAnnotation) {
                // Zaten se√ßili annotation var
                console.log('‚úÖ Annotation zaten se√ßili:', this.selectedAnnotation || this.focusedAnnotation);
            } else {
                // Handle'dan annotation'ƒ± bul ve se√ß
                const annotation = this.annotations.find(ann => 
                    ann === this.selectedAnnotation || ann === this.focusedAnnotation
                );
                if (annotation) {
                    this.selectedAnnotation = annotation;
                    this.focusedAnnotation = annotation;
                    console.log('‚úÖ Annotation se√ßildi:', annotation);
                }
            }
            
            this.isDraggingHandle = true;
            this.dragHandle = handle;
            this.canvas.style.cursor = 'grabbing';
            console.log('üöÄ Handle dragging ba≈ülatƒ±ldƒ±');
            e.preventDefault();
            return;
        }
        
        // 2. Etiket ta≈üƒ±ma kontrol√º - se√ßili etiket varsa
        if (this.focusedAnnotation && !this.focusedAnnotation.locked) {
            const pos = this.getMousePos(e);
            const clickedAnnotation = this.getAnnotationAt(e);
            
            if (clickedAnnotation && clickedAnnotation === this.focusedAnnotation) {
                // Etiket ta≈üƒ±ma ba≈ülat
                this.isDraggingAnnotation = true;
                this.dragStartPos = pos;
                this.dragAnnotation = clickedAnnotation;
                
                // labelPosition'ƒ± en sol √ºstteki handle'a g√∂re ayarla
                const labelPos = this.getLabelPosition(this.dragAnnotation);
                if (labelPos) {
                    this.dragAnnotation.labelPosition = {
                        x: labelPos.x,
                        y: labelPos.y
                    };
                }
                
                this.canvas.style.cursor = 'grabbing';
                e.preventDefault();
                return;
            }
        }

        // 3. Rectangle √ßizim modu - yeni etiket olu≈ütur
        if (this.currentTool === 'rectangle') {
            const pos = this.getMousePos(e);
            this.isDrawing = true;
            this.startX = pos.x;
            this.startY = pos.y;
        }
        
        // 4. Etiket se√ßimi - her zaman √ßalƒ±≈üƒ±r
        this.handleClick(e);
    }

    addPolygonPointToCanvas(pos) {
        // Polygon sistemi kaldƒ±rƒ±ldƒ± - sadece rectangle desteklenir
        return;
    }

    handleMouseMove(e) {
        if (!this.image) return;

        const rawPos = this.getRawMousePos(e);
        
        this.currentMousePos = this.getMousePos(e);
        

        // Pan modu
        if (this.isPanning) {
            this.panX += rawPos.x - this.lastPanX;
            this.panY += rawPos.y - this.lastPanY;
            this.lastPanX = rawPos.x;
            this.lastPanY = rawPos.y;
            this.needsRedraw = true;
            this.redraw();
            return;
        }

        // Handle s√ºr√ºkleme modu
        if (this.isDraggingHandle && this.dragHandle) {
            console.log('üîÑ Handle dragging devam ediyor...');
            // Handle'dan annotation'ƒ± bul
            const annotation = this.selectedAnnotation || this.focusedAnnotation;
            if (!annotation) {
                console.log('‚ùå Annotation bulunamadƒ±!');
                this.isDraggingHandle = false;
                this.dragHandle = null;
                return;
            }
            
            // Kilitli annotation'ƒ± kontrol et
            if (annotation.locked) {
                console.log('üîí Annotation kilitli!');
                this.showToast('Bu etiket kilitli! D√ºzenlemek i√ßin kilidi a√ßƒ±n.', 'warning');
                this.isDraggingHandle = false;
                this.dragHandle = null;
                return;
            }
            
            // Mouse pozisyonunu al (canvas koordinatlarƒ±)
            const rawPos = this.getRawMousePos(e);
            console.log('üìç Mouse pos (canvas):', rawPos);
            
            // AnnotationManager'a canvas koordinatlarƒ±nƒ± g√∂nder (d√∂n√º≈ü√ºm√º o yapacak)
            this.annotationManager.resizeAnnotation(annotation, this.dragHandle, rawPos);
            this.needsRedraw = true;
            this.redraw();
            return;
        }
        
        // Etiket ta≈üƒ±ma modu
        if (this.isDraggingAnnotation && this.dragAnnotation) {
            // Kilitli annotation'ƒ± kontrol et
            if (this.dragAnnotation.locked) {
                this.showToast('Bu etiket kilitli! D√ºzenlemek i√ßin kilidi a√ßƒ±n.', 'warning');
                this.isDraggingAnnotation = false;
                this.dragAnnotation = null;
                return;
            }
            
            // Mouse pozisyonunu image koordinatlarƒ±na d√∂n√º≈üt√ºr
            const pos = this.getMousePos(e);
            const deltaX = pos.x - this.dragStartPos.x;
            const deltaY = pos.y - this.dragStartPos.y;
            
            // Etiket pozisyonunu g√ºncelle
            this.dragAnnotation.x += deltaX;
            this.dragAnnotation.y += deltaY;
            
            // LabelPosition'ƒ± en sol √ºstteki handle'a g√∂re yeniden hesapla
            // getLabelPosition fonksiyonu en sol √ºstteki handle'ƒ± bulur ve pozisyonu hesaplar
            const newLabelPos = this.getLabelPosition(this.dragAnnotation);
            if (newLabelPos) {
                this.dragAnnotation.labelPosition = {
                    x: newLabelPos.x,
                    y: newLabelPos.y
                };
            }
            
            // Ba≈ülangƒ±√ß pozisyonunu g√ºncelle
            this.dragStartPos = pos;
            
            this.needsRedraw = true;
            this.redraw();
            return;
        }

        // Handle hover cursor kontrol√º - se√ßili etiket varsa
        if (this.focusedAnnotation && !this.focusedAnnotation.locked && !this.isDraggingHandle && !this.isDraggingAnnotation) {
            const rect = this.canvas.getBoundingClientRect();
            const canvasPos = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            const handle = this.getHandleAt(canvasPos);
            
            if (handle) {
                // Handle √ºzerinde cursor deƒüi≈ütir
                if (handle.type === 'corner') {
                    // K√∂≈üe handle'ƒ± - resize cursor
                    this.canvas.style.cursor = 'nw-resize';
                } else if (handle.type === 'edge') {
                    // Kenar handle'ƒ± - resize cursor (kenar y√∂n√ºne g√∂re)
                    const edgeIndex = handle.index;
                    if (edgeIndex === 0 || edgeIndex === 2) {
                        // √úst ve alt kenar - yatay resize
                        this.canvas.style.cursor = 'ns-resize';
                    } else {
                        // Sol ve saƒü kenar - dikey resize
                        this.canvas.style.cursor = 'ew-resize';
                    }
                } else {
                    // Diƒüer handle tipleri
                    this.canvas.style.cursor = 'grab';
                }
            } else if (this.focusedAnnotation) {
                // Etiket √ºzerinde cursor deƒüi≈ütir
                this.canvas.style.cursor = 'move';
            } else {
                this.canvas.style.cursor = 'default';
            }
        } else {
            // Handle yoksa normal cursor
            this.canvas.style.cursor = 'default';
        }

        // Rectangle √ßizim modu
        if (this.isDrawing && this.currentTool === 'rectangle') {
            const pos = this.getMousePos(e);
            this.needsRedraw = true;
            this.redraw();
            
            // Rectangle √ßiziliyor
            
            // Ge√ßici rectangle √ßiz (zoom'a g√∂re ayarla)
            this.ctx.save();
            this.ctx.setTransform(this.zoom, 0, 0, this.zoom, this.panX, this.panY);
            this.ctx.strokeStyle = '#e74c3c';
            this.ctx.lineWidth = 2 / this.zoom;
            this.ctx.strokeRect(
                this.startX, 
                this.startY, 
                pos.x - this.startX, 
                pos.y - this.startY
            );
            this.ctx.restore();
        }
    }

    handleMouseUp(e) {
        // Pan modunu bitir
        if (this.isPanning) {
            this.isPanning = false;
            this.canvas.style.cursor = 'crosshair';
            return;
        }

        // Handle s√ºr√ºkleme bitir - t√ºm tool'larda √ßalƒ±≈ümalƒ±
        if (this.isDraggingHandle) {
            // Kilitli annotation'ƒ± kontrol et
            if (this.focusedAnnotation && this.focusedAnnotation.locked) {
                this.showToast('Bu etiket kilitli! D√ºzenlemek i√ßin kilidi a√ßƒ±n.', 'warning');
                this.isDraggingHandle = false;
                this.dragHandle = null;
                this.canvas.style.cursor = 'default';
                return;
            }
            
            this.isDraggingHandle = false;
            this.dragHandle = null;
            this.canvas.style.cursor = 'default';
            this.redraw(); // Deƒüi≈üiklikleri g√∂ster
            return;
        }
        
        // Etiket ta≈üƒ±ma bitir
        if (this.isDraggingAnnotation) {
            // Kilitli annotation'ƒ± kontrol et
            if (this.dragAnnotation && this.dragAnnotation.locked) {
                this.showToast('Bu etiket kilitli! D√ºzenlemek i√ßin kilidi a√ßƒ±n.', 'warning');
                this.isDraggingAnnotation = false;
                this.dragAnnotation = null;
                this.canvas.style.cursor = 'default';
                return;
            }
            
            this.isDraggingAnnotation = false;
            this.dragAnnotation = null;
            this.dragStartPos = null;
            this.canvas.style.cursor = 'default';
            this.redraw(); // Deƒüi≈üiklikleri g√∂ster
            return;
        }
        
        // Handle s√ºr√ºkleme sƒ±rasƒ±nda yeni etiket olu≈üturmayƒ± engelle - zaten yukarƒ±da kontrol edildi
        
        // Sadece rectangle tool desteklenir

        if (!this.image || !this.isDrawing || this.currentTool !== 'rectangle') return;

        const pos = this.getMousePos(e);
        this.isDrawing = false;

        // Rectangle olu≈üturuluyor

        // Rectangle annotation olu≈ütur
        const width = pos.x - this.startX;
        const height = pos.y - this.startY;

        // Minimum boyut kontrol√º - daha b√ºy√ºk minimum boyut
        const minSize = 20 / this.zoom; // 20 piksel minimum
        if (Math.abs(width) > minSize && Math.abs(height) > minSize) {
            // getMousePos zaten g√∂rsel koordinatlarƒ±nƒ± veriyor, direkt kullan
            const imageWidth = Math.abs(pos.x - this.startX);
            const imageHeight = Math.abs(pos.y - this.startY);
            
            // Rectangle'ƒ± direkt polygon benzeri d√ºzenlenebilir olarak olu≈ütur
            const x = Math.min(this.startX, pos.x);
            const y = Math.min(this.startY, pos.y);
            const width = imageWidth;
            const height = imageHeight;
            
            // Annotation'ƒ± olu≈ütur ama hen√ºz listeye ekleme
            this.currentAnnotation = {
                type: 'rectangle',
                x: x,
                y: y,
                width: width,
                height: height,
                // Polygon benzeri d√ºzenlenebilir noktalar
                points: [
                    { x: x, y: y }, // Sol √ºst
                    { x: x + width, y: y }, // Saƒü √ºst
                    { x: x + width, y: y + height }, // Saƒü alt
                    { x: x, y: y + height } // Sol alt
                ],
                label: '',
                color: this.selectedColor || this.getNextAutoColor(),
                id: Date.now()
            };
            
            // DEBUG: Koordinatlarƒ± konsola yazdƒ±r
            console.log('üîç Etiket koordinatlarƒ±:', {
                x: x,
                y: y,
                width: width,
                height: height,
                imageWidth: this.image?.width,
                imageHeight: this.image?.height,
                zoom: this.zoom,
                panX: this.panX,
                panY: this.panY
            });
            this.redraw();
            
            // Hƒ±zlƒ± etiket modunda direkt √∂nceki etiketin ismini al
            if (this.quickLabelMode && this.activeLabel) {
                this.currentAnnotation.label = this.activeLabel;
                this.currentAnnotation.color = this.getNextAutoColor();
                // Annotation'ƒ± listeye ekle
                this.annotations.push(this.currentAnnotation);
                this.currentAnnotation = null;
                this.updateAnnotationList();
                
                // History'ye kaydet
                this.saveToHistory();
                
                // Projeyi kaydet
                this.isSaved = false; // Yeni annotation eklendi, kaydedilmemi≈ü
                this.saveProject();
                
                // Redraw flag'ini set et
                this.needsRedraw = true;
                this.redraw();
                
                // Yeni annotation'ƒ± se√ßili ve focuslanmƒ±≈ü yap
                this.selectedAnnotation = this.annotations[this.annotations.length - 1];
                this.focusedAnnotation = this.annotations[this.annotations.length - 1];
                this.showSuccess(`"${this.activeLabel}" etiketi eklendi!`);
            } else {
                // Normal mod: Modal g√∂ster
                this.showNewLabelModal();
            }
        }
    }

    handleClick(e) {
        if (!this.image) return;

        // Kilit ikonuna tƒ±klama kontrol√º
        const lockClickResult = this.checkLockIconClick(e);
        if (lockClickResult) {
            return; // Kilit ikonuna tƒ±klandƒ±, i≈ülem tamamlandƒ±
        }

        // Sadece rectangle tool desteklenir

        // Diƒüer tool'lar i√ßin normal mantƒ±k
        const clickedAnnotation = this.getAnnotationAt(e);
        
        if (clickedAnnotation) {
            // Etikete tƒ±klandƒ±ƒüƒ±nda sadece focus yap
            this.focusedAnnotation = clickedAnnotation;
            
            // Se√ßim i≈ülemini de yap
            this.selectedAnnotation = clickedAnnotation;
            this.annotationManager.updateAnnotationList();
            
            console.log('‚úÖ Annotation focus\'landƒ±:', clickedAnnotation.id);
            this.redraw();
        } else {
            // Bo≈ü alana tƒ±klandƒ±ƒüƒ±nda focus'u kaldƒ±r
            this.focusedAnnotation = null;
            this.selectedAnnotation = null;
            this.annotationManager.updateAnnotationList();
            
            console.log('‚ùå Focus kaldƒ±rƒ±ldƒ± - bo≈ü alana tƒ±klandƒ±');
            this.redraw();
        }

        // Bo≈ü alana tƒ±klanƒ±rsa se√ßimi kaldƒ±r - zaten yukarƒ±da yapƒ±ldƒ±

        // Ba≈üka bir annotation'a tƒ±klandƒ± - zaten yukarƒ±da se√ßim yapƒ±ldƒ±
    }


    // Polygon sistemi kaldƒ±rƒ±ldƒ±

    handleDoubleClick(e) {
        // √áift tƒ±klama - annotation edit modu
        const clickedAnnotation = this.getAnnotationAt(e);
        if (clickedAnnotation) {
            this.startEditingAnnotation(clickedAnnotation);
        }
    }

    handleRightClick(e) {
        e.preventDefault(); // Varsayƒ±lan context menu'yu engelle
        
        if (!this.image) return;

        // Saƒü tƒ±k i≈ülemi kaldƒ±rƒ±ldƒ± - kilitleme sistemi yok
        console.log('‚ÑπÔ∏è Saƒü tƒ±k i≈ülemi kaldƒ±rƒ±ldƒ±');
    }

    showContextMenu(e, annotation) {
        // Mevcut context menu'yu kaldƒ±r
        const existingMenu = document.getElementById('contextMenu');
        if (existingMenu) {
            existingMenu.remove();
        }

        // Yeni context menu olu≈ütur
        const menu = document.createElement('div');
        menu.id = 'contextMenu';
        menu.className = 'context-menu';
        menu.style.cssText = `
            position: fixed;
            background: #34495e;
            border: 1px solid #2c3e50;
            border-radius: 6px;
            padding: 5px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            min-width: 150px;
            color: white;
            font-size: 13px;
        `;

        // Menu √∂ƒüeleri
        const deleteItem = document.createElement('div');
        deleteItem.className = 'context-menu-item';
        deleteItem.innerHTML = `
            <span style="margin-right: 8px;">üóëÔ∏è</span>
            <span>Silme (${annotation.label})</span>
        `;
        deleteItem.style.cssText = `
            padding: 8px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
        `;
        
        deleteItem.addEventListener('mouseenter', () => {
            deleteItem.style.backgroundColor = '#e74c3c';
        });
        
        deleteItem.addEventListener('mouseleave', () => {
            deleteItem.style.backgroundColor = 'transparent';
        });
        
        deleteItem.addEventListener('click', () => {
            this.deleteAnnotationByObject(annotation);
            menu.remove();
        });

        // Edit √∂ƒüesi
        const editItem = document.createElement('div');
        editItem.className = 'context-menu-item';
        editItem.innerHTML = `
            <span style="margin-right: 8px;">‚úèÔ∏è</span>
            <span>D√ºzenle</span>
        `;
        editItem.style.cssText = `
            padding: 8px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
        `;
        
        editItem.addEventListener('mouseenter', () => {
            editItem.style.backgroundColor = '#3498db';
        });
        
        editItem.addEventListener('mouseleave', () => {
            editItem.style.backgroundColor = 'transparent';
        });
        
        editItem.addEventListener('click', () => {
            this.startEditingAnnotation(annotation);
            menu.remove();
        });

        // Renk deƒüi≈ütir √∂ƒüesi

        // A√ßƒ±klama ekle/d√ºzenle √∂ƒüesi

        // Menu'ya √∂ƒüeleri ekle
        menu.appendChild(editItem);
        menu.appendChild(deleteItem);

        // Sayfaya ekle
        document.body.appendChild(menu);

        // Mouse pozisyonuna yerle≈ütir
        const rect = this.canvas.getBoundingClientRect();
        const menuX = e.clientX;
        const menuY = e.clientY;
        
        menu.style.left = Math.min(window.innerWidth - 200, menuX) + 'px';
        menu.style.top = Math.min(window.innerHeight - 120, menuY) + 'px';

        // Dƒ±≈üarƒ± tƒ±klandƒ±ƒüƒ±nda kapat
        const closeMenu = (clickEvent) => {
            if (!menu.contains(clickEvent.target)) {
                menu.remove();
                document.removeEventListener('click', closeMenu);
                document.removeEventListener('contextmenu', closeMenu);
            }
        };
        
        setTimeout(() => {
            document.addEventListener('click', closeMenu);
            document.addEventListener('contextmenu', closeMenu);
        }, 100);
    }


    deleteAnnotationByObject(annotation) {
        // Annotation'ƒ± listeden kaldƒ±r
        this.annotations = this.annotations.filter(ann => ann.id !== annotation.id);
        
        // Eƒüer silinen annotation se√ßiliyse, se√ßimi kaldƒ±r
        if (this.selectedAnnotation && this.selectedAnnotation.id === annotation.id) {
            this.selectedAnnotation = null;
        }
        
        // Edit modundaysa √ßƒ±k
        if (this.editingAnnotation && this.editingAnnotation.id === annotation.id) {
            this.exitEditMode();
        }
        
        this.updateAnnotationList();
        this.redraw();
        
        this.showSuccess(`"${annotation.label}" silindi.`);
    }

    selectAnnotationAt(e) {
        const mousePos = this.getMousePos(e);
        const clickedAnnotation = this.getAnnotationAtPosition(mousePos);
        
        if (clickedAnnotation) {
            this.selectedAnnotation = clickedAnnotation;
        } else {
            this.selectedAnnotation = null;
        }
        
        this.updateAnnotationList();
        this.redraw();
    }

    getAnnotationAt(e) {
        const mousePos = this.getMousePos(e);
        return this.getAnnotationAtPosition(mousePos);
    }

    // Kilit noktasƒ±na tƒ±klama kontrol√º
    checkLockIconClick(e) {
        const mousePos = this.getMousePos(e);
        
        // T√ºm annotation'larƒ± kontrol et
        for (const annotation of this.annotations) {
            if (!annotation.label) continue;
            
            // Etiket pozisyonunu hesapla
            const labelPos = this.getLabelPosition(annotation);
            if (!labelPos) continue;
            
            // Kilit noktasƒ± pozisyonu - etiket kutusunun saƒüƒ±nda
            const lockPos = {
                x: labelPos.x + labelPos.width + 8,
                y: labelPos.y - labelPos.height + 2,
                radius: 4
            };
            
            // Tƒ±klama kilit noktasƒ± i√ßinde mi?
            const distance = Math.sqrt(
                Math.pow(mousePos.x - lockPos.x, 2) + 
                Math.pow(mousePos.y - lockPos.y, 2)
            );
            
            if (distance <= lockPos.radius + 5) { // 5px tolerance
                // Kilit durumunu deƒüi≈ütir
                annotation.locked = !annotation.locked;
                this.redraw();
                
                // Toast mesajƒ±
                const message = annotation.locked ? `"${annotation.label}" kilitlendi` : `"${annotation.label}" kilidi a√ßƒ±ldƒ±`;
                this.showInfo(message);
                
                return true;
            }
        }
        
        return false;
    }

    // Kilit sistemi kaldƒ±rƒ±ldƒ±

    // Etiket pozisyonunu hesapla - Sol √ºst handle'a g√∂re hizalanmƒ±≈ü
    // Etiket pozisyonu ayarlarƒ± i√ßin class seviyesinde deƒüi≈ükenler
    // Handle'ƒ±n tam ortasƒ± referans alƒ±nacak ≈üekilde ayarlandƒ±
    static labelPositionSettings = {
        fontSize: 14,         // px, etiket kutusu y√ºksekliƒüi
        textWidth: 120,       // px, etiket kutusu geni≈üliƒüi
        padding: 6,           // px, canvas kenarƒ±ndan bo≈üluk
        offsetX: 0,           // px, handle'ƒ±n x koordinatƒ± (ortalanmƒ±≈ü)
        offsetY: -4           // px, handle'ƒ±n y koordinatƒ± (kuyruƒüun alt ucu biraz yukarƒ±da)
    };

    getLabelPosition(annotation) {
        if (!annotation.label) return null;

        // 1) En sol √ºst handle'ƒ± bul veya kullan
        let handlePoint;
        if (annotation.points && annotation.points.length > 0) {
            if (annotation.topLeftHandleIndex !== undefined && annotation.topLeftHandleIndex < annotation.points.length) {
                handlePoint = annotation.points[annotation.topLeftHandleIndex];
                // console.log('‚úÖ Kayƒ±tlƒ± en sol √ºst handle kullanƒ±ldƒ±:', handlePoint, 'index:', annotation.topLeftHandleIndex);
            } else {
                let bestIndex = 0;
                handlePoint = annotation.points.reduce((best, p, index) => {
                    if (p.y < best.y) {
                        bestIndex = index;
                        return p;
                    }
                    if (p.y === best.y && p.x < best.x) {
                        bestIndex = index;
                        return p;
                    }
                    return best;
                }, annotation.points[0]);
                annotation.topLeftHandleIndex = bestIndex;
                // console.log('‚úÖ En sol √ºst handle hesaplandƒ± ve kaydedildi:', handlePoint, 'index:', bestIndex);
            }
        } else {
            handlePoint = { x: annotation.x || 0, y: annotation.y || 0 };
            console.log('‚úÖ Rectangle sol √ºst k√∂≈üe:', handlePoint);
        }

        // 2) Canvas koordinatlarƒ±na √ßevir (zoom'a g√∂re)
        const canvasHandle = this.imageToCanvas(handlePoint.x, handlePoint.y);
        console.log('üîç Canvas handle koordinatƒ±:', canvasHandle);

        // 3) Ayarlarƒ± class seviyesinden al
        const {
            fontSize,
            textWidth,
            padding,
            offsetX,
            offsetY
        } = this.constructor.labelPositionSettings;

        // 4) Label'ƒ± handle ile aynƒ± yatay eksende ve daha yakƒ±n hizala
        let x = canvasHandle.x + offsetX; // Handle'ƒ±n saƒüƒ±nda, offsetX kadar saƒüa
        let y = canvasHandle.y + offsetY; // Handle'ƒ±n y koordinatƒ± (merkez)

        // console.log('üîç Etiket pozisyonu (canvas):', { x, y });

        // 5) Canvas sƒ±nƒ±rlarƒ±nƒ± a≈ümamasƒ± i√ßin d√ºzelt
        const cw = this.canvas.width || (this.ctx && this.ctx.canvas && this.ctx.canvas.width) || 0;
        if (cw) {
            if (x + textWidth + padding > cw) x = Math.max(padding, cw - textWidth - padding);
            if (x < padding) x = padding;
        }

        return {
            x: x,
            y: y,
            width: textWidth,
            height: fontSize,
            handleCanvasPos: canvasHandle
        };
    }

    getAnnotationAtPosition(pos) {
        // T√ºm annotation'larƒ± topla ve i√ß i√ße ge√ßme durumunu kontrol et
        const overlappingAnnotations = [];
        
        for (let i = 0; i < this.annotations.length; i++) {
            const annotation = this.annotations[i];
            let isInside = false;
            let distance = Infinity;
            let area = 0;
            
            if (annotation.type === 'rectangle') {
                // Rectangle'ƒ± polygon'a d√∂n√º≈üt√ºr (eƒüer hen√ºz d√∂n√º≈üt√ºr√ºlmemi≈üse)
                this.annotationManager.convertRectangleToPolygon(annotation);
                
                // Polygon kontrol√º yap
                if (annotation.points && annotation.points.length > 0) {
                    isInside = this.isPointInPolygon(pos, annotation.points);
                    
                    if (isInside) {
                        // Polygon'un merkezine olan mesafeyi hesapla
                        const centerX = annotation.points.reduce((sum, point) => sum + point.x, 0) / annotation.points.length;
                        const centerY = annotation.points.reduce((sum, point) => sum + point.y, 0) / annotation.points.length;
                        distance = Math.sqrt((pos.x - centerX) ** 2 + (pos.y - centerY) ** 2);
                        // Polygon alanƒ±nƒ± hesapla
                        area = this.calculatePolygonArea(annotation.points);
                    }
                } else {
                    // Fallback: Eski rectangle kontrol√º
                    isInside = pos.x >= annotation.x && pos.x <= annotation.x + annotation.width &&
                              pos.y >= annotation.y && pos.y <= annotation.y + annotation.height;
                    
                    if (isInside) {
                        // Dikd√∂rtgenin merkezine olan mesafeyi hesapla
                        const centerX = annotation.x + annotation.width / 2;
                        const centerY = annotation.y + annotation.height / 2;
                        distance = Math.sqrt((pos.x - centerX) ** 2 + (pos.y - centerY) ** 2);
                        area = annotation.width * annotation.height;
                    }
                }
            } else if (annotation.type === 'polygon') {
                isInside = this.isPointInPolygon(pos, annotation.points);
                
                if (isInside) {
                    // Polygon'un merkezine olan mesafeyi hesapla
                    const centerX = annotation.points.reduce((sum, point) => sum + point.x, 0) / annotation.points.length;
                    const centerY = annotation.points.reduce((sum, point) => sum + point.y, 0) / annotation.points.length;
                    distance = Math.sqrt((pos.x - centerX) ** 2 + (pos.y - centerY) ** 2);
                    // Polygon alanƒ±nƒ± hesapla (basit yakla≈üƒ±m)
                    area = this.calculatePolygonArea(annotation.points);
                }
            }
            
            if (isInside) {
                overlappingAnnotations.push({
                    annotation: annotation,
                    index: i,
                    distance: distance,
                    area: area
                });
            }
        }
        
        if (overlappingAnnotations.length === 0) {
            return null;
        }
        
        // ƒ∞√ß i√ße ge√ßme durumunu kontrol et
        const nestedAnnotations = this.findNestedAnnotations(overlappingAnnotations);
        
        if (nestedAnnotations.length > 0) {
            // ƒ∞√ß i√ße ge√ßen annotation'lar varsa, en k√º√ß√ºk alanƒ± se√ß (en i√ßteki)
            nestedAnnotations.sort((a, b) => a.area - b.area);
            return nestedAnnotations[0].annotation;
        }
        
        // ƒ∞√ß i√ße ge√ßme yoksa, en yakƒ±n annotation'ƒ± se√ß
        overlappingAnnotations.sort((a, b) => a.distance - b.distance);
        return overlappingAnnotations[0].annotation;
    }

    findNestedAnnotations(annotations) {
        const nested = [];
        
        for (let i = 0; i < annotations.length; i++) {
            for (let j = 0; j < annotations.length; j++) {
                if (i !== j) {
                    const ann1 = annotations[i].annotation;
                    const ann2 = annotations[j].annotation;
                    
                    if (this.isAnnotationInside(ann1, ann2)) {
                        nested.push(annotations[i]);
                        break;
                    }
                }
            }
        }
        
        return nested;
    }

    isAnnotationInside(inner, outer) {
        if (inner.type === 'rectangle' && outer.type === 'rectangle') {
            return inner.x >= outer.x && 
                   inner.y >= outer.y && 
                   inner.x + inner.width <= outer.x + outer.width && 
                   inner.y + inner.height <= outer.y + outer.height;
        }
        // Diƒüer durumlar i√ßin basit alan kar≈üƒ±la≈ütƒ±rmasƒ±
        return inner.area < outer.area;
    }

    calculatePolygonArea(points) {
        let area = 0;
        for (let i = 0; i < points.length; i++) {
            const j = (i + 1) % points.length;
            area += points[i].x * points[j].y;
            area -= points[j].x * points[i].y;
        }
        return Math.abs(area) / 2;
    }

    isPointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) &&
                (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                inside = !inside;
            }
        }
        return inside;
    }


    getHandleAt(pos) {
        console.log('üîç getHandleAt √ßaƒürƒ±ldƒ±:', { pos, focusedAnnotation: this.focusedAnnotation?.id, selectedAnnotation: this.selectedAnnotation?.id });
        
        // Se√ßili annotation varsa handle'larƒ±nƒ± kontrol et
        if (this.focusedAnnotation) {
            console.log('üîç Focused annotation var, handle kontrol ediliyor...');
            const handle = this.annotationManager.getHandleAt(pos);
            console.log('üîç Focused annotation handle sonucu:', handle);
            return handle;
        }
        
        // Se√ßili annotation yoksa t√ºm annotation'larƒ± kontrol et
        console.log('üîç T√ºm annotation\'lar kontrol ediliyor...', this.annotations.length);
        for (const annotation of this.annotations) {
            console.log('üîç Annotation kontrol ediliyor:', annotation.id, annotation.type);
            // Annotation'ƒ± ge√ßici olarak se√ßili yap
            const originalSelected = this.selectedAnnotation;
            const originalFocused = this.focusedAnnotation;
            this.selectedAnnotation = annotation;
            this.focusedAnnotation = annotation;
            
            // AnnotationManager'daki getHandleAt fonksiyonunu kullan
            const handle = this.annotationManager.getHandleAt(pos);
            console.log('üîç Annotation handle sonucu:', handle);
            
            if (handle) {
                // Handle bulundu, annotation'ƒ± se√ßili yap
                console.log('‚úÖ Handle bulundu!', handle);
                return handle;
            } else {
                // Handle bulunamadƒ±, eski se√ßimi geri y√ºkle
                this.selectedAnnotation = originalSelected;
                this.focusedAnnotation = originalFocused;
            }
        }
        
        console.log('‚ùå Hi√ßbir annotation\'da handle bulunamadƒ±');
        return null;
    }

    getHandleForAnnotation(pos, annotation) {
        const handleSize = 12; // Sabit handle boyutu
        const tolerance = handleSize;

        // pos image koordinatlarƒ±nda, handle'lar canvas koordinatlarƒ±nda
        // pos'u canvas koordinatlarƒ±na d√∂n√º≈üt√ºr
        const canvasPos = this.imageToCanvas(pos.x, pos.y);

        if (annotation.type === 'rectangle') {
            // G√∂rsel koordinatlarƒ±nƒ± canvas koordinatlarƒ±na d√∂n√º≈üt√ºr
            const canvasCoords = this.imageToCanvas(annotation.x, annotation.y);
            const canvasWidth = annotation.width * this.zoom;
            const canvasHeight = annotation.height * this.zoom;
            
            // Rectangle i√ßin 8 handle (canvas koordinatlarƒ±nda)
            const handles = [
                { type: 'top-left', x: canvasCoords.x, y: canvasCoords.y },
                { type: 'top-center', x: canvasCoords.x + canvasWidth / 2, y: canvasCoords.y },
                { type: 'top-right', x: canvasCoords.x + canvasWidth, y: canvasCoords.y },
                { type: 'middle-right', x: canvasCoords.x + canvasWidth, y: canvasCoords.y + canvasHeight / 2 },
                { type: 'bottom-right', x: canvasCoords.x + canvasWidth, y: canvasCoords.y + canvasHeight },
                { type: 'bottom-center', x: canvasCoords.x + canvasWidth / 2, y: canvasCoords.y + canvasHeight },
                { type: 'bottom-left', x: canvasCoords.x, y: canvasCoords.y + canvasHeight },
                { type: 'middle-left', x: canvasCoords.x, y: canvasCoords.y + canvasHeight / 2 }
            ];

            for (let handle of handles) {
                if (Math.abs(canvasPos.x - handle.x) <= tolerance && Math.abs(canvasPos.y - handle.y) <= tolerance) {
                    return handle;
                }
            }
        } else if (annotation.type === 'polygon') {
            // Polygon noktalarƒ±nƒ± canvas koordinatlarƒ±na d√∂n√º≈üt√ºr
            const canvasPoints = annotation.points.map(point => 
                this.imageToCanvas(point.x, point.y)
            );
            
            // Polygon i√ßin nokta handle'larƒ±
            for (let i = 0; i < canvasPoints.length; i++) {
                const point = canvasPoints[i];
                if (Math.abs(canvasPos.x - point.x) <= tolerance && Math.abs(canvasPos.y - point.y) <= tolerance) {
                    return { type: 'polygon-point', index: i, x: point.x, y: point.y };
                }
            }
        }

        return null;
    }

    resizeAnnotation(annotation, handle, pos) {
        // AnnotationManager'daki resizeAnnotation fonksiyonunu kullan
        this.annotationManager.resizeAnnotation(annotation, handle, pos);
    }

    // Eski resize fonksiyonlarƒ± kaldƒ±rƒ±ldƒ± - AnnotationManager'daki fonksiyonlar kullanƒ±lƒ±yor

    handleWheel(e) {
        if (!this.image) return;
        
        e.preventDefault();
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const oldZoom = this.zoom;
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        
        this.zoom = Math.max(0.1, Math.min(5, this.zoom * zoomFactor));
        
        // Zoom merkezini mouse pozisyonuna ayarla
        const zoomRatio = this.zoom / oldZoom;
        this.panX = mouseX - (mouseX - this.panX) * zoomRatio;
        this.panY = mouseY - (mouseY - this.panY) * zoomRatio;
        
        this.redraw();
    }

    zoomIn() {
        if (!this.image) return;
        
        this.zoom = Math.min(5, this.zoom * 1.2);
        this.redraw();
        this.updateGridSize();
    }

    zoomOut() {
        if (!this.image) return;
        
        this.zoom = Math.max(0.1, this.zoom * 0.8);
        this.redraw();
        this.updateGridSize();
    }

    initializeCoordinateSystem() {
        if (!this.image) return;
        
        // Koordinat sistemini sƒ±fƒ±rla
        this.zoom = 1;
        this.panX = 0;
        this.panY = 0;
        
        console.log('Koordinat sistemi ba≈ülatƒ±ldƒ±:', {
            imageWidth: this.image.width,
            imageHeight: this.image.height,
            canvasWidth: this.canvas.width,
            canvasHeight: this.canvas.height
        });
    }

    fitToScreen() {
        if (!this.image) {
            this.showWarning('√ñnce bir resim y√ºkleyin!');
            return;
        }
        
        this.zoomToPhoto(); // Photo-only zoom kullan
    }



    preserveLockStates() {
        // Mevcut lock durumlarƒ±nƒ± kaydet
        if (!this.lockStates) {
            this.lockStates = new Map();
        }
        
        // T√ºm annotation'larƒ±n lock durumlarƒ±nƒ± kaydet
        this.annotations.forEach(annotation => {
            if (annotation.id) {
                this.lockStates.set(annotation.id, annotation.locked || false);
            }
        });
        
        // √áoklu fotoƒüraf modunda imageAnnotations'larƒ± da kontrol et
        if (this.isMultiImageMode && this.imageAnnotations) {
            this.imageAnnotations.forEach(imageAnnotations => {
                if (imageAnnotations) {
                    imageAnnotations.forEach(annotation => {
                        if (annotation.id) {
                            this.lockStates.set(annotation.id, annotation.locked || false);
                        }
                    });
                }
            });
        }
    }

    restoreLockStates() {
        // Kaydedilen lock durumlarƒ±nƒ± geri y√ºkle
        if (!this.lockStates) return;
        
        this.annotations.forEach(annotation => {
            if (annotation.id && this.lockStates.has(annotation.id)) {
                annotation.locked = this.lockStates.get(annotation.id);
            }
        });
        
        // √áoklu fotoƒüraf modunda imageAnnotations'larƒ± da g√ºncelle
        if (this.isMultiImageMode && this.imageAnnotations) {
            this.imageAnnotations.forEach(imageAnnotations => {
                if (imageAnnotations) {
                    imageAnnotations.forEach(annotation => {
                        if (annotation.id && this.lockStates.has(annotation.id)) {
                            annotation.locked = this.lockStates.get(annotation.id);
                        }
                    });
                }
            });
        }
    }

    updateAnnotationList() {
        const list = document.getElementById('annotationList');
        if (!list) return;
        
        console.log('updateAnnotationList √ßaƒürƒ±ldƒ±, annotations sayƒ±sƒ±:', this.annotations.length);
        
        // Mevcut lock durumlarƒ±nƒ± koru
        this.preserveLockStates();
        
        list.innerHTML = '';

        // T√ºm modlarda annotation'larƒ± g√∂ster
        if (this.isMultiImageMode && this.imageAnnotations) {
            // √áoklu fotoƒüraf modunda t√ºm fotoƒüraflardaki annotation'larƒ± g√∂ster
            let globalIndex = 1;
            let hasAnnotations = false;
            
            for (let imageIndex = 0; imageIndex < this.imageAnnotations.length; imageIndex++) {
                const imageAnnotations = this.imageAnnotations[imageIndex] || [];
                const imageData = this.images[imageIndex];
                
                imageAnnotations.forEach((annotation, localIndex) => {
                    hasAnnotations = true;
                    const item = document.createElement('div');
                    item.className = 'annotation-item';
                    
                    // Se√ßili annotation i√ßin √∂zel stil
                    if (this.selectedAnnotation === annotation) {
                        item.classList.add('selected');
                    }
                    
                    const annotationColor = annotation.color || '#2ecc71';
                    
                    // Eski annotation'lar i√ßin locked property'sini ekle (sadece kontrol i√ßin)
                    const isLocked = annotation.locked || false;
                    const lockIcon = isLocked ? 'üîí' : 'üîì';
                    const lockTitle = isLocked ? 'Kilidi A√ß' : 'Kilitle';
                    
                    item.innerHTML = `
                        <div class="annotation-content">
                            <div class="annotation-label">${annotation.label}</div>
                            <div class="annotation-actions">
                                <button class="lock-btn ${isLocked ? 'locked' : 'unlocked'}" onclick="event.stopPropagation(); labelingTool.toggleAnnotationLock(${annotation.id})" title="${lockTitle}">
                                    <span style="font-size: 12px;">${lockIcon}</span>
                                </button>
                                <button class="delete-btn" onclick="event.stopPropagation(); labelingTool.deleteAnnotation(${annotation.id})" title="Sil">
                                    <span style="font-size: 12px;">üóëÔ∏è</span>
                                </button>
                            </div>
                        </div>
                    `;
                    list.appendChild(item);
                    globalIndex++;
                });
            }
            
            // Eƒüer hi√ß annotation yoksa mesaj g√∂ster
            if (!hasAnnotations) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-state';
                emptyMessage.innerHTML = `
                    <div class="empty-state-content">
                        <i class="fas fa-vector-square" style="font-size: 48px; color: #7f8c8d; margin-bottom: 16px;"></i>
                        <h3 style="color: #95a5a6; margin: 0 0 8px 0;">Se√ßili Alan Bulunamadƒ±</h3>
                        <p style="color: #7f8c8d; margin: 0; font-size: 14px;">Hen√ºz hi√ß etiketlenmi≈ü alan yok. Resim √ºzerinde dikd√∂rtgen √ßizerek ba≈ülayƒ±n.</p>
                    </div>
                `;
                list.appendChild(emptyMessage);
            }
        } else {
            // Tek fotoƒüraf modunda mevcut annotation'larƒ± g√∂ster
            if (this.annotations.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-state';
                emptyMessage.innerHTML = `
                    <div class="empty-state-content">
                        <i class="fas fa-vector-square" style="font-size: 48px; color: #7f8c8d; margin-bottom: 16px;"></i>
                        <h3 style="color: #95a5a6; margin: 0 0 8px 0;">Se√ßili Alan Bulunamadƒ±</h3>
                        <p style="color: #7f8c8d; margin: 0; font-size: 14px;">Hen√ºz hi√ß etiketlenmi≈ü alan yok. Resim √ºzerinde dikd√∂rtgen √ßizerek ba≈ülayƒ±n.</p>
                    </div>
                `;
                list.appendChild(emptyMessage);
            } else {
                this.annotations.forEach((annotation, index) => {
                const item = document.createElement('div');
                item.className = 'annotation-item';
                
                // Se√ßili annotation i√ßin √∂zel stil
                if (this.selectedAnnotation === annotation) {
                    item.classList.add('selected');
                }
                
                const annotationColor = annotation.color || '#2ecc71';
                
                // Eski annotation'lar i√ßin locked property'sini ekle (sadece kontrol i√ßin)
                const isLocked = annotation.locked || false;
                const lockIcon = isLocked ? 'üîí' : 'üîì';
                const lockTitle = isLocked ? 'Kilidi A√ß' : 'Kilitle';
                
                item.innerHTML = `
                    <div class="annotation-content">
                        <div class="annotation-label">${annotation.label}</div>
                        <div class="annotation-actions">
                            <button class="lock-btn ${isLocked ? 'locked' : 'unlocked'}" onclick="event.stopPropagation(); labelingTool.toggleAnnotationLock(${annotation.id})" title="${lockTitle}">
                                <span style="font-size: 12px;">${lockIcon}</span>
                            </button>
                            <button class="delete-btn" onclick="event.stopPropagation(); labelingTool.deleteAnnotation(${annotation.id})" title="Sil">
                                <span style="font-size: 12px;">üóëÔ∏è</span>
                            </button>
                        </div>
                    </div>
                `;
                list.appendChild(item);
                });
            }
        }
        
        // Lock durumlarƒ±nƒ± geri y√ºkle
        this.restoreLockStates();
    }

    toggleAnnotationLock(id) {
        // Annotation'ƒ± bul
        let annotation = this.annotations.find(ann => ann.id === id);
        
        // √áoklu fotoƒüraf modunda imageAnnotations'da ara
        if (!annotation && this.isMultiImageMode && this.imageAnnotations) {
            for (let imageIndex = 0; imageIndex < this.imageAnnotations.length; imageIndex++) {
                if (this.imageAnnotations[imageIndex]) {
                    annotation = this.imageAnnotations[imageIndex].find(ann => ann.id === id);
                    if (annotation) break;
                }
            }
        }
        
        if (annotation) {
            annotation.locked = !annotation.locked;
            
            // Sadece lock durumunu deƒüi≈ütir, annotation'ƒ± se√ßme
            // this.selectedAnnotation = annotation; // Bu satƒ±rƒ± kaldƒ±rdƒ±k
            
            this.updateAnnotationList();
            this.redraw();
            
            // Toast bildirimi
            const message = annotation.locked ? 'Etiket kilitlendi' : 'Etiket kilidi a√ßƒ±ldƒ±';
            this.showToast(message, 'info');
        }
    }

    async deleteAnnotation(id) {
        // Silinecek annotation'ƒ± bul
        const annotationToDelete = this.annotations.find(ann => ann.id === id);
        console.log('Silinecek annotation:', annotationToDelete);
        console.log('Silme √∂ncesi annotations sayƒ±sƒ±:', this.annotations.length);
        
        // Kilitli annotation'ƒ± silmeyi engelle
        if (annotationToDelete && annotationToDelete.locked) {
            this.showToast('Bu etiket kilitli! Silmek i√ßin √∂nce kilidi a√ßƒ±n.', 'warning');
            return;
        }
        
        // Database'den sil (eƒüer database annotation ID'si varsa)
        if (annotationToDelete && annotationToDelete.dbId && window.labelingAuth) {
            try {
                const response = await window.labelingAuth.authenticatedRequest(
                    `${window.labelingAuth.baseURL}/annotations/${annotationToDelete.dbId}`,
                    { method: 'DELETE' }
                );
                
                if (!response.ok) {
                    console.error('‚ùå Database\'den etiket silinirken hata:', response.statusText);
                    this.showToast('Etiket database\'den silinemedi!', 'error');
                    return;
                }
                
                console.log('‚úÖ Etiket database\'den silindi');
            } catch (error) {
                console.error('‚ùå Database silme hatasƒ±:', error);
                this.showToast('Database baƒülantƒ± hatasƒ±!', 'error');
                return;
            }
        }
        
        // Silinecek annotation'ƒ±n etiketini kaydet
        const deletedLabel = annotationToDelete ? annotationToDelete.label : null;
        
        this.annotations = this.annotations.filter(ann => ann.id !== id);
        console.log('Silme sonrasƒ± annotations sayƒ±sƒ±:', this.annotations.length);
        this.isSaved = false; // Annotation silindi, kaydedilmemi≈ü
        
        // √áoklu fotoƒüraf modunda ImageManager √ºzerinden kaydet
        if (this.isMultiImageMode && window.imageManager) {
            this.saveCurrentImageAnnotations();
        } else {
            // Tek fotoƒüraf modunda projeyi kaydet
            this.saveProject();
        }
        
        // √áoklu fotoƒüraf modunda imageAnnotations'dan da sil
        if (this.isMultiImageMode && this.imageAnnotations) {
            for (let imageIndex = 0; imageIndex < this.imageAnnotations.length; imageIndex++) {
                if (this.imageAnnotations[imageIndex]) {
                    this.imageAnnotations[imageIndex] = this.imageAnnotations[imageIndex].filter(ann => ann.id !== id);
                }
            }
        }
        
        // Eƒüer silinen annotation se√ßiliyse, se√ßimi kaldƒ±r
        if (this.selectedAnnotation && this.selectedAnnotation.id === id) {
            this.selectedAnnotation = null;
        }
        
        // Eƒüer silinen annotation focuslanmƒ±≈üsa, focus'u kaldƒ±r
        if (this.focusedAnnotation && this.focusedAnnotation.id === id) {
            this.focusedAnnotation = null;
        }
        
        // Etiket listesini g√ºncelle - kullanƒ±lmayan etiketleri sil
        this.updateLabelListAfterDeletion(deletedLabel);
        
        this.updateAnnotationList();
        this.saveAllAnnotationsToDatabase(); // Basit API kullan
        this.redraw();
    }

    // ID ile annotation se√ß
    selectAnnotationById(id) {
        const annotation = this.annotations.find(ann => ann.id === id);
        if (annotation) {
            this.selectedAnnotation = annotation;
            this.updateAnnotationList();
            this.redraw();
        }
    }


    clearAll() {
        this.annotations = [];
        this.currentAnnotation = null;
        this.updateAnnotationList();
        this.redraw();
    }

    // Tek bir annotation'ƒ± database'e kaydet
    async saveCurrentAnnotationToDatabase(annotation) {
        console.log('üîß saveCurrentAnnotationToDatabase √ßaƒürƒ±ldƒ±:', annotation);
        console.log('üîß imageManager:', window.imageManager);
        console.log('üîß currentImage:', window.imageManager?.currentImage);
        console.log('üîß labelingAuth:', window.labelingAuth);
        
        if (!window.imageManager || !window.imageManager.currentImage || !window.labelingAuth) {
            console.log('‚ö†Ô∏è Database kaydetme i√ßin gerekli ko≈üullar saƒülanmadƒ±');
            console.log('  - imageManager:', !!window.imageManager);
            console.log('  - currentImage:', !!window.imageManager?.currentImage);
            console.log('  - labelingAuth:', !!window.labelingAuth);
            return;
        }

        try {
            const annotationData = {
                annotation_data: {
                    annotations: [annotation] // Array olarak g√∂nder
                }
            };

            const url = `${window.labelingAuth.baseURL}/images/${window.imageManager.currentImage.id}/annotations`;
            console.log('üì° API √ßaƒürƒ±sƒ± yapƒ±lƒ±yor:', url);
            console.log('üì° G√∂nderilen veri:', annotationData);

            const response = await window.labelingAuth.authenticatedRequest(url, {
                method: 'POST',
                body: JSON.stringify(annotationData),
                headers: { 'Content-Type': 'application/json' }
            });
            
            console.log('üì° API yanƒ±tƒ±:', response.status, response.statusText);

            if (response.ok) {
                const result = await response.json();
                // Database'den d√∂nen ID'yi annotation'a ekle
                annotation.dbId = result.id;
                console.log('‚úÖ Etiket database\'e kaydedildi:', result.id);
                
                // Proje istatistiklerini g√ºncelle
                this.updateProjectStats();
            } else {
                console.error('‚ùå Database\'e etiket kaydedilemedi:', response.statusText);
            }
        } catch (error) {
            console.error('‚ùå Database kaydetme hatasƒ±:', error);
        }
    }

    // BASIT API ILE ETIKET KAYDET
    async saveAllAnnotationsToDatabase() {
        if (!window.imageManager?.currentImage) return;
        
        try {
            const imageId = window.imageManager.currentImage.id;
            console.log(`üíæ ${this.annotations.length} etiket kaydediliyor...`);
            
            // Annotations'larƒ± backend formatƒ±na √ßevir
            const formattedAnnotations = this.annotations.map(annotation => {
                const formatted = {
                    id: annotation.id,
                    label: annotation.label,
                    type: annotation.type,
                    color: annotation.color,
                    x: annotation.x,
                    y: annotation.y,
                    width: annotation.width,
                    height: annotation.height
                };
                
                // Points bilgisi varsa ekle
                if (annotation.points && annotation.points.length > 0) {
                    formatted.points = annotation.points;
                    formatted.type = 'polygon'; // Points varsa polygon olarak i≈üaretle
                    console.log('üî∫ Polygon points kaydediliyor:', annotation.points);
                }
                
                return formatted;
            });

            await fetch(`http://localhost:3000/api/images/${imageId}/annotations`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ annotations: formattedAnnotations })
            });

            console.log('‚úÖ Etiketler kaydedildi');
        } catch (error) {
            console.error('‚ùå Kaydetme hatasƒ±:', error);
        }
    }

    // Proje istatistiklerini g√ºncelle
    async updateProjectStats() {
        if (!window.labelingAuth || !window.labelingAuth.getCurrentProject()) {
            // Kullanƒ±cƒ± giri≈ü yapmamƒ±≈ü veya proje se√ßilmemi≈ü, istatistikleri gizle
            const statsSection = document.getElementById('projectStatsSection');
            if (statsSection) {
                statsSection.style.display = 'none';
            }
            return;
        }

        try {
            // API'den proje istatistiklerini getir
            const projectId = window.labelingAuth.getCurrentProject();
            const response = await window.labelingAuth.authenticatedRequest(
                `${window.labelingAuth.baseURL}/projects/${projectId}/detailed-stats`
            );

            if (response.ok) {
                const stats = await response.json();
                
                // DOM elementlerini g√ºncelle
                const statsSection = document.getElementById('projectStatsSection');
                if (statsSection) {
                    statsSection.style.display = 'block';
                    
                    document.getElementById('totalImages').textContent = stats.project.totalImages || 0;
                    document.getElementById('labeledImages').textContent = stats.project.labeledImages || 0;
                    document.getElementById('totalLabels').textContent = stats.project.totalLabels || 0;
                    document.getElementById('completionRate').textContent = `${stats.project.completionRate || 0}%`;
                    
                    // Label sayƒ±larƒ±nƒ± g√ºncelle
                    const labelCountsContainer = document.getElementById('labelCounts');
                    if (labelCountsContainer && stats.labelCounts) {
                        labelCountsContainer.innerHTML = '';
                        
                        if (Object.keys(stats.labelCounts).length === 0) {
                            labelCountsContainer.innerHTML = '<div style="padding: 12px; text-align: center; color: var(--text-muted); font-size: 12px;">Hen√ºz etiket yok</div>';
                        } else {
                            Object.entries(stats.labelCounts)
                                .sort(([,a], [,b]) => b - a) // Sayƒ±ya g√∂re sƒ±rala
                                .forEach(([label, count]) => {
                                    const item = document.createElement('div');
                                    item.className = 'label-count-item';
                                    item.innerHTML = `
                                        <span class="label-count-name">${label}</span>
                                        <span class="label-count-value">${count}</span>
                                    `;
                                    labelCountsContainer.appendChild(item);
                                });
                        }
                    }
                }
            }
        } catch (error) {
            console.error('‚ùå Proje istatistikleri g√ºncellenirken hata:', error);
            // Hata durumunda istatistikleri gizle
            const statsSection = document.getElementById('projectStatsSection');
            if (statsSection) {
                statsSection.style.display = 'none';
            }
        }
    }

    redraw() {
        // Throttle redraw calls to prevent excessive rendering
        const now = Date.now();
        // B√ºy√ºk dosya sayƒ±larƒ± i√ßin daha agresif throttle
        const throttleTime = (this.images && this.images.length > 1000) ? 100 : 16; // 1000+ dosya i√ßin 10fps, diƒüerleri i√ßin 60fps
        if (!this.needsRedraw && (now - this.lastRedrawTime) < throttleTime) {
            return;
        }
        
        this.needsRedraw = false;
        this.lastRedrawTime = now;

        // CanvasManager mod√ºl√º ile √ßizim
        this.canvasManager.redraw();

        
        // Grid ve polygon noktalarƒ±nƒ± g√ºncelle
        if (this.showGrid) {
            this.updateGridSize();
        }
    }




    drawResizeHandles(annotation) {
        const handleSize = 8;
        this.ctx.fillStyle = '#ffffff';
        this.ctx.strokeStyle = '#000000';
        this.ctx.lineWidth = 1;

        // G√∂rsel koordinatlarƒ±nƒ± canvas koordinatlarƒ±na d√∂n√º≈üt√ºr
        const canvasCoords = this.imageToCanvasCoords(annotation.x, annotation.y);
        const canvasWidth = annotation.width * this.zoom;
        const canvasHeight = annotation.height * this.zoom;

        // 8 k√∂≈üe/kenar handle'ƒ± (canvas koordinatlarƒ±nda)
        const handles = [
            { x: canvasCoords.x, y: canvasCoords.y }, // Sol √ºst
            { x: canvasCoords.x + canvasWidth / 2, y: canvasCoords.y }, // √úst orta
            { x: canvasCoords.x + canvasWidth, y: canvasCoords.y }, // Saƒü √ºst
            { x: canvasCoords.x + canvasWidth, y: canvasCoords.y + canvasHeight / 2 }, // Saƒü orta
            { x: canvasCoords.x + canvasWidth, y: canvasCoords.y + canvasHeight }, // Saƒü alt
            { x: canvasCoords.x + canvasWidth / 2, y: canvasCoords.y + canvasHeight }, // Alt orta
            { x: canvasCoords.x, y: canvasCoords.y + canvasHeight }, // Sol alt
            { x: canvasCoords.x, y: canvasCoords.y + canvasHeight / 2 } // Sol orta
        ];

        handles.forEach(handle => {
            this.ctx.fillRect(
                handle.x - handleSize / 2, 
                handle.y - handleSize / 2, 
                handleSize, 
                handleSize
            );
            this.ctx.strokeRect(
                handle.x - handleSize / 2, 
                handle.y - handleSize / 2, 
                handleSize, 
                handleSize
            );
        });
    }

    drawPolygonHandles(annotation) {
        const handleSize = 8;
        this.ctx.fillStyle = '#ffffff';
        this.ctx.strokeStyle = '#000000';
        this.ctx.lineWidth = 1;

        // Polygon noktalarƒ±nƒ± canvas koordinatlarƒ±na d√∂n√º≈üt√ºr
        const canvasPoints = annotation.points.map(point => 
            this.imageToCanvasCoords(point.x, point.y)
        );

        canvasPoints.forEach(point => {
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, handleSize / 2, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.stroke();
        });
    }

    canvasToImageCoordinates(canvasX, canvasY) {
        // Canvas koordinatlarƒ±nƒ± orijinal resim koordinatlarƒ±na √ßevir
        // Mevcut zoom ve pan sistemini kullan
        const imageX = (canvasX - this.panX) / this.zoom;
        const imageY = (canvasY - this.panY) / this.zoom;
        return { x: imageX, y: imageY };
    }

    cropAnnotation(annotation) {
        if (!this.image) return null;

        // Yeni bir canvas olu≈ütur kƒ±rpma i√ßin
        const cropCanvas = document.createElement('canvas');
        const cropCtx = cropCanvas.getContext('2d');

        let cropData = null;

        if (annotation.type === 'rectangle') {
            // Eƒüer polygon points varsa, polygon'un bounding box'ƒ±nƒ± hesapla
            if (annotation.points && annotation.points.length > 0) {
                const xs = annotation.points.map(p => p.x);
                const ys = annotation.points.map(p => p.y);
                const topLeft = { x: Math.min(...xs), y: Math.min(...ys) };
                const bottomRight = { x: Math.max(...xs), y: Math.max(...ys) };
            } else {
                // Normal rectangle koordinatlarƒ±
            const topLeft = { x: annotation.x, y: annotation.y };
            const bottomRight = { 
                x: annotation.x + annotation.width, 
                y: annotation.y + annotation.height 
            };
            }

            const cropWidth = Math.abs(bottomRight.x - topLeft.x);
            const cropHeight = Math.abs(bottomRight.y - topLeft.y);

            cropCanvas.width = cropWidth;
            cropCanvas.height = cropHeight;

            // √ñnce arka planƒ± temizle (siyah alanlarƒ± √∂nlemek i√ßin)
            cropCtx.clearRect(0, 0, cropWidth, cropHeight);

            // Orijinal resimden kƒ±rp
            cropCtx.drawImage(
                this.image,
                Math.max(0, topLeft.x), Math.max(0, topLeft.y), cropWidth, cropHeight,
                0, 0, cropWidth, cropHeight
            );

            cropData = {
                type: 'rectangle',
                originalCoords: {
                    x: topLeft.x,
                    y: topLeft.y,
                    width: cropWidth,
                    height: cropHeight
                }
            };

        } else if (annotation.type === 'polygon') {
            // Polygon tam resim boyutunda, sadece polygon alanƒ±nƒ± g√∂ster
            console.log('üîç POLYGON CROP DEBUG:', {
                type: annotation.type,
                points: annotation.points
            });
            
            const imagePoints = annotation.points;
            
            // Canvas boyutunu TAM RESƒ∞M boyutuna ayarla
            cropCanvas.width = this.image.width;
            cropCanvas.height = this.image.height;

            // Polygon maskesi olu≈ütur (tam koordinatlar)
            cropCtx.save();
            cropCtx.beginPath();
            imagePoints.forEach((point, index) => {
                if (index === 0) {
                    cropCtx.moveTo(point.x, point.y);
                } else {
                    cropCtx.lineTo(point.x, point.y);
                }
            });
            cropCtx.closePath();
            cropCtx.clip();

            // Orijinal resmi tam boyutta √ßiz (sadece polygon alanƒ±nda g√∂r√ºnecek)
            cropCtx.drawImage(this.image, 0, 0);
            
            cropCtx.restore();

            cropData = {
                type: 'polygon',
                originalCoords: {
                    width: this.image.width,
                    height: this.image.height,
                    points: imagePoints
                }
            };
        }

        // Canvas'ƒ± base64'e √ßevir - Hem rectangle hem polygon i√ßin JPEG kullan (beyaz arka plan)
        const dataURL = cropCanvas.toDataURL('image/jpeg', 0.9);
        
        return {
            dataURL: dataURL,
            cropData: cropData,
            label: annotation.label
        };
    }

    async cropAndSaveAll() {
        try {
            // ImageManager kontrol√º
            if (!this.imageManager) {
                this.showError('ImageManager bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
                return;
            }

            if (!this.imageManager.currentProject) {
                this.showError('Aktif proje bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
                return;
            }

            // ExportManager kontrol√º
            if (!this.exportManager) {
                this.showError('ExportManager bulunamadƒ±! L√ºtfen sayfayƒ± yenileyin.');
                return;
            }

            // Yeni Save As y√∂ntemi ile kƒ±rp ve kaydet
            await this.exportManager.cropAndSaveAs();
            
        } catch (error) {
            console.error('Crop and Save All hatasƒ±:', error);
            this.showError('Kƒ±rpma i≈ülemi sƒ±rasƒ±nda hata olu≈ütu: ' + error.message);
        }
    }

    // Normal Save - Eski sistem gibi klas√∂r yapƒ±sƒ±
    async normalSave() {
        try {
            console.log('üíæ Normal Save ba≈ülatƒ±lƒ±yor...');
            
            // ImageManager kontrol√º
            let imageManager = this.imageManager || window.labelingTool?.imageManager;
            
            if (!imageManager) {
                console.error('‚ùå ImageManager bulunamadƒ±');
                this.showError('ImageManager bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
                return;
            }
            
            if (!imageManager.auth) {
                if (window.labelingTool?.auth) {
                    imageManager.auth = window.labelingTool.auth;
                } else if (window.labelingAuth) {
                    imageManager.auth = window.labelingAuth;
                } else {
                    this.showError('Auth objesi bulunamadƒ±! L√ºtfen sayfayƒ± yenileyin.');
                    return;
                }
            }

            if (!imageManager.currentProject) {
                console.error('‚ùå Aktif proje bulunamadƒ±');
                console.error('‚ùå imageManager detaylarƒ±:', {
                    currentProject: imageManager.currentProject,
                    totalImages: imageManager.totalImages,
                    currentImageIndex: imageManager.currentImageIndex
                });
                
                // Mevcut projeleri kontrol et
                console.log('üîç Mevcut projeler kontrol ediliyor...');
                try {
                    const projectsResponse = await imageManager.auth.makeRequest(`${imageManager.baseURL}/projects`);
                    if (projectsResponse.ok) {
                        const projects = await projectsResponse.json();
                        console.log('üìÅ Mevcut projeler:', projects);
                        
                        if (projects.length > 0) {
                            console.log('üìÅ ƒ∞lk proje se√ßiliyor:', projects[0]);
                            await imageManager.setProject(projects[0].id);
                            
                            // Tekrar kontrol et
                            if (imageManager.currentProject) {
                                console.log('‚úÖ Proje ba≈üarƒ±yla se√ßildi:', imageManager.currentProject);
                            } else {
                                this.showError('Proje se√ßilemedi! L√ºtfen manuel olarak bir proje se√ßin.');
                return;
            }
        } else {
                            this.showError('Hi√ß proje bulunamadƒ±! L√ºtfen √∂nce bir proje olu≈üturun.');
                            return;
                        }
                    } else {
                        this.showError('Projeler alƒ±namadƒ±! L√ºtfen sayfayƒ± yenileyin.');
                        return;
                    }
                } catch (error) {
                    console.error('‚ùå Proje kontrol hatasƒ±:', error);
                    this.showError('Proje kontrol edilemedi! L√ºtfen sayfayƒ± yenileyin.');
                return;
            }
        }

            this.showInfo('Normal formatƒ±nda dataset hazƒ±rlanƒ±yor...');

            // Proje verilerini al
            const projectId = imageManager.currentProject.id;
            const response = await imageManager.auth.makeRequest(
                `${imageManager.baseURL}/projects/${projectId}/export-data`
            );

            if (!response.ok) {
                this.showError('Proje verileri alƒ±namadƒ±!');
                return;
            }

            const projectData = await response.json();
            const { images, annotations } = projectData;
            
            if (images.length === 0) {
                this.showWarning('Projede hi√ß resim bulunamadƒ±!');
                return;
            }

            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const projectName = imageManager.currentProject.name || 'project';
            
            // Klas√∂r yapƒ±sƒ±: proje/images/images_name/etiketler/
            for (const image of images) {
                const imageAnnotations = annotations[image.id] || [];
                if (imageAnnotations.length === 0) continue;
                
                // Resim dosyasƒ±nƒ± al
                const imageResponse = await imageManager.auth.makeRequest(
                    `${imageManager.baseURL}/images/${image.id}/file`
                );
                
                if (!imageResponse.ok) continue;
                
                const imageBlob = await imageResponse.blob();
                const imageName = image.fileName || image.file_name;
                const imageNameWithoutExt = imageName.replace(/\.[^/.]+$/, "");
                
                // Her etiket i√ßin klas√∂r olu≈ütur
                for (let i = 0; i < imageAnnotations.length; i++) {
                    const annotation = imageAnnotations[i];
                    const labelName = annotation.label || annotation.label_name || 'unknown';
                    
                    
                    // Klas√∂r yapƒ±sƒ±: proje/images/images_name/etiketler/
                    const folderPath = `${projectName}/images/${imageNameWithoutExt}/etiketler/`;
                    const fileName = `${labelName}_${i + 1}.jpg`;
                    
                    // Kƒ±rpƒ±lmƒ±≈ü resmi olu≈ütur
                    const croppedImage = await this.cropImageFromAnnotation(imageBlob, annotation);
                    if (croppedImage) {
                        zip.file(`${folderPath}${fileName}`, croppedImage);
                    }
                }
            }
            
            // ZIP'i blob olarak olu≈ütur
            const content = await zip.generateAsync({type: "blob"});
            
            // Dosya adƒ±nƒ± olu≈ütur
            const fileName = `${projectName}_normal_dataset.zip`;
            
            // Kullanƒ±cƒ±dan dosya konumu se√ßmesini iste
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: fileName,
                        types: [{
                            description: 'ZIP dosyalarƒ±',
                            accept: {
                                'application/zip': ['.zip']
                            }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    
                    this.showInfo(`Normal dataset ba≈üarƒ±yla kaydedildi!\nProje: ${projectName}\nToplam resim: ${images.length}`);
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        this.showInfo('Kaydetme iptal edildi.');
                        return;
                    }
                    throw error;
                }
            } else {
                // Eski tarayƒ±cƒ±lar i√ßin fallback
                this.fallbackDownload(content, fileName);
            }
            
        } catch (error) {
            console.error('‚ùå Normal Save hatasƒ±:', error);
            this.showError('Normal save sƒ±rasƒ±nda hata olu≈ütu: ' + error.message);
        }
    }

    // Annotation'dan kƒ±rpƒ±lmƒ±≈ü resim olu≈ütur
    async cropImageFromAnnotation(imageBlob, annotation) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Polygon points varsa, tam resim boyutunda polygon mask ile kƒ±rp
                if (annotation.points && annotation.points.length >= 3) {
                    // Canvas tam resim boyutu
                    canvas.width = img.width;
                    canvas.height = img.height;

                    // Polygon maskesi olu≈ütur (tam koordinatlar)
                    ctx.save();
                    ctx.beginPath();
                    annotation.points.forEach((point, index) => {
                        if (index === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.closePath();
                    ctx.clip();

                    // Orijinal resmi tam boyutta √ßiz (sadece polygon alanƒ±nda g√∂r√ºnecek)
                    ctx.drawImage(img, 0, 0);
                    ctx.restore();
                } else {
                    // Normal rectangle crop
                    const x = annotation.x || 0;
                    const y = annotation.y || 0;
                    const width = annotation.width || 0;
                    const height = annotation.height || 0;
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Beyaz arka plan (JPEG i√ßin)
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, width, height);
                    
                    ctx.drawImage(img, x, y, width, height, 0, 0, width, height);
                }
                
                // Canvas'ƒ± blob'a √ßevir
                canvas.toBlob((blob) => {
                    resolve(blob);
                }, 'image/jpeg', 0.9);
            };
            
            img.onerror = () => {
                console.error('Resim y√ºklenemedi');
                resolve(null);
            };
            
            img.src = URL.createObjectURL(imageBlob);
        });
    }


    // Eski fonksiyon - kaldƒ±rƒ±labilir
    cropPolygonImage(ctx, img, annotation, x, y, width, height) {
        const points = annotation.points || [];
        if (points.length < 3) return;
        
        // √ñnce t√ºm canvas'ƒ± siyah yap
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, width, height);
        
        // Polygon path'ini olu≈ütur
        ctx.save();
        ctx.beginPath();
        
        // Polygon koordinatlarƒ±nƒ± relative yap (bounding box'a g√∂re)
        ctx.moveTo(points[0].x - x, points[0].y - y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x - x, points[i].y - y);
        }
        ctx.closePath();
        
        // Polygon'u clip olarak ayarla
        ctx.clip();
        
        // Orijinal resmi √ßiz (sadece polygon alanƒ±nda g√∂r√ºnecek)
        // Bounding box alanƒ±nƒ± orijinal resimden kƒ±rp ve √ßiz
        ctx.drawImage(img, x, y, width, height, 0, 0, width, height);
        
        ctx.restore();
    }

    // YOLO Export - Sƒ±fƒ±rdan yeni fonksiyon
    async yoloExport() {
        try {
            console.log('üöÄ YOLO Export ba≈ülatƒ±lƒ±yor...');
            console.log('üîç this.imageManager:', this.imageManager);
            console.log('üîç this.imageManager?.currentProject:', this.imageManager?.currentProject);
            console.log('üîç window.labelingTool:', window.labelingTool);
            console.log('üîç window.labelingTool?.imageManager:', window.labelingTool?.imageManager);
            
            // ImageManager kontrol√º - hem this.imageManager hem de window.labelingTool.imageManager'ƒ± kontrol et
            let imageManager = this.imageManager || window.labelingTool?.imageManager;
            
            console.log('üîç imageManager detaylarƒ±:', {
                imageManager: imageManager,
                auth: imageManager?.auth,
                baseURL: imageManager?.baseURL,
                currentProject: imageManager?.currentProject
            });
            
            if (!imageManager) {
                console.error('‚ùå ImageManager bulunamadƒ±');
                this.showError('ImageManager bulunamadƒ±! L√ºtfen √∂nce bir proje se√ßin.');
                return;
            }
            
            if (!imageManager.auth) {
                console.error('‚ùå ImageManager.auth bulunamadƒ±');
                console.log('üîç window.labelingAuth:', window.labelingAuth);
                console.log('üîç window.labelingTool:', window.labelingTool);
                console.log('üîç window.labelingTool?.auth:', window.labelingTool?.auth);
                
                // window.labelingTool.auth'u kullanmayƒ± dene
                if (window.labelingTool?.auth) {
                    console.log('üîÑ window.labelingTool.auth kullanƒ±lƒ±yor');
                    imageManager.auth = window.labelingTool.auth;
                } else if (window.labelingAuth) {
                    console.log('üîÑ window.labelingAuth kullanƒ±lƒ±yor');
                    imageManager.auth = window.labelingAuth;
                } else {
                    console.error('‚ùå Hi√ßbir auth objesi bulunamadƒ±');
                    this.showError('Auth objesi bulunamadƒ±! L√ºtfen sayfayƒ± yenileyin.');
                    return;
                }
            }

            if (!imageManager.currentProject) {
                console.error('‚ùå Aktif proje bulunamadƒ±');
                console.error('‚ùå imageManager detaylarƒ±:', {
                    currentProject: imageManager.currentProject,
                    totalImages: imageManager.totalImages,
                    currentImageIndex: imageManager.currentImageIndex
                });
                
                // Mevcut projeleri kontrol et
                console.log('üîç Mevcut projeler kontrol ediliyor...');
                try {
                    const projectsResponse = await imageManager.auth.makeRequest(`${imageManager.baseURL}/projects`);
                    if (projectsResponse.ok) {
                        const projects = await projectsResponse.json();
                        console.log('üìÅ Mevcut projeler:', projects);
                        
                        if (projects.length > 0) {
                            console.log('üìÅ ƒ∞lk proje se√ßiliyor:', projects[0]);
                            await imageManager.setProject(projects[0].id);
                            
                            // Tekrar kontrol et
                            if (imageManager.currentProject) {
                                console.log('‚úÖ Proje ba≈üarƒ±yla se√ßildi:', imageManager.currentProject);
                            } else {
                                this.showError('Proje se√ßilemedi! L√ºtfen manuel olarak bir proje se√ßin.');
                                return;
                            }
                        } else {
                            this.showError('Hi√ß proje bulunamadƒ±! L√ºtfen √∂nce bir proje olu≈üturun.');
                            return;
                        }
                    } else {
                        this.showError('Projeler alƒ±namadƒ±! L√ºtfen sayfayƒ± yenileyin.');
                        return;
                    }
                } catch (error) {
                    console.error('‚ùå Proje kontrol hatasƒ±:', error);
                    this.showError('Proje kontrol edilemedi! L√ºtfen sayfayƒ± yenileyin.');
                    return;
                }
            }

            console.log('‚úÖ ImageManager ve proje kontrol√º ba≈üarƒ±lƒ±');
            console.log('üìÅ Proje:', imageManager.currentProject);

            this.showInfo('YOLO formatƒ±nda dataset hazƒ±rlanƒ±yor...');

            // Proje verilerini al
            const projectId = imageManager.currentProject.id;
            console.log('üìä Proje verileri alƒ±nƒ±yor, Project ID:', projectId);

            // Tek API √ßaƒürƒ±sƒ± ile t√ºm proje verilerini al
            const response = await imageManager.auth.makeRequest(
                `${imageManager.baseURL}/projects/${projectId}/export-data`
            );

            if (!response.ok) {
                console.error('‚ùå Export endpoint hatasƒ±:', response.status);
                this.showError('Proje verileri alƒ±namadƒ±!');
                return;
            }

            const projectData = await response.json();
            const { images, annotations } = projectData;
            
            console.log('üìä Alƒ±nan resim sayƒ±sƒ±:', images.length);
            console.log('üìä Toplam annotation sayƒ±sƒ±:', Object.values(annotations).flat().length);

            if (images.length === 0) {
                this.showWarning('Projede hi√ß resim bulunamadƒ±!');
                return;
            }

            // ZIP dosyasƒ± olu≈ütur
            const zip = new JSZip();
            const projectName = imageManager.currentProject.name || 'dataset';
            const datasetFolder = zip.folder(projectName);
            
            // YOLO klas√∂r yapƒ±sƒ±nƒ± olu≈ütur
            const imagesFolder = datasetFolder.folder('images');
            const labelsFolder = datasetFolder.folder('labels');
            const trainImagesFolder = imagesFolder.folder('train');
            const valImagesFolder = imagesFolder.folder('val');
            const trainLabelsFolder = labelsFolder.folder('train');
            const valLabelsFolder = labelsFolder.folder('val');
            
            // Train/Val split hesapla (80/20)
            const shuffledImages = this.shuffleArray([...images]);
            const trainCount = Math.floor(shuffledImages.length * 0.8);
            const trainImages = shuffledImages.slice(0, trainCount);
            const valImages = shuffledImages.slice(trainCount);
            
            console.log(`üìä Train/Val split: ${trainImages.length}/${valImages.length}`);
            
            // Sƒ±nƒ±f mapping'i olu≈ütur
            const allLabels = new Set();
            Object.values(annotations).flat().forEach(annotation => {
                allLabels.add(annotation.label);
            });
            const classMapping = {};
            Array.from(allLabels).forEach((label, index) => {
                classMapping[label] = index;
            });
            
            console.log('üìä Sƒ±nƒ±f mapping:', classMapping);
            
            // Train set'i i≈üle
            for (const image of trainImages) {
                await this.addImageToYOLO(trainImagesFolder, trainLabelsFolder, image, annotations[image.id] || [], classMapping);
            }
            
            // Val set'i i≈üle
            for (const image of valImages) {
                await this.addImageToYOLO(valImagesFolder, valLabelsFolder, image, annotations[image.id] || [], classMapping);
            }
            
            // classes.txt dosyasƒ± olu≈ütur
            const classesContent = Array.from(allLabels).join('\n');
            datasetFolder.file('classes.txt', classesContent);
            
            // data.yaml dosyasƒ± olu≈ütur
            const yamlContent = this.createYOLOYaml(classMapping);
            datasetFolder.file('data.yaml', yamlContent);
            
            // ZIP'i blob olarak olu≈ütur
            const content = await zip.generateAsync({type: "blob"});
            
            // Dosya adƒ±nƒ± olu≈ütur
            const fileName = `${projectName}_yolo_dataset.zip`;
            
            // Kullanƒ±cƒ±dan dosya konumu se√ßmesini iste
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: fileName,
                        types: [{
                            description: 'ZIP dosyalarƒ±',
                            accept: {
                                'application/zip': ['.zip']
                            }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    
                    this.showInfo(`YOLO dataset ba≈üarƒ±yla kaydedildi!\nToplam: ${images.length} resim\nTrain: ${trainImages.length} resim\nVal: ${valImages.length} resim\nSƒ±nƒ±f sayƒ±sƒ±: ${allLabels.size}`);
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        this.showInfo('Kaydetme iptal edildi.');
                        return;
                    }
                    throw error;
                }
            } else {
                // Eski tarayƒ±cƒ±lar i√ßin fallback
                this.fallbackDownload(content, fileName);
            }
            
        } catch (error) {
            console.error('‚ùå YOLO Export hatasƒ±:', error);
            this.showError('YOLO export sƒ±rasƒ±nda hata olu≈ütu: ' + error.message);
        }
    }

    // Yardƒ±mcƒ± fonksiyonlar
    shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    async addImageToYOLO(imagesFolder, labelsFolder, image, imageAnnotations, classMapping) {
        // Resim dosyasƒ±nƒ± ekle
        const imageManager = this.imageManager || window.labelingTool?.imageManager;
        const imageResponse = await imageManager.auth.makeRequest(
            `${imageManager.baseURL}/images/${image.id}/file`
        );
        
        if (imageResponse.ok) {
            const imageBlob = await imageResponse.blob();
            imagesFolder.file(image.fileName, imageBlob);
        }

        // Label dosyasƒ±nƒ± olu≈ütur
        const labelContent = this.createYOLLabelFile(imageAnnotations, classMapping);
        const labelFileName = image.fileName.replace(/\.[^/.]+$/, '.txt');
        labelsFolder.file(labelFileName, labelContent);
    }

    createYOLLabelFile(annotations, classMapping) {
        let content = '';
        
        for (const annotation of annotations) {
            const classId = classMapping[annotation.label] || 0;
            
            // YOLO format: class_id center_x center_y width height (normalized)
            const centerX = (annotation.x + annotation.width / 2) / annotation.imageWidth;
            const centerY = (annotation.y + annotation.height / 2) / annotation.imageHeight;
            const width = annotation.width / annotation.imageWidth;
            const height = annotation.height / annotation.imageHeight;
            
            content += `${classId} ${centerX.toFixed(6)} ${centerY.toFixed(6)} ${width.toFixed(6)} ${height.toFixed(6)}\n`;
        }
        
        return content;
    }

    createYOLOYaml(classMapping) {
        const classes = Object.keys(classMapping).sort((a, b) => classMapping[a] - classMapping[b]);
        
        return `# YOLO Dataset Configuration
path: ./
train: images/train
val: images/val

nc: ${classes.length}
names: [${classes.map(c => `'${c}'`).join(', ')}]`;
    }

    fallbackDownload(content, fileName) {
        const blobUrl = URL.createObjectURL(content);
        const downloadLink = document.createElement('a');
        downloadLink.href = blobUrl;
        downloadLink.download = fileName;
        downloadLink.style.display = 'none';
        
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        
        setTimeout(() => {
            URL.revokeObjectURL(blobUrl);
        }, 1000);
        
        this.showInfo('Dosya indirildi! Tarayƒ±cƒ±nƒ±zƒ±n indirme klas√∂r√ºn√º kontrol edin.');
    }

    downloadBlob(blob, fileName) {
        const link = document.createElement('a');
        link.download = fileName;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
    }

    // ZIP dosyasƒ±nƒ± indir
    async saveToSelectedFolder(zip, projectName) {
        try {
            // ZIP dosyasƒ±nƒ± olu≈ütur
            const content = await zip.generateAsync({type: "blob"});
            
            // Direkt indirme yap
            this.downloadBlob(content, `${projectName}_dataset.zip`);
            this.showInfo('ZIP dosyasƒ± indirildi.');
            
        } catch (error) {
            console.error('ƒ∞ndirme hatasƒ±:', error);
            this.showError('ZIP dosyasƒ± olu≈üturulurken hata olu≈ütu.');
        }
    }

    generateMetadata(projectName) {
        if (this.isMultiImageMode) {
            // √áoklu fotoƒüraf modunda t√ºm annotation'larƒ± topla
            const allAnnotations = [];
            const labelCounts = {};
            
            for (let imageIndex = 0; imageIndex < (this.images ? this.images.length : 0); imageIndex++) {
                const imageData = this.images[imageIndex];
                const imageAnnotations = this.imageAnnotations[imageIndex] || [];
                
                imageAnnotations.forEach(annotation => {
                    const croppedImage = this.croppedImages.find(img => 
                        img.annotationId === annotation.id && img.imageIndex === imageIndex
                    );
                    
                    allAnnotations.push({
                        id: annotation.id,
                        label: annotation.label,
                        type: annotation.type,
                        imageIndex: imageIndex,
                        imageName: imageData.name,
                        coordinates: annotation.points && annotation.points.length > 0 ? {
                            points: annotation.points
                        } : {
                            x: annotation.x,
                            y: annotation.y,
                            width: annotation.width,
                            height: annotation.height
                        },
                        croppedImage: croppedImage ? {
                            fileName: croppedImage.fileName,
                            filePath: croppedImage.filePath,
                            originalCoords: croppedImage.cropData.originalCoords
                        } : null
                    });
                    
                    // Label sayƒ±larƒ±nƒ± hesapla
                    labelCounts[annotation.label] = (labelCounts[annotation.label] || 0) + 1;
                });
            }
            
            return {
                project: {
                    name: projectName,
                    created: new Date().toISOString(),
                    mode: 'multi-image',
                    totalImages: this.images ? this.images.length : 0,
                    images: this.images.map((img, index) => ({
                        index: index,
                        name: img.name,
                        width: img.image.width,
                        height: img.image.height,
                        annotationCount: this.imageAnnotations[index] ? this.imageAnnotations[index].length : 0
                    }))
                },
                annotations: allAnnotations,
                summary: {
                    totalAnnotations: allAnnotations.length,
                    totalCroppedImages: this.croppedImages.length,
                    totalImages: this.images ? this.images.length : 0,
                    labelCounts: labelCounts
                }
            };
        } else {
            // Tek fotoƒüraf modunda
            return {
                project: {
                    name: projectName,
                    created: new Date().toISOString(),
                    mode: 'single-image',
                    image: this.image ? {
                        width: this.image.width,
                        height: this.image.height
                    } : null
                },
                annotations: this.annotations.map(annotation => {
                    const croppedImage = this.croppedImages.find(img => img.annotationId === annotation.id);
                    return {
                        id: annotation.id,
                        label: annotation.label,
                        type: annotation.type,
                        coordinates: annotation.points && annotation.points.length > 0 ? {
                            points: annotation.points
                        } : {
                            x: annotation.x,
                            y: annotation.y,
                            width: annotation.width,
                            height: annotation.height
                        },
                        croppedImage: croppedImage ? {
                            fileName: croppedImage.fileName,
                            filePath: croppedImage.filePath,
                            originalCoords: croppedImage.cropData.originalCoords
                        } : null
                    };
                }),
                summary: {
                    totalAnnotations: this.annotations.length,
                    totalCroppedImages: this.croppedImages.length,
                    labelCounts: this.annotations.reduce((acc, ann) => {
                        acc[ann.label] = (acc[ann.label] || 0) + 1;
                        return acc;
                    }, {})
                }
            };
        }
    }

    // Export fonksiyonlarƒ± ExportManager'a ta≈üƒ±ndƒ±

    // Export fonksiyonlarƒ± ExportManager'a ta≈üƒ±ndƒ±


    // Utility manager instance
    get utilityManager() {
        if (!this._utilityManager) {
            this._utilityManager = new UtilityManager(this);
        }
        return this._utilityManager;
    }

    // Optimized image switching with caching
    async switchToImageOptimized(index) {
        // ImageManager'dan fotoƒüraflarƒ± al
        if (this.imageManager && this.imageManager.images) {
            this.images = this.imageManager.images;
        }
        
        if (!this.isMultiImageMode || index < 0 || index >= (this.images ? this.images.length : 0)) return;
        
        // Prevent multiple simultaneous switches
        if (this.isProcessing) return;
        this.isProcessing = true;

        // Loading g√∂stergesi ekle (sadece tƒ±klandƒ±ƒüƒ±nda)
        this.showImageLoadingIndicator(index);

        try {
            // Mevcut annotationlarƒ± kaydet
            if (this.imageAnnotations[this.currentImageIndex]) {
                this.imageAnnotations[this.currentImageIndex] = [...this.annotations];
            }

            // Mevcut filtreleri kaydet
            if (this.currentImageIndex >= 0) {
                this.imageFilters[this.currentImageIndex] = {
                    activeFilters: [...this.activeFilters],
                    activeTextures: [...this.activeTextures]
                };
            }

            // Yeni resme ge√ß
            this.currentImageIndex = index;
            
            // ImageManager'daki index'i de g√ºncelle
            if (this.imageManager) {
                this.imageManager.currentImageIndex = index;
            }
            
            const imageInfo = this.images[index];
            
            // Lazy loading: Eƒüer resim hen√ºz y√ºklenmemi≈üse y√ºkle
            if (!imageInfo.loaded || !imageInfo.image) {
                await this.loadFullImage(imageInfo);
            }
            
            // Cache'den resmi al veya y√ºkle
            const cacheKey = `image_${index}`;
            if (this.imageCache.has(cacheKey)) {
                this.image = this.imageCache.get(cacheKey);
            } else {
                this.image = imageInfo.image;
                this.imageCache.set(cacheKey, this.image);
            }
            
            // Bu resim i√ßin orijinal veriyi kaydet (eƒüer yoksa)
            this.saveOriginalImageData();
            
            // Bu resmin annotationlarƒ±nƒ± y√ºkle
            this.annotations = this.imageAnnotations[index] || [];
            
            // Bu resmin filtrelerini y√ºkle (debounced)
            this.debouncedLoadImageFilters(index);
            
            // UI'yi g√ºncelle (throttled)
            this.throttledUpdateUI();
            
            // Proje durumunu kaydet (resim deƒüi≈üti)
            this.saveProject();
            
        } finally {
            this.isProcessing = false;
            this.hideImageLoadingIndicator();
        }
    }

    showImageLoadingIndicator(index) {
        // Thumbnail'da loading g√∂stergesi ekle
        const thumbnails = document.querySelectorAll('.image-thumbnail');
        if (thumbnails[index]) {
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'image-loading-indicator';
            loadingIndicator.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            loadingIndicator.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: var(--accent-primary);
                font-size: 16px;
                z-index: 10;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 50%;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            thumbnails[index].appendChild(loadingIndicator);
        }
    }

    hideImageLoadingIndicator() {
        // T√ºm loading g√∂stergelerini kaldƒ±r
        const loadingIndicators = document.querySelectorAll('.image-loading-indicator');
        loadingIndicators.forEach(indicator => indicator.remove());
    }

    async loadFullImage(imageInfo) {
        if (imageInfo.loaded && imageInfo.image) {
            return; // Zaten y√ºklenmi≈ü
        }

        try {
            // Tam resmi y√ºkle
            const imageData = await this.loadImageFileOptimized(imageInfo.file);
            
            // ImageInfo'yu g√ºncelle
            imageInfo.image = imageData.image;
            imageInfo.dataURL = imageData.dataURL;
            imageInfo.loaded = true;
            
            // Cache'e ekle
            const cacheKey = `image_${imageInfo.index}`;
            this.imageCache.set(cacheKey, imageData.image);
            
        } catch (error) {
            console.error(`Tam resim y√ºkleme hatasƒ± (${imageInfo.name}):`, error);
            this.showWarning(`Resim y√ºklenemedi: ${imageInfo.name}`);
        }
    }

    // Debounced filter loading
    debouncedLoadImageFilters = this.utilityManager.debounce((index) => {
        this.loadImageFilters(index);
    }, 100, 'loadFilters');

    // Throttled UI update - b√ºy√ºk dosya sayƒ±larƒ± i√ßin daha agresif throttle
    throttledUpdateUI = this.utilityManager.throttle(() => {
        this.updateImageList();
        this.updateImageNavigation();
        this.updateAnnotationList();
        this.updateFilterUI();
        this.resizeCanvas();
        // Resim deƒüi≈ütiƒüinde otomatik ortala
        this.zoomToPhoto();
    }, (this.images && this.images.length > 1000) ? 200 : 50, 'updateUI');

    // Cache management
    clearImageCache() {
        this.imageCache.clear();
    }

    clearFilterCache() {
        this.filterCache.clear();
    }

    clearAllCaches() {
        this.clearImageCache();
        this.clearFilterCache();
    }

    // Memory management - call this periodically
    manageMemory() {
        // B√ºy√ºk dosya sayƒ±larƒ± i√ßin √ßok daha agresif bellek temizleme
        const maxCacheSize = (this.images && this.images.length > 1000) ? 5 : 20;
        
        // Clear old cache entries if memory usage is high
        if (this.imageCache.size > maxCacheSize) {
            const keys = Array.from(this.imageCache.keys());
            // Sadece mevcut resim hari√ß diƒüerlerini temizle
            const currentKey = `image_${this.currentImageIndex}`;
            for (let i = 0; i < keys.length; i++) {
                if (keys[i] !== currentKey) {
                this.imageCache.delete(keys[i]);
                }
            }
        }
        
        if (this.filterCache.size > 10) {
            const keys = Array.from(this.filterCache.keys());
            for (let i = 0; i < Math.floor(keys.length / 2); i++) {
                this.filterCache.delete(keys[i]);
            }
        }
        
        // Garbage collection'ƒ± tetikle
        if (this.images && this.images.length > 1000) {
            this.forceGarbageCollection();
        }
    }

    forceGarbageCollection() {
        // Bellek temizliƒüi i√ßin garbage collection'ƒ± tetikle
        if (window.gc) {
            window.gc();
        }
        
        // B√ºy√ºk objeleri temizle
        this.images.forEach((imageData, index) => {
            if (index !== this.currentImageIndex && imageData.image) {
                // Mevcut resim hari√ß diƒüerlerinin image objelerini temizle
                imageData.image = null;
                imageData.dataURL = null;
            }
        });
    }

    // Koordinat g√∂sterimi metodlarƒ±
    updateCoordinates(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.round(e.clientX - rect.left);
        const y = Math.round(e.clientY - rect.top);
        
        // Resim koordinatlarƒ±na d√∂n√º≈üt√ºr (zoom ve pan dikkate alƒ±narak)
        const imageX = Math.round((x - this.panX) / this.zoom);
        const imageY = Math.round((y - this.panY) / this.zoom);
        
        // Koordinatlarƒ± g√ºncelle
        const coordX = document.getElementById('coordX');
        const coordY = document.getElementById('coordY');
        
        if (coordX && coordY) {
            coordX.textContent = imageX;
            coordY.textContent = imageY;
        }
        
        // Fullscreen crosshair pozisyonunu g√ºncelle
        this.updateFullscreenCrosshairPosition(x, y);
    }

    showCoordinates() {
        const coordinatesDisplay = document.getElementById('coordinatesDisplay');
        if (coordinatesDisplay) {
            coordinatesDisplay.classList.remove('hidden');
        }
    }

    hideCoordinates() {
        const coordinatesDisplay = document.getElementById('coordinatesDisplay');
        if (coordinatesDisplay) {
            coordinatesDisplay.classList.add('hidden');
        }
    }

    // Grid Display Methods
    updateGridDisplay() {
        const gridOverlay = document.getElementById('gridOverlay');
        if (gridOverlay) {
            if (this.showGrid) {
                gridOverlay.style.display = 'block';
                this.updateGridSize();
            } else {
                gridOverlay.style.display = 'none';
            }
        }
    }

    updateGridSize() {
        if (!this.showGrid || !this.image) return;
        
        const majorGrid = document.getElementById('majorGrid');
        const minorGrid = document.getElementById('minorGrid');
        
        if (majorGrid && minorGrid) {
            // Zoom seviyesine g√∂re grid boyutunu ayarla
            const scaledGridSize = this.gridSize * this.zoom;
            const scaledMajorSize = this.majorGridSize * this.zoom;
            
            majorGrid.style.backgroundSize = `${scaledMajorSize}px ${scaledMajorSize}px`;
            minorGrid.style.backgroundSize = `${scaledGridSize}px ${scaledGridSize}px`;
        }
    }

    // Polygon sistemi kaldƒ±rƒ±ldƒ±

    // Polygon sistemi kaldƒ±rƒ±ldƒ±

    // Polygon sistemi kaldƒ±rƒ±ldƒ±

    // Polygon sistemi kaldƒ±rƒ±ldƒ±

    // Polygon sistemi kaldƒ±rƒ±ldƒ±

    // Canvas Cursor Update
    updateCanvasCursor() {
        this.canvas.style.cursor = 'crosshair';
    }

    // Polygon sistemi kaldƒ±rƒ±ldƒ±

    // Improved Photo-Only Zoom
    zoomToPhoto() {
        if (!this.image) return;
        
        const container = this.canvas.parentElement;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        
        const imageAspect = this.image.width / this.image.height;
        const containerAspect = containerWidth / containerHeight;
        
        let scale;
        if (imageAspect > containerAspect) {
            // Resim daha geni≈ü
            scale = (containerWidth - 40) / this.image.width;
        } else {
            // Resim daha y√ºksek
            scale = (containerHeight - 40) / this.image.height;
        }
        
        this.zoom = Math.min(scale, 1); // Maksimum %100 zoom
        this.panX = (containerWidth - this.image.width * this.zoom) / 2;
        this.panY = (containerHeight - this.image.height * this.zoom) / 2;
        
        this.redraw();
        this.updateGridSize();
    }

    // Fullscreen Crosshair Methods
    showFullscreenCrosshairCursor() {
        if (!this.showFullscreenCrosshair) return;
        
        const crosshair = document.getElementById('fullscreenCrosshair');
        if (crosshair) {
            crosshair.style.display = 'block';
            this.crosshairVisible = true;
        }
        
        // Canvas cursor'ƒ±nƒ± gizle
        this.canvas.style.cursor = 'none';
    }

    hideFullscreenCrosshairCursor() {
        const crosshair = document.getElementById('fullscreenCrosshair');
        if (crosshair) {
            crosshair.style.display = 'none';
            this.crosshairVisible = false;
        }
        
        // Canvas cursor'ƒ±nƒ± geri getir
        this.canvas.style.cursor = 'crosshair';
    }

    updateFullscreenCrosshairPosition(x, y) {
        if (!this.crosshairVisible) return;
        
        const crosshairVertical = document.getElementById('crosshairVertical');
        const crosshairHorizontal = document.getElementById('crosshairHorizontal');
        const crosshairCenter = document.getElementById('crosshairCenter');
        
        if (crosshairVertical && crosshairHorizontal && crosshairCenter) {
            // Dikey √ßizgiyi mouse X pozisyonuna ayarla
            crosshairVertical.style.left = `${x}px`;
            
            // Yatay √ßizgiyi mouse Y pozisyonuna ayarla
            crosshairHorizontal.style.top = `${y}px`;
            
            // Merkez noktayƒ± mouse pozisyonuna ayarla
            crosshairCenter.style.left = `${x}px`;
            crosshairCenter.style.top = `${y}px`;
        }
    }

    // Favori Etiket Fonksiyonlarƒ±
    showFavoriteLabelsModal() {
        const modal = document.getElementById('favoriteLabelsModal');
        const input = document.getElementById('newFavoriteInput');
        
        if (!modal) {
            console.error('‚ùå favoriteLabelsModal bulunamadƒ±!');
            return;
        }
        
        if (!input) {
            console.error('‚ùå newFavoriteInput bulunamadƒ±!');
            return;
        }
        
        modal.classList.add('show');
        input.focus();
        input.value = '';
        this.updateFavoriteLabelsList();
    }

    closeFavoriteLabelsModal() {
        const modal = document.getElementById('favoriteLabelsModal');
        if (modal) {
            modal.classList.remove('show');
        }
    }

    showShortcutsModal() {
        const modal = document.getElementById('shortcutsModal');
        if (modal) {
            modal.classList.add('show');
        }
    }

    closeShortcutsModal() {
        const modal = document.getElementById('shortcutsModal');
        if (modal) {
            modal.classList.remove('show');
        }
    }

    addFavoriteFromModal() {
        const input = document.getElementById('newFavoriteInput');
        const labelName = input.value.trim();
        
        if (!labelName) {
            this.showInfo('L√ºtfen etiket adƒ± girin!');
            return;
        }

        // Aynƒ± isimde favori var mƒ± kontrol et
        if (this.favoriteLabels.includes(labelName)) {
            this.showInfo('Bu etiket zaten favorilerde!');
            return;
        }

        this.favoriteLabels.push(labelName);
        this.updateFavoriteLabelsList();
        input.value = '';
        this.showInfo(`"${labelName}" favorilere eklendi!`);
    }

    removeFavoriteLabel(labelName) {
        const index = this.favoriteLabels.indexOf(labelName);
        if (index > -1) {
            this.favoriteLabels.splice(index, 1);
            this.updateFavoriteLabelsList();
            this.showInfo(`"${labelName}" favorilerden kaldƒ±rƒ±ldƒ±!`);
        }
    }

    updateFavoriteLabelsList() {
        const container = document.getElementById('favoriteLabelsList');
        if (!container) return;

        container.innerHTML = '';

        if (this.favoriteLabels.length === 0) {
            container.innerHTML = '<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 20px;">Hen√ºz favori etiket yok</div>';
            return;
        }

        this.favoriteLabels.forEach(labelName => {
            const favoriteItem = document.createElement('div');
            favoriteItem.className = 'favorite-item';
            favoriteItem.innerHTML = `
                <div class="favorite-item-content">
                    <i class="fas fa-star favorite-item-icon"></i>
                    <span class="favorite-item-name">#${labelName}</span>
                </div>
                <div class="favorite-item-actions">
                    <button class="favorite-item-btn edit" data-action="use" data-label="${labelName}">Kullan</button>
                    <button class="favorite-item-btn delete" data-action="delete" data-label="${labelName}">Sil</button>
                </div>
            `;
            
            // Event listeners
            const useBtn = favoriteItem.querySelector('[data-action="use"]');
            const deleteBtn = favoriteItem.querySelector('[data-action="delete"]');
            
            useBtn.addEventListener('click', () => {
                this.createLabelFromFavorite(labelName);
            });
            
            deleteBtn.addEventListener('click', () => {
                this.removeFavoriteLabel(labelName);
            });

            container.appendChild(favoriteItem);
        });
    }

    updateFavoriteLabelsDisplay() {
        const container = document.getElementById('favoriteLabels');
        if (!container) return;

        container.innerHTML = '';

        if (this.favoriteLabels.length === 0) {
            container.innerHTML = '<div style="color: var(--text-muted); font-style: italic; font-size: 0.9em;">Hen√ºz favori etiket yok</div>';
            return;
        }

        this.favoriteLabels.forEach(labelName => {
            const favoriteElement = document.createElement('div');
            favoriteElement.className = 'favorite-label';
            favoriteElement.innerHTML = `
                <i class="fas fa-star favorite-icon"></i>
                <span class="favorite-name">#${labelName}</span>
            `;
            
            // Favori etikete tƒ±klandƒ±ƒüƒ±nda direkt kaydet
            favoriteElement.addEventListener('click', () => {
                this.createLabelFromFavorite(labelName);
            });

            container.appendChild(favoriteElement);
        });
    }

    createLabelFromFavorite(labelName) {
        // Etiket ismi alanƒ±na favori etiket adƒ±nƒ± yaz
        const modalInput = document.getElementById('modalLabelInput');
        if (modalInput) {
            modalInput.value = labelName;
        }
        
        // Otomatik olarak Enter'a basmƒ±≈ü gibi davran (confirmNewLabel √ßaƒüƒ±r)
        this.confirmNewLabel();
    }

    showFavoriteLabelsInModal() {
        this.updateFavoriteLabelsDisplay();
    }

    // Etiket ismini harf durumuna g√∂re d√∂n√º≈üt√ºr ve bo≈üluklarƒ± _ ile deƒüi≈ütir
    transformLabelName(labelName) {
        if (!labelName) return labelName;
        
        // √ñnce bo≈üluklarƒ± _ ile deƒüi≈ütir
        let transformedName = labelName.replace(/\s+/g, '_');
        
        // Sonra harf durumunu uygula
        switch (this.labelCaseMode) {
            case 'uppercase':
                return transformedName.toUpperCase();
            case 'lowercase':
                return transformedName.toLowerCase();
            case 'original':
            default:
                return transformedName;
        }
    }

    // Export klas√∂r√º se√ß
    async selectExportFolder() {
        try {
            // File System Access API kullanarak klas√∂r se√ß
            if ('showDirectoryPicker' in window) {
                const directoryHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'documents'
                });
                this.exportFolderPath = directoryHandle.name;
                
                // Input alanƒ±nƒ± g√ºncelle
                const folderPathInput = document.getElementById('exportFolderPath');
                if (folderPathInput) {
                    folderPathInput.value = this.exportFolderPath;
                }
                
                this.showInfo(`Export klas√∂r√º se√ßildi: ${this.exportFolderPath}`);
                return true;
            } else {
                // Fallback: Basit input dialog
                const folderPath = prompt('Export klas√∂r√º yolunu girin (√∂rn: C:\\Users\\Kullanici\\Desktop\\Export):');
                if (folderPath && folderPath.trim()) {
                    this.exportFolderPath = folderPath.trim();
                    
                    // Input alanƒ±nƒ± g√ºncelle
                    const folderPathInput = document.getElementById('exportFolderPath');
                    if (folderPathInput) {
                        folderPathInput.value = this.exportFolderPath;
                    }
                    
                    this.showInfo(`Export klas√∂r√º ayarlandƒ±: ${this.exportFolderPath}`);
                    return true;
                }
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Export klas√∂r se√ßimi kullanƒ±cƒ± tarafƒ±ndan iptal edildi');
                return false;
            } else {
                console.error('Export klas√∂r se√ßim hatasƒ±:', error);
                this.showWarning('Export klas√∂r se√ßimi sƒ±rasƒ±nda hata olu≈ütu. L√ºtfen tekrar deneyin.');
                return false;
            }
        }
        return false;
    }

    // Kƒ±rp klas√∂r√º se√ß
    async selectCropFolder() {
        try {
            // File System Access API kullanarak klas√∂r se√ß
            if ('showDirectoryPicker' in window) {
                const directoryHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'documents'
                });
                this.cropFolderPath = directoryHandle.name;
                this.showInfo(`Kƒ±rp klas√∂r√º se√ßildi: ${this.cropFolderPath}`);
                return true;
            } else {
                // Fallback: Basit input dialog
                const folderPath = prompt('Kƒ±rp klas√∂r√º yolunu girin (√∂rn: C:\\Users\\Kullanici\\Desktop\\Kƒ±rpƒ±lan_Resimler):');
                if (folderPath && folderPath.trim()) {
                    this.cropFolderPath = folderPath.trim();
                    this.showInfo(`Kƒ±rp klas√∂r√º ayarlandƒ±: ${this.cropFolderPath}`);
                    return true;
                }
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Klas√∂r se√ßimi kullanƒ±cƒ± tarafƒ±ndan iptal edildi');
                return false;
            } else {
                console.error('Klas√∂r se√ßim hatasƒ±:', error);
                this.showWarning('Klas√∂r se√ßimi sƒ±rasƒ±nda hata olu≈ütu. L√ºtfen tekrar deneyin.');
                return false;
            }
        }
        return false;
    }

}



// Uygulamayƒ± ba≈ülat - DOM y√ºklendikten sonra
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM y√ºklendi, LabelingTool ba≈ülatƒ±lƒ±yor...');
    
    // Modal elementlerini kontrol et
    console.log('üîç Modal elementleri kontrol ediliyor...');
    console.log('üîç labelModal:', document.getElementById('labelModal'));
    console.log('üîç favoriteLabelsModal:', document.getElementById('favoriteLabelsModal'));
    console.log('üîç T√ºm modal elementleri:', document.querySelectorAll('.modal'));
    
    // Hava durumu filtrelerini kontrol et
    console.log('üå§Ô∏è Hava durumu filtreleri kontrol ediliyor...');
    const weatherFilters = document.querySelectorAll('input[data-filter]');
    console.log('üå§Ô∏è Bulunan hava durumu filtreleri:', weatherFilters.length);
    weatherFilters.forEach((filter, index) => {
        console.log(`üå§Ô∏è Filtre ${index + 1}:`, filter.getAttribute('data-filter'));
    });
    
    console.log('LabelingAuth zaten y√ºklenmi≈ü');
    window.labelingTool = new LabelingTool();
    console.log('LabelingTool ba≈ülatƒ±ldƒ±');
});

// Eƒüer DOM zaten y√ºklendiyse hemen ba≈ülat
if (document.readyState === 'loading') {
    // DOM hen√ºz y√ºkleniyor, yukarƒ±daki event listener √ßalƒ±≈üacak
} else {
    // DOM zaten y√ºklendi
    console.log('DOM zaten y√ºkl√º, LabelingTool ba≈ülatƒ±lƒ±yor...');
    
    // Hava durumu filtrelerini kontrol et
    console.log('üå§Ô∏è Hava durumu filtreleri kontrol ediliyor (DOM zaten y√ºkl√º)...');
    const weatherFilters = document.querySelectorAll('input[data-filter]');
    console.log('üå§Ô∏è Bulunan hava durumu filtreleri:', weatherFilters.length);
    weatherFilters.forEach((filter, index) => {
        console.log(`üå§Ô∏è Filtre ${index + 1}:`, filter.getAttribute('data-filter'));
    });
    
    console.log('LabelingAuth zaten y√ºklenmi≈ü');
    window.labelingTool = new LabelingTool();
    console.log('LabelingTool ba≈ülatƒ±ldƒ±');
}
