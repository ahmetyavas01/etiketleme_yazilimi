const express = require('express');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const http = require('http');
const socketIo = require('socket.io');
const multer = require('multer');
const database = require('./database-simple');
const auth = require('./auth');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});
const PORT = 3000;

// Multer konfig√ºrasyonu
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const uploadsDir = path.join(__dirname, '../uploads');
        if (!fs.existsSync(uploadsDir)) {
            fs.mkdirSync(uploadsDir, { recursive: true });
        }
        cb(null, uploadsDir);
    },
    filename: (req, file, cb) => {
        // Orijinal dosya adƒ±nƒ± koru ama g√ºvenli hale getir
        const timestamp = Date.now();
        const originalName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');
        cb(null, `${timestamp}_${originalName}`);
    }
});

const upload = multer({ 
    storage: storage,
    limits: { fileSize: 50 * 1024 * 1024 }, // 50MB limit
    fileFilter: (req, file, cb) => {
        // Sadece resim dosyalarƒ±nƒ± kabul et
        if (file.mimetype.startsWith('image/')) {
            cb(null, true);
        } else {
            cb(new Error('Sadece resim dosyalarƒ± kabul edilir!'), false);
        }
    }
});

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' })); // JSON limitini 50MB'a √ßƒ±kar

// Health check endpoint
app.get('/api/health', (req, res) => {
    // Ger√ßek IP adresini al
    const os = require('os');
    const networkInterfaces = os.networkInterfaces();
    let serverIP = 'localhost';
    
    // En uygun IP adresini bul (localhost olmayan)
    for (const interfaceName in networkInterfaces) {
        const interfaces = networkInterfaces[interfaceName];
        for (const iface of interfaces) {
            if (iface.family === 'IPv4' && !iface.internal) {
                serverIP = iface.address;
                break;
            }
        }
        if (serverIP !== 'localhost') break;
    }
    
    res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        message: 'Etiketleme Sistemi Server √ßalƒ±≈üƒ±yor',
        ip: serverIP
    });
});

// Server ba≈ülatma endpoint'i
app.post('/api/server/start', (req, res) => {
    console.log('üöÄ Dashboard\'dan server ba≈ülatma isteƒüi alƒ±ndƒ±');
    
    try {
        const { spawn } = require('child_process');
        const path = require('path');
        const os = require('os');
        
        // Server'ƒ±n zaten √ßalƒ±≈üƒ±p √ßalƒ±≈ümadƒ±ƒüƒ±nƒ± kontrol et
        const isRunning = process.uptime() > 0;
        
        if (isRunning) {
            return res.json({
                success: true,
                message: 'Server zaten √ßalƒ±≈üƒ±yor',
                alreadyRunning: true
            });
        }
        
        // Platform'a g√∂re server ba≈ülatma script'ini se√ß
        let startScript;
        if (os.platform() === 'win32') {
            // Windows i√ßin batch script
            startScript = path.join(__dirname, '../scripts/start-server.bat');
        } else {
            // Mac/Linux i√ßin shell script
            startScript = path.join(__dirname, '../scripts/start-server.sh');
        }
        
        console.log('üìú Server ba≈ülatma script\'i:', startScript);
        
        // Server ba≈ülatma script'ini √ßalƒ±≈ütƒ±r
        let serverProcess;
        if (os.platform() === 'win32') {
            serverProcess = spawn('cmd', ['/c', startScript], {
                detached: true,
                stdio: 'ignore',
                cwd: path.join(__dirname, '..')
            });
        } else {
            serverProcess = spawn('bash', [startScript], {
                detached: true,
                stdio: 'ignore',
                cwd: path.join(__dirname, '..')
            });
        }
        
        serverProcess.unref();
        
        console.log('‚úÖ Server ba≈ülatma script\'i √ßalƒ±≈ütƒ±rƒ±ldƒ±, PID:', serverProcess.pid);
        
        res.json({
            success: true,
            message: 'Server ba≈ülatma script\'i √ßalƒ±≈ütƒ±rƒ±ldƒ±',
            pid: serverProcess.pid,
            platform: os.platform()
        });
        
    } catch (error) {
        console.error('‚ùå Server ba≈ülatma hatasƒ±:', error);
        res.status(500).json({
            success: false,
            error: 'Server ba≈ülatƒ±lamadƒ±: ' + error.message
        });
    }
});

// Static files
app.use('/dashboard', express.static(path.join(__dirname, '../dashboard')));
app.use('/app', express.static(path.join(__dirname, '../labeling-app')));
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// Sadece orijinal path'leri serve et - uploads klas√∂r√º yok

// CORS preflight i√ßin OPTIONS request'i handle et
app.options('/api/files/*', (req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    res.status(200).end();
});

// Orijinal dosya path'lerini serve et (fallback)
app.get('/api/files/*', async (req, res) => {
    try {
        // URL'den dosya path'ini al
        const filePath = req.params[0]; // * wildcard'dan gelen path
        const fileName = decodeURIComponent(filePath);
        
        console.log('üìÅ Dosya isteniyor:', fileName);
        
        // √ñnce veritabanƒ±ndan dosyayƒ± bul ve doƒürudan file_path'i kullan
        let foundPath = null;
        
        try {
            // Dosyayƒ± veritabanƒ±nda ara
            const image = await database.getImageByFileName(fileName);
            if (image && image.file_path) {
                // G√∂reli path'i mutlak path'e d√∂n√º≈üt√ºr
                let absoluteFilePath = image.file_path;
                if (image.file_path.startsWith('~')) {
                    const os = require('os');
                    absoluteFilePath = path.join(os.homedir(), image.file_path.substring(2));
                } else if (!path.isAbsolute(image.file_path)) {
                    absoluteFilePath = path.join(process.cwd(), image.file_path);
                }
                
                console.log('üîç Veritabanƒ±ndan dosya yolu alƒ±ndƒ±:', image.file_path);
                console.log('üîç Mutlak path:', absoluteFilePath);
                
                if (fs.existsSync(absoluteFilePath)) {
                    console.log('‚úÖ Dosya veritabanƒ± yolunda bulundu:', absoluteFilePath);
                    foundPath = absoluteFilePath;
                } else {
                    console.log('‚ö†Ô∏è Dosya veritabanƒ± yolunda bulunamadƒ±, fallback klas√∂rlerde arayacak:', absoluteFilePath);
                }
            }
        } catch (dbError) {
            console.log('‚ö†Ô∏è Veritabanƒ± hatasƒ±, fallback klas√∂rlerde arayacak:', dbError.message);
        }
        
        // Eƒüer veritabanƒ± yolunda bulunamadƒ±ysa, fallback klas√∂rlerde ara
        if (!foundPath) {
            const searchPaths = [
                path.join(__dirname, '../uploads', fileName),
                path.join(__dirname, '../plaka_deneme/images/train', fileName),
                path.join(__dirname, '../plaka_deneme/images/val', fileName)
            ];
            
            for (const searchPath of searchPaths) {
                console.log('üîç Fallback klas√∂rde arƒ±yor:', searchPath);
                if (fs.existsSync(searchPath)) {
                    console.log('‚úÖ Fallback klas√∂rde bulundu:', searchPath);
                    foundPath = searchPath;
                    break;
                }
            }
        }
        
        if (!foundPath) {
            console.log('‚ùå Dosya hi√ßbir klas√∂rde bulunamadƒ±:', fileName);
            return res.status(404).json({ error: 'Dosya bulunamadƒ±' });
        }
        
        // Dosya istatistiklerini al
        const stats = fs.statSync(foundPath);
        if (!stats.isFile()) {
            console.log('‚ùå Ge√ßersiz dosya:', foundPath);
            return res.status(400).json({ error: 'Ge√ßersiz dosya' });
        }
        
        // MIME type belirle
        const ext = path.extname(foundPath).toLowerCase();
        const mimeTypes = {
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.png': 'image/png',
            '.gif': 'image/gif',
            '.bmp': 'image/bmp',
            '.webp': 'image/webp'
        };
        
        const mimeType = mimeTypes[ext] || 'application/octet-stream';
        
        // CORS headers
        res.setHeader('Access-Control-Allow-Origin', '*');
        res.setHeader('Access-Control-Allow-Methods', 'GET');
        res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
        
        // Content-Type header'ƒ±nƒ± set et
        res.setHeader('Content-Type', mimeType);
        res.setHeader('Content-Length', stats.size);
        
        // Dosyayƒ± stream et
        const fileStream = fs.createReadStream(foundPath);
        fileStream.pipe(res);
        
        console.log('‚úÖ Dosya serve edildi:', foundPath);
        
    } catch (error) {
        console.error('‚ùå Dosya serve hatasƒ±:', error);
        res.status(500).json({ error: 'Dosya okuma hatasƒ±' });
    }
});

// File Upload Route (multer middleware √∂nce √ßalƒ±≈ümalƒ±)
app.post('/api/upload', upload.single('image'), (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: 'Dosya y√ºklenmedi' });
        }
        
        const fileInfo = {
            fileName: req.file.originalname,
            savedName: req.file.filename,
            filePath: `/uploads/${req.file.filename}`,
            fullPath: req.file.path,
            size: req.file.size,
            mimeType: req.file.mimetype,
            uploadedAt: new Date().toISOString(),
            uploadedBy: 'system'
        };
        
        console.log('üì§ Dosya y√ºklendi:', fileInfo);
        
        res.json({
            success: true,
            message: 'Dosya ba≈üarƒ±yla y√ºklendi',
            file: fileInfo
        });
        
    } catch (error) {
        console.error('‚ùå Dosya y√ºkleme hatasƒ±:', error);
        res.status(500).json({ error: 'Dosya y√ºkleme hatasƒ±: ' + error.message });
    }
});

// Auth Routes
app.post('/api/auth/login', async (req, res) => {
    const { username } = req.body;
    
    if (!username) {
        return res.status(400).json({ error: 'Kullanƒ±cƒ± adƒ± gerekli' });
    }

    const result = await auth.login(username);
    if (result.success) {
        res.json(result);
    } else {
        res.status(401).json(result);
    }
});

// User Management Routes (Admin only)
app.get('/api/users', async (req, res) => {
    const result = await auth.getAllUsers();
    if (result.success) {
        res.json(result.users);
    } else {
        res.status(500).json({ error: result.error });
    }
});

app.post('/api/users', async (req, res) => {
    const { username, role } = req.body;
    
    if (!username) {
        return res.status(400).json({ error: 'Kullanƒ±cƒ± adƒ± gerekli' });
    }

    const result = await auth.createUser(username, role);
    if (result.success) {
        res.json(result.user);
    } else {
        res.status(400).json({ error: result.error });
    }
});

// Project Routes
app.get('/api/projects', async (req, res) => {
    try {
        const projects = await database.getAllProjects();
        
        // Her proje i√ßin etiket sayƒ±sƒ±nƒ± hesapla
        const projectsWithStats = await Promise.all(
            projects.map(async (project) => {
                try {
                    const stats = await database.getProjectAnnotationStats(project.id);
                    return {
                        ...project,
                        labelCount: stats.totalAnnotations || 0
                    };
                } catch (error) {
                    console.error(`Proje ${project.id} etiket sayƒ±sƒ± hesaplanamadƒ±:`, error);
                    return {
                        ...project,
                        labelCount: 0
                    };
                }
            })
        );
        
        res.json(projectsWithStats);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Basit proje √∂zeti
app.get('/api/projects/summary', async (req, res) => {
    try {
        console.log('üìä Proje √∂zeti endpoint √ßaƒürƒ±ldƒ±');
        const projects = await database.getAllProjects();
        console.log('üìä Projeler alƒ±ndƒ±:', projects.length);
        
        // Her proje i√ßin etiket sayƒ±sƒ±nƒ± hesapla
        const projectSummaries = await Promise.all(
            projects.map(async (project) => {
                try {
                    // Proje i√ßin annotation istatistikleri al
                    const annotations = await database.getProjectAnnotationStats(project.id);
                    
                    let labelCount = 0;
                    if (annotations && annotations.length > 0) {
                        annotations.forEach(annotation => {
                            if (annotation.annotation_data && annotation.annotation_data.annotations) {
                                labelCount += annotation.annotation_data.annotations.length;
                            }
                        });
                    }
                    
                    return {
                        id: project.id,
                        name: project.name,
                        labelCount: labelCount,
                        totalImages: project.total_images || 0,
                        description: project.description
                    };
                } catch (error) {
                    console.error(`‚ùå Proje ${project.id} √∂zeti alƒ±nƒ±rken hata:`, error);
                    return {
                        id: project.id,
                        name: project.name,
                        labelCount: 0,
                        totalImages: project.total_images || 0,
                        description: project.description
                    };
                }
            })
        );
        
        console.log('üìä √ñzet hazƒ±rlandƒ±:', projectSummaries.length);
        res.json(projectSummaries);
    } catch (error) {
        console.error('‚ùå Proje √∂zeti hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Etiket analizi endpoint'i
app.get('/api/analytics/labels', async (req, res) => {
    try {
        console.log('üìä Etiket analizi endpoint √ßaƒürƒ±ldƒ±');
        const projects = await database.getAllProjects();
        
        let totalLabels = 0;
        const projectAnalytics = [];
        
        for (const project of projects) {
            const images = await database.getProjectImages(project.id);
            const projectData = {
                id: project.id,
                name: project.name,
                totalImages: images.length,
                images: []
            };
            
            for (const image of images) {
                try {
                    const annotations = await database.getImageAnnotations(image.id);
                    const imageData = {
                        id: image.id,
                        fileName: image.file_path.split('/').pop(),
                        filePath: image.file_path,
                        isLabeled: image.is_labeled,
                        annotations: []
                    };
                    
                    if (annotations && annotations.length > 0) {
                        annotations.forEach(annotation => {
                            try {
                                if (annotation.annotation_data && annotation.annotation_data.annotations) {
                                    annotation.annotation_data.annotations.forEach(ann => {
                                        const label = ann.label || 'Unknown';
                                        imageData.annotations.push({
                                            label: label,
                                            coordinates: ann.coordinates
                                        });
                                        totalLabels++;
                                    });
                                }
                            } catch (error) {
                                console.error(`‚ùå Annotation parse hatasƒ± (image ${image.id}):`, error);
                            }
                        });
                    }
                    
                    projectData.images.push(imageData);
                } catch (error) {
                    console.error(`‚ùå Image annotations hatasƒ± (image ${image.id}):`, error);
                    // Hata olsa bile bo≈ü image data ekle
                    projectData.images.push({
                        id: image.id,
                        fileName: image.file_path.split('/').pop(),
                        filePath: image.file_path,
                        isLabeled: image.is_labeled,
                        annotations: []
                    });
                }
            }
            
            projectAnalytics.push(projectData);
        }
        
        // Genel etiket istatistikleri
        const labelCounts = {};
        projectAnalytics.forEach(project => {
            project.images.forEach(image => {
                image.annotations.forEach(annotation => {
                    const label = annotation.label;
                    labelCounts[label] = (labelCounts[label] || 0) + 1;
                });
            });
        });
        
        const labelStats = Object.entries(labelCounts).map(([label, count]) => ({
            label: label,
            count: count,
            percentage: totalLabels > 0 ? Math.round((count / totalLabels) * 100) : 0
        })).sort((a, b) => b.count - a.count);
        
        console.log('üìä Analytics response:', {
            totalLabels,
            labelStatsCount: labelStats.length,
            projectsCount: projectAnalytics.length
        });
        
        res.json({
            totalLabels: totalLabels,
            labelStats: labelStats,
            projects: projectAnalytics
        });
    } catch (error) {
        console.error('‚ùå Etiket analizi hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/projects/:id', async (req, res) => {
    try {
        const project = await database.getProject(req.params.id);
        if (project) {
            res.json(project);
        } else {
            res.status(404).json({ error: 'Proje bulunamadƒ±' });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Proje silme
app.delete('/api/projects/:id', async (req, res) => {
    try {
        const projectId = req.params.id;
        console.log('üóëÔ∏è Proje siliniyor:', projectId);
        
        // √ñnce projenin var olup olmadƒ±ƒüƒ±nƒ± kontrol et
        const project = await database.getProject(projectId);
        if (!project) {
            return res.status(404).json({ error: 'Proje bulunamadƒ±' });
        }
        
        // Projeyi sil (cascade delete ile ilgili t√ºm veriler silinecek)
        await database.deleteProject(projectId);
        
        console.log('‚úÖ Proje silindi:', project.name);
        res.json({ message: 'Proje ba≈üarƒ±yla silindi', projectName: project.name });
    } catch (error) {
        console.error('‚ùå Proje silme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// T√ºm fotoƒüraflarƒ±n is_labeled durumunu g√ºncelle
app.post('/api/update-labeled-status', async (req, res) => {
    try {
        console.log('üîÑ T√ºm fotoƒüraflarƒ±n is_labeled durumu g√ºncelleniyor...');
        const updatedCount = await database.updateAllImagesLabeledStatus();
        console.log(`‚úÖ ${updatedCount} fotoƒürafƒ±n is_labeled durumu g√ºncellendi`);
        
        res.json({
            success: true,
            message: `${updatedCount} fotoƒürafƒ±n is_labeled durumu g√ºncellendi`,
            updatedCount: updatedCount
        });
    } catch (error) {
        console.error('‚ùå is_labeled durumu g√ºncelleme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/projects', async (req, res) => {
    const { name, description, folder_path } = req.body;
    
    if (!name || !folder_path) {
        return res.status(400).json({ error: 'Proje adƒ± ve klas√∂r yolu gerekli' });
    }

    try {
        console.log('üìÅ Yeni proje olu≈üturuluyor:', { name, folder_path });
        
        // Path'i kontrol et ve gerekirse mutlak path'e d√∂n√º≈üt√ºr
        let absolutePath = folder_path;
        if (folder_path.startsWith('~')) {
            const os = require('os');
            absolutePath = path.join(os.homedir(), folder_path.substring(2));
        } else if (!path.isAbsolute(folder_path)) {
            // G√∂reli path ise, mevcut √ßalƒ±≈üma dizinine g√∂re mutlak path olu≈ütur
            absolutePath = path.resolve(folder_path);
        }
        
        // Projeyi olu≈ütur (tam path ile)
        const project = await database.createProject(name, description, absolutePath, 1); // Admin user ID
        console.log('‚úÖ Proje olu≈üturuldu:', project.id);
        
        // Klas√∂r yolunu kontrol et
        if (!fs.existsSync(absolutePath)) {
            console.log('‚ö†Ô∏è Klas√∂r bulunamadƒ±, fotoƒüraf tarama atlandƒ±:', absolutePath);
            return res.json({
                ...project,
                message: 'Proje olu≈üturuldu, ancak klas√∂r bulunamadƒ±. Fotoƒüraflarƒ± manuel olarak tarayƒ±n.',
                imagesScanned: false
            });
        }

        // Desteklenen resim formatlarƒ±
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.tif'];
        
        // Klas√∂rdeki dosyalarƒ± oku (mutlak path kullan)
        const files = fs.readdirSync(absolutePath);
        const imageFiles = files.filter(file => {
            const ext = path.extname(file).toLowerCase();
            return imageExtensions.includes(ext);
        }).sort(); // Alfabetik sƒ±ralama

        console.log(`üì∏ ${imageFiles.length} resim dosyasƒ± bulundu`);

        // Yeni fotoƒüraflarƒ± ekle
        let addedCount = 0;
        for (let i = 0; i < imageFiles.length; i++) {
            const fileName = imageFiles[i];
            const filePath = path.join(absolutePath, fileName);
            const stats = fs.statSync(filePath);
            
            try {
                // Fotoƒüraf boyutlarƒ±nƒ± hesapla
                const sharp = require('sharp');
                const metadata = await sharp(filePath).metadata();
                const width = metadata.width;
                const height = metadata.height;
                
                await database.addImage(
                    project.id,
                    filePath,
                    fileName,
                    stats.size,
                    path.extname(fileName).toLowerCase(),
                    i,
                    width,
                    height
                );
                addedCount++;
            } catch (error) {
                console.error(`‚ùå Fotoƒüraf eklenemedi: ${fileName}`, error);
            }
        }

        // Proje toplam fotoƒüraf sayƒ±sƒ±nƒ± g√ºncelle
        await database.updateProjectImageCount(project.id, addedCount);

        // T√ºm fotoƒüraflarƒ±n is_labeled durumunu g√ºncelle
        await database.updateAllImagesLabeledStatus();
        console.log('‚úÖ T√ºm fotoƒüraflarƒ±n is_labeled durumu g√ºncellendi');

        console.log(`‚úÖ ${addedCount} fotoƒüraf projeye eklendi`);

        res.json({
            ...project,
            message: `${addedCount} fotoƒüraf ba≈üarƒ±yla eklendi`,
            imagesScanned: true,
            total_images: addedCount
        });
        
    } catch (error) {
        console.error('‚ùå Proje olu≈üturma hatasƒ±:', error);
        res.status(400).json({ error: error.message });
    }
});

app.put('/api/projects/:id', async (req, res) => {
    const { data } = req.body;
    
    try {
        console.log('üìù Proje g√ºncelleniyor:', req.params.id);
        console.log('üìä Veri boyutu:', JSON.stringify(data).length, 'karakter');
        console.log('üìã Annotation sayƒ±sƒ±:', data.annotations ? data.annotations.length : 0);
        
        const result = await database.updateProject(req.params.id, data);
        console.log('‚úÖ Proje g√ºncellendi:', req.params.id);
        
        // Real-time g√ºncelleme: Proje odasƒ±ndaki t√ºm kullanƒ±cƒ±lara yeni veriyi broadcast et
        io.to(`project_${req.params.id}`).emit('projectUpdated', {
            projectId: req.params.id,
            data: data,
            updatedBy: 'system',
            timestamp: new Date().toISOString()
        });
        
        res.json(result);
    } catch (error) {
        console.error('‚ùå Proje g√ºncelleme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

app.delete('/api/projects/:id', async (req, res) => {
    try {
        const result = await database.deleteProject(req.params.id);
        res.json(result);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Fotoƒüraf tarama ve ekleme endpoint'i
app.post('/api/projects/:id/scan-images', async (req, res) => {
    try {
        const projectId = req.params.id;
        const project = await database.getProject(projectId);
        
        if (!project) {
            return res.status(404).json({ error: 'Proje bulunamadƒ±' });
        }

        const folderPath = project.folder_path;
        
        // Path'i kontrol et ve gerekirse mutlak path'e d√∂n√º≈üt√ºr
        let absolutePath = folderPath;
        if (folderPath.startsWith('~')) {
            const os = require('os');
            absolutePath = path.join(os.homedir(), folderPath.substring(2));
        } else if (!path.isAbsolute(folderPath)) {
            // G√∂reli path ise, mevcut √ßalƒ±≈üma dizinine g√∂re mutlak path olu≈ütur
            absolutePath = path.resolve(folderPath);
        }
        
        if (!fs.existsSync(absolutePath)) {
            return res.status(400).json({ error: 'Klas√∂r bulunamadƒ±: ' + absolutePath });
        }

        console.log('üìÅ Klas√∂r taranƒ±yor:', absolutePath);
        
        // Desteklenen resim formatlarƒ±
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.tif'];
        
        // Klas√∂rdeki dosyalarƒ± oku
        const files = fs.readdirSync(absolutePath);
        const imageFiles = files.filter(file => {
            const ext = path.extname(file).toLowerCase();
            return imageExtensions.includes(ext);
        }).sort(); // Alfabetik sƒ±ralama

        console.log(`üì∏ ${imageFiles.length} resim dosyasƒ± bulundu`);

        // Mevcut fotoƒüraflarƒ± temizle
        await database.db.run('DELETE FROM images WHERE project_id = ?', [projectId]);

        // Yeni fotoƒüraflarƒ± ekle
        let addedCount = 0;
        for (let i = 0; i < imageFiles.length; i++) {
            const fileName = imageFiles[i];
            const filePath = path.join(absolutePath, fileName);
            const stats = fs.statSync(filePath);
            
            try {
                await database.addImage(
                    projectId,
                    filePath,
                    fileName,
                    stats.size,
                    path.extname(fileName).toLowerCase(),
                    i
                );
                addedCount++;
            } catch (error) {
                console.error(`‚ùå Fotoƒüraf eklenemedi: ${fileName}`, error);
            }
        }

        // Proje toplam fotoƒüraf sayƒ±sƒ±nƒ± g√ºncelle
        await database.updateProjectImageCount(projectId, addedCount);

        console.log(`‚úÖ ${addedCount} fotoƒüraf veritabanƒ±na eklendi`);

        res.json({
            success: true,
            message: `${addedCount} fotoƒüraf ba≈üarƒ±yla eklendi`,
            total_images: addedCount,
            folder_path: folderPath
        });

    } catch (error) {
        console.error('‚ùå Fotoƒüraf tarama hatasƒ±:', error);
        res.status(500).json({ error: 'Fotoƒüraf tarama hatasƒ±: ' + error.message });
    }
});

// Proje fotoƒüraflarƒ±nƒ± listele
app.get('/api/projects/:id/images', async (req, res) => {
    try {
        const projectId = req.params.id;
        const images = await database.getProjectImages(projectId);
        res.json(images);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Mevcut fotoƒüraflarƒ±n boyutlarƒ±nƒ± g√ºncelle
app.post('/api/update-image-dimensions', async (req, res) => {
    try {
        console.log('üìè Fotoƒüraf boyutlarƒ± g√ºncelleniyor...');
        
        // T√ºm fotoƒüraflarƒ± al
        const images = await database.getAllImages();
        console.log(`üìè ${images.length} fotoƒüraf bulundu`);
        
        let updatedCount = 0;
        const sharp = require('sharp');
        
        for (const image of images) {
            try {
                // Eƒüer boyut bilgisi yoksa g√ºncelle
                if (!image.width || !image.height) {
                    const metadata = await sharp(image.file_path).metadata();
                    const width = metadata.width;
                    const height = metadata.height;
                    
                    // Database'de g√ºncelle
                    await database.updateImageDimensions(image.id, width, height);
                    updatedCount++;
                    console.log(`‚úÖ ${image.file_name}: ${width}x${height}`);
                }
            } catch (error) {
                console.error(`‚ùå ${image.file_name} boyut g√ºncellenemedi:`, error.message);
            }
        }
        
        res.json({
            success: true,
            message: `${updatedCount} fotoƒürafƒ±n boyutu g√ºncellendi`,
            updatedCount: updatedCount,
            totalImages: images.length
        });
        
    } catch (error) {
        console.error('‚ùå Boyut g√ºncelleme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Export i√ßin optimize edilmi≈ü proje verileri
app.get('/api/projects/:id/export-data', async (req, res) => {
    try {
        const projectId = req.params.id;
        console.log('üìä Export verileri alƒ±nƒ±yor, Project ID:', projectId);
        
        // Proje bilgileri
        const project = await database.getProject(projectId);
        if (!project) {
            return res.status(404).json({ error: 'Proje bulunamadƒ±' });
        }
        
        // T√ºm resimleri al
        const images = await database.getProjectImages(projectId);
        console.log('üìä Alƒ±nan resim sayƒ±sƒ±:', images.length);
        
        // Her resim i√ßin annotation'larƒ± ayrƒ± ayrƒ± al (normal API'den)
        const annotations = {};
        for (const image of images) {
            try {
                // Normal API'den annotation'larƒ± al
                const imageAnnotations = await database.allQuery(
                    'SELECT * FROM annotations WHERE image_id = ? ORDER BY created_at ASC',
                    [image.id]
                );
                console.log(`üîç Resim ${image.id} i√ßin annotation'lar:`, imageAnnotations ? imageAnnotations.length : 'undefined');
                
                if (imageAnnotations && imageAnnotations.length > 0) {
                    const allAnnotations = [];
                    
                    imageAnnotations.forEach(ann => {
                        // Annotation verilerini parse et
                        let annotationData;
                        try {
                            annotationData = typeof ann.annotation_data === 'string' 
                                ? JSON.parse(ann.annotation_data) 
                                : ann.annotation_data;
                        } catch (error) {
                            console.warn(`Annotation ${ann.id} parse edilemedi:`, error);
                            return;
                        }
                        
                        if (annotationData && annotationData.annotations && annotationData.annotations.length > 0) {
                            // T√ºm annotation'larƒ± i≈üle
                            annotationData.annotations.forEach(annData => {
                                console.log('üîç AnnData:', annData);
                                const result = {
                                    id: annData.id || ann.id, // annotation'ƒ±n kendi id'sini kullan
                                    label: annData.label,
                                    label_name: annData.label,
                                    type: annData.type || 'rectangle',
                                    color: annData.color || '#007AFF',
                                    x: parseFloat(annData.x) || 0,
                                    y: parseFloat(annData.y) || 0,
                                    width: parseFloat(annData.width) || 0,
                                    height: parseFloat(annData.height) || 0,
                                    points: (annData.points && Array.isArray(annData.points)) ? 
                                        annData.points.map(point => ({
                                            x: parseFloat(point.x) || 0,
                                            y: parseFloat(point.y) || 0
                                        })) : [],
                                    imageWidth: parseFloat(image.width) || 1280,
                                    imageHeight: parseFloat(image.height) || 720
                                };
                                console.log('üîç Result:', result);
                                allAnnotations.push(result);
                            });
                        }
                    });
                    
                    annotations[image.id] = allAnnotations;
                } else {
                    annotations[image.id] = [];
                }
            } catch (error) {
                console.error(`Resim ${image.id} annotation'larƒ± alƒ±namadƒ±:`, error);
                annotations[image.id] = [];
            }
        }
        
        console.log('üìä Toplam annotation sayƒ±sƒ±:', Object.values(annotations).flat().length);
        
        // Weather filter bilgilerini al
        const weatherFilters = {};
        for (const image of images) {
            try {
                const filterData = await database.getImageWeatherFilter(image.id);
                if (filterData && filterData.filter_data) {
                    weatherFilters[image.id] = {
                        type: filterData.filter_data.type,
                        data: filterData.filter_data
                    };
                }
            } catch (error) {
                console.warn(`Resim ${image.id} i√ßin weather filter alƒ±namadƒ±:`, error);
            }
        }
        
        console.log('üå§Ô∏è Weather filter sayƒ±sƒ±:', Object.keys(weatherFilters).length);
        
        res.json({
            project: project,
            images: images,
            annotations: annotations,
            weatherFilters: weatherFilters
        });
        
    } catch (error) {
        console.error('‚ùå Export verileri hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Belirli resim dosyasƒ±nƒ± getir
app.get('/api/images/:id/file', async (req, res) => {
    try {
        const imageId = req.params.id;
        console.log('üìÅ Dosya isteniyor:', imageId);
        
        const image = await database.getImageById(imageId);
        if (!image) {
            return res.status(404).json({ error: 'Resim bulunamadƒ±' });
        }
        
        const filePath = image.file_path;
        console.log('üìÅ Dosya yolu:', filePath);
        
        // G√∂reli path'i mutlak path'e d√∂n√º≈üt√ºr
        let absoluteFilePath = filePath;
        if (filePath.startsWith('~')) {
            const os = require('os');
            absoluteFilePath = path.join(os.homedir(), filePath.substring(2));
        } else if (!path.isAbsolute(filePath)) {
            absoluteFilePath = path.join(process.cwd(), filePath);
        }
        
        console.log('üìÅ Mutlak dosya yolu:', absoluteFilePath);
        
        // Dosya var mƒ± kontrol et
        if (!fs.existsSync(absoluteFilePath)) {
            console.error('‚ùå Dosya bulunamadƒ±:', absoluteFilePath);
            return res.status(404).json({ error: 'Dosya bulunamadƒ±' });
        }
        
        // Dosya t√ºr√ºn√º belirle
        const ext = path.extname(filePath).toLowerCase();
        let contentType = 'image/jpeg';
        
        switch (ext) {
            case '.jpg':
            case '.jpeg':
                contentType = 'image/jpeg';
                break;
            case '.png':
                contentType = 'image/png';
                break;
            case '.gif':
                contentType = 'image/gif';
                break;
            case '.webp':
                contentType = 'image/webp';
                break;
            default:
                contentType = 'application/octet-stream';
        }
        
        console.log('‚úÖ Dosya serve edildi:', absoluteFilePath);
        res.setHeader('Content-Type', contentType);
        res.sendFile(absoluteFilePath);
        
    } catch (error) {
        console.error('‚ùå Dosya serve hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Belirli pozisyondaki fotoƒürafƒ± getir
app.get('/api/projects/:id/images/:position', async (req, res) => {
    try {
        const projectId = req.params.id;
        const position = parseInt(req.params.position);
        
        if (isNaN(position) || position < 0) {
            return res.status(400).json({ error: 'Ge√ßersiz pozisyon' });
        }

        const image = await database.getImageByPosition(projectId, position);
        
        if (!image) {
            return res.status(404).json({ error: 'Fotoƒüraf bulunamadƒ±' });
        }

        // Fotoƒürafƒ±n etiketlerini de getir
        const annotations = await database.getImageAnnotations(image.id);

        res.json({
            ...image,
            annotations: annotations
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Debug endpoint - T√ºm weather filters'larƒ± listele
app.get('/api/debug/weather-filters', async (req, res) => {
    try {
        console.log('üîç Debug: T√ºm weather filters listeleniyor');
        const allWeatherFilters = await database.allQuery('SELECT * FROM weather_filters ORDER BY created_at DESC');
        console.log(`üîç Debug: ${allWeatherFilters.length} adet weather filter bulundu`);
        
        const formattedFilters = [];
        allWeatherFilters.forEach(filter => {
            try {
                const filterData = typeof filter.filter_data === 'string' 
                    ? JSON.parse(filter.filter_data) 
                    : filter.filter_data;
                
                formattedFilters.push({
                    id: filter.id,
                    image_id: filter.image_id,
                    created_at: filter.created_at,
                    updated_at: filter.updated_at,
                    filter_data: filterData
                });
            } catch (e) {
                console.error('‚ùå Debug: Weather filter parse edilemedi:', filter.id);
            }
        });
        
        res.json({
            total: allWeatherFilters.length,
            weatherFilters: formattedFilters
        });
    } catch (error) {
        console.error('‚ùå Debug weather filters hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Debug endpoint - T√ºm annotations'larƒ± listele
app.get('/api/debug/annotations', async (req, res) => {
    try {
        console.log('üîç Debug: T√ºm annotations listeleniyor');
        const allAnnotations = await database.allQuery('SELECT * FROM annotations ORDER BY created_at DESC');
        console.log(`üîç Debug: ${allAnnotations.length} adet annotation bulundu`);
        
        const formattedAnnotations = [];
        allAnnotations.forEach(annotation => {
            try {
                const annotationData = typeof annotation.annotation_data === 'string' 
                    ? JSON.parse(annotation.annotation_data) 
                    : annotation.annotation_data;
                
                formattedAnnotations.push({
                    id: annotation.id,
                    image_id: annotation.image_id,
                    created_at: annotation.created_at,
                    annotation_data: annotationData
                });
            } catch (e) {
                console.error('‚ùå Debug: Annotation parse edilemedi:', annotation.id);
            }
        });
        
        res.json({
            total: allAnnotations.length,
            annotations: formattedAnnotations
        });
    } catch (error) {
        console.error('‚ùå Debug annotations hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Belirli bir fotoƒürafƒ±n etiketlerini getir (AUTH YOK)
app.get('/api/images/:id/annotations', async (req, res) => {
    try {
        const imageId = req.params.id;
        console.log(`üìã Fotoƒüraf ${imageId} etiketleri isteniyor`);
        const dbAnnotations = await database.getImageAnnotations(imageId);
        console.log(`üìã Veritabanƒ±ndan ${dbAnnotations.length} adet annotation bulundu`);
        
        // Annotation data'yƒ± parse et ve frontend formatƒ±na √ßevir
        const formattedAnnotations = [];
        
        dbAnnotations.forEach(dbAnnotation => {
            console.log(`üìã DB Annotation ID: ${dbAnnotation.id}, Data:`, dbAnnotation.annotation_data);
            
            try {
                // annotation_data'yƒ± parse et
                const annotationData = typeof dbAnnotation.annotation_data === 'string' 
                    ? JSON.parse(dbAnnotation.annotation_data) 
                    : dbAnnotation.annotation_data;
                
                console.log(`üìã Parsed annotation data:`, annotationData);
                
                // Eƒüer annotations array'i varsa, her birini ayrƒ± annotation olarak ekle
                if (annotationData && annotationData.annotations && Array.isArray(annotationData.annotations)) {
                    annotationData.annotations.forEach(ann => {
                        formattedAnnotations.push({
                            ...ann,
                            dbId: dbAnnotation.id,
                            created_at: dbAnnotation.created_at,
                            updated_at: dbAnnotation.updated_at
                        });
                    });
                } else if (annotationData && annotationData.label) {
                    // Tek annotation formatƒ±
                    formattedAnnotations.push({
                        ...annotationData,
                        dbId: dbAnnotation.id,
                        created_at: dbAnnotation.created_at,
                        updated_at: dbAnnotation.updated_at
                    });
                }
            } catch (parseError) {
                console.error(`‚ùå Annotation ${dbAnnotation.id} parse edilemedi:`, parseError);
            }
        });
        
        console.log(`üìã ${formattedAnnotations.length} adet etiket frontend'e g√∂nderiliyor`);
        res.json(formattedAnnotations);
    } catch (error) {
        console.error('‚ùå Etiket getirme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Belirli bir fotoƒürafa etiket ekle (AUTH YOK - BASIT)
app.post('/api/images/:id/annotations', async (req, res) => {
    try {
        const imageId = req.params.id;
        const { annotations } = req.body; // Sadece annotations array'i al
        
        console.log(`üìù Fotoƒüraf ${imageId} i√ßin ${annotations?.length || 0} etiket kaydediliyor`);
        console.log('üìù Request body:', JSON.stringify(req.body, null, 2));
        console.log('üìù Headers:', req.headers);
        
        if (!annotations || !Array.isArray(annotations)) {
            console.log('‚ùå Annotations array eksik');
            console.log('‚ùå Gelen data:', req.body);
            return res.status(400).json({ error: 'Annotations array gerekli' });
        }

        // √ñnce mevcut etiketleri sil
        await database.deleteImageAnnotations(imageId);
        console.log(`üóëÔ∏è Fotoƒüraf ${imageId} mevcut etiketleri silindi`);

        let savedCount = 0;
        // Her etiket i√ßin ayrƒ± kaydet - her birinin kendi dbId'si olsun
        if (annotations.length > 0) {
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const annotationData = {
                    annotations: [annotation] // Tek etiket kaydet
                };
                
                console.log(`üíæ Server: Etiket ${i + 1}/${annotations.length} kaydediliyor:`, annotation.label);
                const annotationId = await database.addImageAnnotation(imageId, annotationData, 1); // user_id = 1
                console.log(`‚úÖ Server: Etiket kaydedildi, ID: ${annotationId.id}`);
                savedCount++;
            }
        }
        
        console.log(`‚úÖ ${savedCount} adet etiket kaydedildi`);
        
        // Fotoƒürafƒ±n is_labeled durumunu g√ºncelle
        try {
            const isLabeled = savedCount > 0 ? 1 : 0;
            await database.updateImageLabeledStatus(imageId, isLabeled, 1); // labeledBy = 1
            console.log(`üìù Fotoƒüraf ${imageId} is_labeled durumu g√ºncellendi: ${isLabeled}`);
        } catch (error) {
            console.error('‚ùå is_labeled durumu g√ºncellenirken hata:', error);
        }
        
        // Real-time g√ºncelleme: Sadece ger√ßek deƒüi≈üiklik olduƒüunda dashboard'a bildir
        if (savedCount > 0) {
            // üÜï Eklenen etiketlerin detaylarƒ±nƒ± al
            const addedLabels = [];
            annotations.forEach(annotation => {
                if (annotation.label) {
                    addedLabels.push(annotation.label);
                }
            });
            
            io.emit('labelAdded', {
                imageId: imageId,
                savedCount: savedCount,
                addedLabels: addedLabels, // üÜï Eklenen etiket isimleri
                labelNames: [...new Set(addedLabels)], // üÜï Benzersiz etiket isimleri
                timestamp: new Date().toISOString()
            });
            console.log(`üì° Dashboard'a etiket eklendi bildirimi g√∂nderildi: ${savedCount} etiket, isimler: ${addedLabels.join(', ')}`);
        } else {
            console.log('üì° Etiket deƒüi≈üikliƒüi yok, WebSocket bildirimi atlandƒ±');
        }
        
        // Proje √∂zetini de g√ºncelle (etiket sayƒ±sƒ± i√ßin)
        try {
            // Fotoƒürafƒ±n hangi projeye ait olduƒüunu bul
            const image = await database.getImageById(imageId);
            if (image && image.project_id) {
                console.log(`üìä Proje ${image.project_id} etiket sayƒ±sƒ± g√ºncelleniyor...`);
                // Proje √∂zeti otomatik olarak g√ºncellenecek (database'de trigger var)
            }
        } catch (error) {
            console.error('‚ùå Proje √∂zeti g√ºncelleme hatasƒ±:', error);
        }
        
        res.json({
            success: true,
            saved_count: savedCount,
            message: `${savedCount} etiket kaydedildi`
        });
    } catch (error) {
        console.error('‚ùå Etiket kaydetme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Belirli bir etiket g√ºncelle
app.put('/api/annotations/:id', async (req, res) => {
    try {
        const annotationId = req.params.id;
        const { annotation_data } = req.body;
        
        if (!annotation_data) {
            return res.status(400).json({ error: 'Etiket verisi gerekli' });
        }

        await database.updateAnnotation(annotationId, annotation_data);
        
        res.json({
            success: true,
            message: 'Etiket g√ºncellendi'
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Belirli bir etiket sil
app.delete('/api/annotations/:id', async (req, res) => {
    try {
        const annotationId = req.params.id;
        console.log(`üóëÔ∏è API: Annotation siliniyor, ID: ${annotationId}`);
        
        const result = await database.deleteAnnotation(annotationId);
        
        // Etiket bulunamadƒ±ysa veya zaten silinmi≈üse
        if (!result.success || result.changes === 0) {
            return res.status(404).json({ error: 'Etiket bulunamadƒ± veya zaten silinmi≈ü' });
        }

        // Silinen etiket ismini al (database'den geldi)
        const deletedLabelName = result.deletedLabelName;

        // üÜï Real-time g√ºncelleme: Etiket silindi bildirimi
        io.emit('labelDeleted', {
            annotationId: annotationId,
            deletedCount: result.changes,
            deletedLabelName: deletedLabelName, // üÜï Silinen etiket ismi
            timestamp: new Date().toISOString()
        });
        console.log(`üì° Dashboard'a etiket silindi bildirimi g√∂nderildi: ${result.changes} etiket, isim: ${deletedLabelName || 'Bilinmeyen'}`);
        
        res.json({
            success: true,
            message: 'Etiket silindi',
            changes: result.changes
        });
    } catch (error) {
        console.error('‚ùå API: Annotation silme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});
// Belirli bir fotoƒürafƒ±n t√ºm etiketlerini sil
app.delete('/api/images/:id/annotations', async (req, res) => {
    try {
        const imageId = req.params.id;
        const deletedCount = await database.deleteImageAnnotations(imageId);
        
        // üÜï Real-time g√ºncelleme: T√ºm etiketler silindi bildirimi
        io.emit('labelDeleted', {
            imageId: imageId,
            deletedCount: deletedCount || 0,
            timestamp: new Date().toISOString(),
            allAnnotations: true
        });
        console.log(`üì° Dashboard'a t√ºm etiketler silindi bildirimi g√∂nderildi: ${deletedCount || 0} etiket`);
        
        res.json({
            success: true,
            message: 'T√ºm etiketler silindi',
            deletedCount: deletedCount || 0
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Weather filter endpoint'leri
// Belirli bir fotoƒürafƒ±n weather filter'ƒ±nƒ± getir
app.get('/api/images/:id/weather-filter', async (req, res) => {
    try {
        const imageId = req.params.id;
        console.log(`üå§Ô∏è Fotoƒüraf ${imageId} weather filter'ƒ± isteniyor`);
        
        const weatherFilter = await database.getImageWeatherFilter(imageId);
        
        if (weatherFilter) {
            console.log(`‚úÖ Weather filter bulundu:`, weatherFilter.filter_data);
            res.json({
                success: true,
                weatherFilter: weatherFilter
            });
        } else {
            console.log(`‚ÑπÔ∏è Weather filter bulunamadƒ±, varsayƒ±lan d√∂nd√ºr√ºl√ºyor`);
            res.json({
                success: true,
                weatherFilter: null,
                message: 'Weather filter bulunamadƒ±'
            });
        }
    } catch (error) {
        console.error('‚ùå Weather filter getirme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Belirli bir fotoƒürafƒ±n weather filter'ƒ±nƒ± kaydet/g√ºncelle
app.post('/api/images/:id/weather-filter', async (req, res) => {
    try {
        const imageId = req.params.id;
        const { filterData, filter_data } = req.body;
        
        // Hem filterData hem de filter_data formatƒ±nƒ± destekle
        const actualFilterData = filterData || filter_data;
        
        console.log(`üå§Ô∏è Fotoƒüraf ${imageId} i√ßin weather filter kaydediliyor:`, actualFilterData);
        
        if (!actualFilterData) {
            console.log('‚ùå Filter data eksik');
            return res.status(400).json({ error: 'Filter data gerekli' });
        }

        // Weather filter'ƒ± kaydet/g√ºncelle
        const filterId = await database.updateImageWeatherFilter(imageId, actualFilterData, 1); // user_id = 1
        
        console.log(`‚úÖ Weather filter kaydedildi, ID: ${filterId}`);
        
        // üÜï Real-time g√ºncelleme: Dashboard'a bildir
        io.emit('weatherFiltersUpdated', {
            imageId: imageId,
            filterData: actualFilterData,
            weatherFilters: actualFilterData, // Daha uyumlu format
            timestamp: new Date().toISOString()
        });
        console.log(`üì° Dashboard'a weather filter g√ºncellendi bildirimi g√∂nderildi`);
        
        res.json({
            success: true,
            filterId: filterId,
            message: 'Weather filter ba≈üarƒ±yla kaydedildi'
        });
    } catch (error) {
        console.error('‚ùå Weather filter kaydetme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Belirli bir fotoƒürafƒ±n weather filter'ƒ±nƒ± sil
app.delete('/api/images/:id/weather-filter', async (req, res) => {
    try {
        const imageId = req.params.id;
        console.log(`üóëÔ∏è Fotoƒüraf ${imageId} weather filter'ƒ± siliniyor`);
        
        const deletedCount = await database.deleteImageWeatherFilter(imageId);
        
        console.log(`‚úÖ ${deletedCount} weather filter silindi`);

        // üÜï Real-time g√ºncelleme: Weather filter silindi bildirimi
        io.emit('weatherFiltersUpdated', {
            imageId: imageId,
            deleted: true,
            deletedCount: deletedCount,
            timestamp: new Date().toISOString()
        });
        console.log(`üì° Dashboard'a weather filter silindi bildirimi g√∂nderildi`);
        
        res.json({
            success: true,
            message: 'Weather filter silindi',
            deletedCount: deletedCount
        });
    } catch (error) {
        console.error('‚ùå Weather filter silme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Favori etiket API'leri
// Projeye favori etiket ekle
app.post('/api/projects/:id/favorite-labels', async (req, res) => {
    try {
        const projectId = req.params.id;
        const { labelName } = req.body;
        const userId = 1; // ≈ûimdilik sabit user_id
        
        console.log(`‚≠ê Proje ${projectId} i√ßin favori etiket ekleniyor: ${labelName}`);
        
        if (!labelName || labelName.trim() === '') {
            return res.status(400).json({ error: 'Etiket adƒ± gerekli' });
        }
        
        const favoriteId = await database.addFavoriteLabel(projectId, userId, labelName.trim());
        
        console.log(`‚úÖ Favori etiket eklendi, ID: ${favoriteId}`);
        
        res.json({
            success: true,
            favoriteId: favoriteId,
            message: 'Favori etiket eklendi'
        });
    } catch (error) {
        console.error('‚ùå Favori etiket ekleme hatasƒ±:', error);
        
        // UNIQUE constraint hatasƒ± kontrol√º
        if (error.code === 'SQLITE_CONSTRAINT' && error.message.includes('UNIQUE constraint failed')) {
            return res.status(409).json({ 
                error: 'Bu etiket zaten favorilerde!',
                code: 'DUPLICATE_FAVORITE'
            });
        }
        
        res.status(500).json({ error: error.message });
    }
});

// Projenin favori etiketlerini getir
app.get('/api/projects/:id/favorite-labels', async (req, res) => {
    try {
        const projectId = req.params.id;
        const userId = 1; // ≈ûimdilik sabit user_id
        
        console.log(`‚≠ê Proje ${projectId} favori etiketleri getiriliyor`);
        
        const favoriteLabels = await database.getFavoriteLabels(projectId, userId);
        
        console.log(`‚úÖ ${favoriteLabels.length} favori etiket bulundu`);
        
        res.json({
            success: true,
            favoriteLabels: favoriteLabels
        });
    } catch (error) {
        console.error('‚ùå Favori etiket getirme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Projeden favori etiket sil
app.delete('/api/projects/:id/favorite-labels/:labelName', async (req, res) => {
    try {
        const projectId = req.params.id;
        const labelName = decodeURIComponent(req.params.labelName);
        const userId = 1; // ≈ûimdilik sabit user_id
        
        console.log(`üóëÔ∏è Proje ${projectId} favori etiketi siliniyor: ${labelName}`);
        
        const deletedCount = await database.removeFavoriteLabel(projectId, userId, labelName);
        
        console.log(`‚úÖ ${deletedCount} favori etiket silindi`);
        
        res.json({
            success: true,
            message: 'Favori etiket silindi',
            deletedCount: deletedCount
        });
    } catch (error) {
        console.error('‚ùå Favori etiket silme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Belirli bir fotoƒürafƒ± sil (etiketleriyle birlikte)
app.delete('/api/images/:id', async (req, res) => {
    try {
        const imageId = req.params.id;
        
        // √ñnce etiketleri sil
        await database.deleteImageAnnotations(imageId);
        
        // Sonra fotoƒürafƒ± sil
        await database.deleteImage(imageId);
        
        res.json({
            success: true,
            message: 'Fotoƒüraf ve etiketleri silindi'
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Proje detaylƒ± istatistikleri (kullanƒ±cƒ± bazƒ±nda etiket sayƒ±larƒ± i√ßin)
app.get('/api/projects/:id/detailed-stats', async (req, res) => {
    try {
        const projectId = req.params.id;
        
        // Proje bilgileri
        const project = await database.getProject(projectId);
        if (!project) {
            return res.status(404).json({ error: 'Proje bulunamadƒ±' });
        }

        // Proje g√∂r√ºnt√ºleri ve etiketleri
        const images = await database.getProjectImages(projectId);
        
        // Her resim i√ßin etiket sayƒ±sƒ±
        let totalLabels = 0;
        let labeledImages = 0;
        const labelCounts = {};
        
        for (const image of images) {
            const annotations = await database.getImageAnnotations(image.id);
            let imageLabels = 0;
            
            annotations.forEach(annotation => {
                if (annotation.annotation_data && annotation.annotation_data.annotations) {
                    imageLabels += annotation.annotation_data.annotations.length;
                    
                    // Label t√ºrlerini say
                    annotation.annotation_data.annotations.forEach(ann => {
                        if (ann.label) {
                            labelCounts[ann.label] = (labelCounts[ann.label] || 0) + 1;
                        }
                    });
                }
            });
            
            totalLabels += imageLabels;
            if (imageLabels > 0) labeledImages++;
        }

        res.json({
            project: {
                id: project.id,
                name: project.name,
                totalImages: images.length,
                labeledImages: labeledImages,
                totalLabels: totalLabels,
                completionRate: images.length > 0 ? Math.round((labeledImages / images.length) * 100) : 0
            },
            labelCounts: labelCounts,
            recentActivity: await database.getProjectAnnotationStats(projectId)
        });
        
    } catch (error) {
        console.error('‚ùå Proje istatistikleri hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Proje mevcut pozisyonunu g√ºncelle
app.put('/api/projects/:id/position', async (req, res) => {
    try {
        const projectId = req.params.id;
        const { current_index } = req.body;
        
        if (typeof current_index !== 'number' || current_index < 0) {
            return res.status(400).json({ error: 'Ge√ßersiz pozisyon' });
        }

        await database.updateProjectPosition(projectId, current_index);
        
        res.json({
            success: true,
            message: 'Pozisyon g√ºncellendi',
            current_index: current_index
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Fotoƒürafƒ± etiketli olarak i≈üaretle
app.put('/api/images/:id/mark-labeled', async (req, res) => {
    try {
        const imageId = req.params.id;
        const { annotation_data, label_name, username } = req.body;
        
        console.log('üìù Etiket kaydediliyor:', { imageId, annotation_data, label_name, username });
        
        // Frontend'den gelen annotation_data'yƒ± kullan
        if (annotation_data) {
            // Etiket verilerini kaydet
            await database.saveAnnotation(imageId, annotation_data, 1);
            
            // Fotoƒürafƒ± etiketli olarak i≈üaretle
            await database.markImageAsLabeled(imageId, 1);
            
            res.json({
                success: true,
                message: 'Fotoƒüraf etiketli olarak i≈üaretlendi',
                annotation_data: annotation_data
            });
        } else if (label_name && username) {
            // Eski format i√ßin geriye d√∂n√ºk uyumluluk
            const simpleAnnotationData = {
                label: label_name,
                username: username,
                timestamp: new Date().toISOString()
            };
            
            await database.saveAnnotation(imageId, simpleAnnotationData, 1);
            await database.markImageAsLabeled(imageId, 1);
            
            res.json({
                success: true,
                message: 'Fotoƒüraf etiketli olarak i≈üaretlendi',
                label: label_name
            });
        } else {
            return res.status(400).json({ error: 'Etiket verisi gerekli' });
        }
    } catch (error) {
        console.error('‚ùå Etiket kaydetme hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Fotoƒürafƒ± etiketlenmemi≈ü olarak i≈üaretle
app.put('/api/images/:id/mark-unlabeled', async (req, res) => {
    try {
        const imageId = req.params.id;
        
        await database.markImageAsUnlabeled(imageId);
        
        res.json({
            success: true,
            message: 'Fotoƒüraf etiketlenmemi≈ü olarak i≈üaretlendi'
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Etiket istatistikleri API'leri
app.get('/api/analytics/labels', async (req, res) => {
    try {
        const annotations = await database.getLabelStatistics();
        
        // Etiket sayƒ±larƒ±nƒ± hesapla
        const labelCounts = {};
        const projectStats = {};
        let totalAnnotations = 0;
        
        annotations.forEach(annotation => {
            const projectName = annotation.project_name;
            const projectId = annotation.project_id;
            
            if (!projectStats[projectId]) {
                projectStats[projectId] = {
                    name: projectName,
                    labels: {},
                    total: 0
                };
            }
            
            if (annotation.annotation_data && annotation.annotation_data.annotations) {
                annotation.annotation_data.annotations.forEach(ann => {
                    const label = ann.label || 'Etiketlenmemi≈ü';
                    
                    // Global sayƒ±m
                    labelCounts[label] = (labelCounts[label] || 0) + 1;
                    totalAnnotations++;
                    
                    // Proje bazƒ±nda sayƒ±m
                    projectStats[projectId].labels[label] = (projectStats[projectId].labels[label] || 0) + 1;
                    projectStats[projectId].total++;
                });
            }
        });
        
        // Oranlarƒ± hesapla
        const labelStats = Object.entries(labelCounts).map(([label, count]) => ({
            label,
            count,
            percentage: totalAnnotations > 0 ? ((count / totalAnnotations) * 100).toFixed(2) : 0
        })).sort((a, b) => b.count - a.count);
        
        // Proje bazƒ±nda istatistikler
        const projectLabelStats = Object.values(projectStats).map(project => ({
            projectName: project.name,
            totalLabels: project.total,
            labels: Object.entries(project.labels).map(([label, count]) => ({
                label,
                count,
                percentage: project.total > 0 ? ((count / project.total) * 100).toFixed(2) : 0
            })).sort((a, b) => b.count - a.count)
        }));
        
        res.json({
            success: true,
            data: {
                totalAnnotations,
                labelStats,
                projectLabelStats,
                summary: {
                    uniqueLabels: labelStats.length,
                    mostUsedLabel: labelStats[0] || null,
                    leastUsedLabel: labelStats[labelStats.length - 1] || null
                }
            }
        });
    } catch (error) {
        console.error('‚ùå Etiket istatistikleri hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Kullanƒ±cƒ± etiket istatistikleri
app.get('/api/analytics/users', async (req, res) => {
    try {
        const userStats = await database.getUserAnnotationStats();
        
        res.json({
            success: true,
            data: userStats
        });
    } catch (error) {
        console.error('‚ùå Kullanƒ±cƒ± istatistikleri hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Proje bazƒ±nda etiket istatistikleri
app.get('/api/analytics/projects/:id/labels', async (req, res) => {
    try {
        const projectId = req.params.id;
        const annotations = await database.getProjectAnnotationStats(projectId);
        
        // Etiket sayƒ±larƒ±nƒ± hesapla
        const labelCounts = {};
        let totalAnnotations = 0;
        
        annotations.forEach(annotation => {
            if (annotation.annotation_data && annotation.annotation_data.annotations) {
                annotation.annotation_data.annotations.forEach(ann => {
                    const label = ann.label || 'Etiketlenmemi≈ü';
                    labelCounts[label] = (labelCounts[label] || 0) + 1;
                    totalAnnotations++;
                });
            }
        });
        
        // Oranlarƒ± hesapla
        const labelStats = Object.entries(labelCounts).map(([label, count]) => ({
            label,
            count,
            percentage: totalAnnotations > 0 ? ((count / totalAnnotations) * 100).toFixed(2) : 0
        })).sort((a, b) => b.count - a.count);
        
        res.json({
            success: true,
            data: {
                projectId,
                totalAnnotations,
                labelStats,
                summary: {
                    uniqueLabels: labelStats.length,
                    mostUsedLabel: labelStats[0] || null,
                    leastUsedLabel: labelStats[labelStats.length - 1] || null
                }
            }
        });
    } catch (error) {
        console.error('‚ùå Proje etiket istatistikleri hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Label Analytics endpoint
app.get('/api/label-analytics', async (req, res) => {
    try {
        console.log('üìä Etiket analizi endpoint √ßaƒürƒ±ldƒ±');
        
        const projects = await database.getAllProjects();
        let totalLabels = 0;
        let labelStatsCount = 0;
        
        for (const project of projects) {
            const stats = await database.getProjectAnnotationStats(project.id);
            totalLabels += stats.totalAnnotations;
            labelStatsCount += stats.labelStats.length;
        }
        
        const response = {
            totalLabels,
            labelStatsCount,
            projectsCount: projects.length
        };
        
        console.log('üìä Analytics response:', response);
        res.json(response);
    } catch (error) {
        console.error('‚ùå Label analytics hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Annotation Stats endpoint
app.get('/api/projects/:id/annotation-stats', async (req, res) => {
    try {
        const projectId = parseInt(req.params.id);
        const stats = await database.getProjectAnnotationStats(projectId);
        res.json(stats);
    } catch (error) {
        console.error('‚ùå Annotation stats hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Labels endpoint
app.get('/api/labels', async (req, res) => {
    try {
        const labels = await database.getAllLabels();
        res.json(labels);
    } catch (error) {
        console.error('‚ùå Labels hatasƒ±:', error);
        res.status(500).json({ error: error.message });
    }
});

// Dashboard route
app.get('/dashboard', (req, res) => {
    res.sendFile(path.join(__dirname, '../dashboard/index.html'));
});

// Etiketleme uygulamasƒ± route
app.get('/app', (req, res) => {
    res.sendFile(path.join(__dirname, '../labeling-app/index.html'));
});

// Dosya yolu endpoint'i kaldƒ±rƒ±ldƒ± - artƒ±k direkt dosya yolundan √ßekiliyor

// Error handling middleware
app.use((err, req, res, next) => {
    console.error('‚ùå Server hatasƒ±:', err);
    res.status(500).json({ error: 'Sunucu hatasƒ±' });
});

// 404 handler
app.use((req, res) => {
    res.status(404).json({ error: 'Endpoint bulunamadƒ±' });
});

// Graceful shutdown
process.on('SIGINT', () => {
    console.log('\nüõë Server kapatƒ±lƒ±yor...');
    database.close();
    process.exit(0);
});

// WebSocket connection handling
const connectedUsers = new Map(); // Baƒülƒ± kullanƒ±cƒ±larƒ± takip et

io.on('connection', (socket) => {
    console.log('üîå Yeni kullanƒ±cƒ± baƒülandƒ±:', socket.id);
    
    // JWT token ile authentication
    socket.on('authenticate', async (token) => {
        try {
            const decoded = auth.verifyToken(token);
            if (decoded) {
                socket.userId = decoded.id;
                socket.username = decoded.username;
                connectedUsers.set(socket.id, {
                    userId: decoded.id,
                    username: decoded.username,
                    socketId: socket.id
                });
                
                console.log(`‚úÖ Kullanƒ±cƒ± doƒürulandƒ±: ${decoded.username} (${socket.id})`);
                socket.emit('authenticated', { success: true, username: decoded.username });
            } else {
                socket.emit('authError', { error: 'Ge√ßersiz token' });
            }
        } catch (error) {
            console.error('‚ùå WebSocket auth hatasƒ±:', error);
            socket.emit('authError', { error: 'Authentication ba≈üarƒ±sƒ±z' });
        }
    });
    
    // Projeye katƒ±lma
    socket.on('joinProject', (projectId) => {
        if (socket.username) {
            const roomName = `project_${projectId}`;
            socket.join(roomName);
            socket.currentProject = projectId;
            
            console.log(`üë• ${socket.username} projeye katƒ±ldƒ±: ${projectId}`);
            
            // Diƒüer kullanƒ±cƒ±lara bildir
            socket.to(roomName).emit('userJoined', {
                username: socket.username,
                projectId: projectId,
                timestamp: new Date().toISOString()
            });
            
            // Odadaki kullanƒ±cƒ± sayƒ±sƒ±nƒ± g√∂nder
            const room = io.sockets.adapter.rooms.get(roomName);
            const userCount = room ? room.size : 0;
            io.to(roomName).emit('roomStats', { userCount, projectId });
        }
    });
    
    // Projeden ayrƒ±lma
    socket.on('leaveProject', (projectId) => {
        if (socket.username) {
            const roomName = `project_${projectId}`;
            socket.leave(roomName);
            socket.currentProject = null;
            
            console.log(`üëã ${socket.username} projeden ayrƒ±ldƒ±: ${projectId}`);
            
            // Diƒüer kullanƒ±cƒ±lara bildir
            socket.to(roomName).emit('userLeft', {
                username: socket.username,
                projectId: projectId,
                timestamp: new Date().toISOString()
            });
            
            // Odadaki kullanƒ±cƒ± sayƒ±sƒ±nƒ± g√ºncelle
            const room = io.sockets.adapter.rooms.get(roomName);
            const userCount = room ? room.size : 0;
            io.to(roomName).emit('roomStats', { userCount, projectId });
        }
    });
    
    // Baƒülantƒ± koptuƒüunda temizlik
    socket.on('disconnect', () => {
        if (socket.currentProject) {
            const roomName = `project_${socket.currentProject}`;
            socket.to(roomName).emit('userLeft', {
                username: socket.username,
                projectId: socket.currentProject,
                timestamp: new Date().toISOString()
            });
            
            // Odadaki kullanƒ±cƒ± sayƒ±sƒ±nƒ± g√ºncelle
            const room = io.sockets.adapter.rooms.get(roomName);
            const userCount = room ? room.size : 0;
            io.to(roomName).emit('roomStats', { userCount, projectId: socket.currentProject });
        }
        
        connectedUsers.delete(socket.id);
        console.log(`üîå Kullanƒ±cƒ± baƒülantƒ±sƒ± koptu: ${socket.username || socket.id}`);
    });
});

server.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ Server √ßalƒ±≈üƒ±yor: http://0.0.0.0:${PORT}`);
    console.log(`üìä Dashboard: http://localhost:${PORT}/dashboard`);
    console.log(`üè∑Ô∏è Etiketleme: http://localhost:${PORT}/app`);
    console.log(`üë§ Varsayƒ±lan admin: admin`);
    console.log(`üîå WebSocket desteƒüi aktif`);
    console.log(`üåê Aƒü eri≈üimi: Aynƒ± aƒüdaki t√ºm cihazlardan eri≈üilebilir`);
});
